<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[AlexYoung's blog]]></title>
  <subtitle><![CDATA[当你的才华还撑不起你的野心时，你就应该静下心来学习。]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://alexyyek.github.io/"/>
  <updated>2015-05-01T09:10:38.349Z</updated>
  <id>http://alexyyek.github.io/</id>
  
  <author>
    <name><![CDATA[AlexYoung]]></name>
    <email><![CDATA[alexyyek@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[LinkedList]]></title>
    <link href="http://alexyyek.github.io/2015/05/01/LinkedList/"/>
    <id>http://alexyyek.github.io/2015/05/01/LinkedList/</id>
    <published>2015-05-01T09:00:09.000Z</published>
    <updated>2015-05-01T09:04:51.000Z</updated>
    <content type="html"><![CDATA[<p>本篇博客重点剖析继承Collection接口中的LinkedList类，JDK源码版本基于1.8.0_25。</p>
<h2 id="LinkedList概述">LinkedList概述</h2>
<p>LinkedList与ArrayList一样实现List接口，只是ArrayList是List接口的大小可变数组的实现，LinkedList是List接口链表的实现。基于链表实现的方式使得LinkedList在插入和删除时更优于ArrayList，而随机访问则比ArrayList逊色些。LinkedList继承于AbstractSequentialList，实现了List, Deque, Cloneable, java.io.Serializable这些接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">java.lang.Object</div><div class="line">   ↳     java.util.AbstractCollection&lt;E&gt;</div><div class="line">         ↳     java.util.AbstractList&lt;E&gt;</div><div class="line">               ↳     java.util.AbstractSequentialList&lt;E&gt;</div><div class="line">                     ↳     java.util.LinkedList&lt;E&gt;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</div><div class="line">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> {}</div></pre></td></tr></table></figure>

<ul>
<li>继承 AbstractSequentialList：双向链表，可以被当作堆栈、队列或双端队列进行操作。</li>
<li>Deque 接口：为 add、poll 提供先进先出队列操作，从而能将LinkedList当作双端队列使用。</li>
<li>Cloneable接口：覆盖了函数clone()，Returns a shallow copy of this ArrayList instance.</li>
<li>Serializable接口：ArrayList支持序列化，能通过序列化去传输。</li>
</ul>
<p>稍微提及一下AbstractSequentialList，AbstractSequentialList继承AbstractList，对其中的方法进行再抽象，不同于动态数组列表ArrayList。</p>
<p>AbstractSequentialList在功能上，最大限度地减少了实现受“连续访问”数据存储（如链接列表）支持的此接口所需的工作。说白了就是你的列表需要快速的添加删除数据等，用此抽象类，若是需要快速随机的访问数据等用AbstractList抽象类。</p>
<blockquote>
<p>JDK 1.8.0_25：This class provides a skeletal implementation of the List interface to minimize the effort required to implement this interface backed by a “<strong>sequential access</strong>“ data store. </p>
</blockquote>
<p>同ArrayList一样，LinkedList中的操作不是线程安全的，所以为了防止意外的非同步访问，最好在创建时声明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List list = Collections.synchronizedList(<span class="keyword">new</span> LinkedList(...));</div></pre></td></tr></table></figure>

<p>LinkedList与Collection的关系：</p>
<p><center> <img src="http://alexyoung.qiniudn.com/272345393446232.jpg" alt=""> <center></center></center></p>
<p>LinkedList包含三个重要的成员：first、last 和 size。</p>
<ul>
<li><code>transient Node&lt;E&gt; first</code>：双向链表的表头，它是双向链表节点所对应的类Node的实例。Node中包含成员变量：prev, next, item。</li>
<li><code>transient Node&lt;E&gt; last</code>：双向链表的表尾。</li>
<li><code>transient int size</code>：双向链表中节点的个数。</li>
</ul>
<h2 id="构造方法">构造方法</h2>
<p>LinkedList实现了一个双向列表，由first字段和last字段指向列表的头部和尾部。列表的每个节点是一个Node对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>{</div><div class="line">        E item;</div><div class="line">        Node&lt;E&gt; next;</div><div class="line">        Node&lt;E&gt; prev;</div><div class="line"></div><div class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) {</div><div class="line">            <span class="keyword">this</span>.item = element;</div><div class="line">            <span class="keyword">this</span>.next = next;</div><div class="line">            <span class="keyword">this</span>.prev = prev;</div><div class="line">        }</div><div class="line">    }</div></pre></td></tr></table></figure>

<p>LinkedList提供了两个构造方法：LinkedList()和LinkedList(Collection&lt;? extends E&gt; c)。</p>
<p>前一个构造方法为空，里面不含任何元素。后者构造一个包含指定 collection 中的元素的列表。构造函数首先会调用LinkedList()，构造一个空列表，然后调用了addAll()方法将Collection中的所有元素添加到列表中。addAll()源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span>(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c) {</div><div class="line">        <span class="comment">//若插入的位置小于0或者大于链表长度，则抛出IndexOutOfBoundsException异常</span></div><div class="line">        checkPositionIndex(index);</div><div class="line">        </div><div class="line">        Object[] a = c.toArray();</div><div class="line">        <span class="keyword">int</span> numNew = a.length;<span class="comment">//插入元素个数</span></div><div class="line">        <span class="keyword">if</span> (numNew == <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        Node&lt;E&gt; pred, succ;     <span class="comment">//定义前导与后继</span></div><div class="line">        <span class="keyword">if</span> (index == size) {    <span class="comment">//如果在队尾插入</span></div><div class="line">            succ = <span class="keyword">null</span>;    <span class="comment">//后继置空</span></div><div class="line">            pred = last;    <span class="comment">//前导指向队尾元素last</span></div><div class="line">        } <span class="keyword">else</span> {            <span class="comment">//在指定位置插入</span></div><div class="line">            succ = node(index); <span class="comment">//后继指向该位置</span></div><div class="line">            pred = succ.prev;   <span class="comment">//先导指向前一个元素</span></div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (Object o : a) {</div><div class="line">            <span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) o;</div><div class="line">            Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);<span class="comment">//创建一个新节点，指定先导，后继置空</span></div><div class="line">            <span class="keyword">if</span> (pred == <span class="keyword">null</span>)<span class="comment">//如果先导不存在</span></div><div class="line">                first = newNode;<span class="comment">//表头first指向此节点</span></div><div class="line">            <span class="keyword">else</span></div><div class="line">                pred.next = newNode;<span class="comment">//先导存在，则将其next指向新节点</span></div><div class="line">            pred = newNode;<span class="comment">//先导移动，继续创建新节点</span></div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (succ == <span class="keyword">null</span>) {</div><div class="line">            last = pred;</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            pred.next = succ;</div><div class="line">            succ.prev = pred;</div><div class="line">        }</div><div class="line"></div><div class="line">        size += numNew;</div><div class="line">        modCount++;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div></pre></td></tr></table></figure>

<h2 id="外部方法">外部方法</h2>
<p>LinkedList提供了一堆linkXX和unlinkXX辅助方法，用来往列表中插入元素和删除元。</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">linkFirst</td>
<td style="text-align:center">插入头部</td>
</tr>
<tr>
<td style="text-align:center">linkLast</td>
<td style="text-align:center">插入尾部</td>
</tr>
<tr>
<td style="text-align:center">linkBefore</td>
<td style="text-align:center">插入到某个节点前</td>
</tr>
<tr>
<td style="text-align:center">unlinkFirst</td>
<td style="text-align:center">删除头部</td>
</tr>
<tr>
<td style="text-align:center">unlinkLast</td>
<td style="text-align:center">删除尾部</td>
</tr>
<tr>
<td style="text-align:center">unlink</td>
<td style="text-align:center">删除某节点</td>
</tr>
</tbody>
</table>
<p>接下来是一些向外暴露的接口的方法，get、remove、add等类型的方法。用到了之前的那些辅助方法。还有一些获取当前状态的方法，比如size、isEmpty、contains，一些方法是父类的方法。</p>
<p>唯一值得拿出来说的是在get、set、add、remove中都有调用的node方法，它将输入的index与链表长度的1/2进行对比，如果小于链表长度的一半，就从表头first开始操作；否则就从last开始，从而节省一半的查找时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Node&lt;E&gt; node(<span class="keyword">int</span> index) {</div><div class="line">        <span class="comment">// assert isElementIndex(index);</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) {</div><div class="line">            Node&lt;E&gt; x = first;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</div><div class="line">                x = x.next;</div><div class="line">            <span class="keyword">return</span> x;</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            Node&lt;E&gt; x = last;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</div><div class="line">                x = x.prev;</div><div class="line">            <span class="keyword">return</span> x;</div><div class="line">        }</div><div class="line">    }</div></pre></td></tr></table></figure>

<p>此外遍历LinkedList时切忌不要sillyB到使用随机访问去遍历，建议使用迭代器或for循环。不然你将感受到地狱。</p>
<h2 id="fast-fail机制">fast-fail机制</h2>
<p>讲了ArrayList和LinkedList，最后讲讲两者面对多线程对同一个集合操作时，可能会产生的fail-fast事件。</p>
<p>fail-fast 机制是java集合(Collection)中的一种错误机制。简单来说就是当某一个线程遍历list的过程中，list的内容被另外一个线程所改变了；就会抛出ConcurrentModificationException异常，产生fail-fast事件。</p>
<h3 id="解决方案">解决方案</h3>
<p>fail-fast机制，是一种错误检测机制。它只能被用来检测错误，因为JDK并不保证fail-fast机制一定会发生。若在多线程环境下使用fail-fast机制的集合，建议使用“java.util.concurrent包下的类”去取代“java.util包下的类”。</p>
<p>所以，本例中只需要将ArrayList替换成java.util.concurrent包下对应的类即可。即，将代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div></pre></td></tr></table></figure>

<p>替换为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;String&gt;();</div></pre></td></tr></table></figure>

<h3 id="抛出异常原理">抛出异常原理</h3>
<p>原理很简单，在AbstractList里定义了一个叫modCount的玩意。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</div></pre></td></tr></table></figure>

<p>这货存在的全部意义就是在有操作对List进行修改时，自加一。例如在ArrayList里的 ensureExplicitCapacity 方法，remove方法，clear方法等等。</p>
<p>产生fail-fast事件，是通过抛出ConcurrentModificationException异常来触发的。而ConcurrentModificationException是在操作Iterator时抛出的异常。</p>
<p>再查看Iterator的源码你会发现，Iterator里定义了一个叫expectedModCount的变量，<code>初始化等于modCount的值</code>。</p>
<p>所以每次遍历List中的元素的时候，都会比较 expectedModCount 和 modCount 是否相等。如果不相等则抛出异常。</p>
<p>那么什么时候 modCount 不等于 expectedModCount呢？查看ArrayList的源码，如上面所说，无论是 ensureExplicitCapacity()、add()、remove()，还是clear()，只要涉及到修改集合中的元素个数时，都会改变modCount的值。</p>
<p>总结一下就是当多个线程对同一个集合进行操作的时候，某线程访问集合的过程中，该集合的内容被其他线程所改变(即其它线程通过add、remove、clear等方法，改变了modCount的值)；这时，就会抛出ConcurrentModificationException异常，产生fail-fast事件。</p>
<h3 id="解决原理">解决原理</h3>
<p>查看和ArrayList对应的CopyOnWriteArrayList的源码。举个最简单的例子add方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span>(E e) {</div><div class="line">       <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">       lock.lock();</div><div class="line">       <span class="keyword">try</span> {</div><div class="line">           Object[] elements = getArray(); <span class="comment">//copy一份原来的array</span></div><div class="line">           <span class="keyword">int</span> len = elements.length;</div><div class="line">           Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>); </div><div class="line">           newElements[len] = e; <span class="comment">//在copy的数组上add</span></div><div class="line">           setArray(newElements); <span class="comment">//原有引用指向修改后的数据</span></div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       } <span class="keyword">finally</span> {</div><div class="line">           lock.unlock();</div><div class="line">       }</div><div class="line">   }</div></pre></td></tr></table></figure>

<p>CopyOnWriteArrayList的add、set、remove等会改变原数组的方法中，都是先copy一份原来的array，再在copy数组上进行add、set、remove操作。然后把原有数据的引用改成指向修改后的数据，这就才不影响COWIterator那份数组。</p>
]]></content>
    <summary type="html">
    <![CDATA[The LinkedList class extends AbstractSequentialList and implements the List interface. LinkedList supports sequential access data store.]]>
    
    </summary>
    
      <category term="coding" scheme="http://alexyyek.github.io/tags/coding/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ArrayList]]></title>
    <link href="http://alexyyek.github.io/2015/04/12/ArrayList/"/>
    <id>http://alexyyek.github.io/2015/04/12/ArrayList/</id>
    <published>2015-04-12T08:42:16.000Z</published>
    <updated>2015-04-12T11:13:49.000Z</updated>
    <content type="html"><![CDATA[<p>在上一篇<a href="http://alexyyek.github.io/2015/04/06/Collection/" target="_blank" rel="external">博客</a>中，我们基本了解了Java容器类的架构。本篇博客重点剖析继承Collection接口中的ArrayList类，JDK源码版本基于1.8.0_25。</p>
<h2 id="ArrayList概述">ArrayList概述</h2>
<p>ArrayList 是一个数组队列，相当于动态数组。与Java中的数组相比，它的容量能动态增长。它继承于AbstractList，实现了List, RandomAccess, Cloneable, java.io.Serializable这些接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">java.lang.Object</div><div class="line">   ↳     java.util.AbstractCollection&lt;E&gt;</div><div class="line">         ↳     java.util.AbstractList&lt;E&gt;</div><div class="line">               ↳     java.util.ArrayList&lt;E&gt;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> {}</div></pre></td></tr></table></figure>

<ul>
<li>继承AbstractList：实现数组基本的添加、删除、修改、遍历等功能</li>
<li>RandmoAccess接口：support fast (generally constant time) random access</li>
<li>Cloneable接口：覆盖clone()方法，Returns a shallow copy of this ArrayList instance</li>
<li>Serializable接口：ArrayList支持序列化，能通过序列化去传输</li>
</ul>
<p>RandmoAccess为List提供快速访问功能。在ArrayList中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。题外话：random and sequential access is often fuzzy. For example, some List implementations provide asymptotically linear access times if they get huge, but constant access times in practice. </p>
<p>稍后，我们会比较List的“快速随机访问”和“通过Iterator迭代器访问”的效率。</p>
<blockquote>
<p>JDK 1.8.0_25：Note that this implementation is not synchronized. If multiple threads access an ArrayList instance concurrently, and at least one of the threads modifies the list structurally, it must be synchronized externally.  </p>
</blockquote>
<p>和Vector不同，ArrayList中的操作不是线程安全的，所以为了防止意外的非同步访问，最好在创建时声明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList(...));</div></pre></td></tr></table></figure>

<p>ArrayList与Collection关系如下图：</p>
<p><center> <img src="http://alexyoung.qiniudn.com/272343457973489.jpg" alt=""> <center></center></center></p>
<p>ArrayList包含了两个重要的对象：elementData 和 size。</p>
<ul>
<li><code>transient Object[] elementData</code> : ArrayList容器，保存添加到ArrayList中的元素。</li>
<li><code>private int size</code> ：The size of the ArrayList (the number of elements it contains).</li>
</ul>
<blockquote>
<p>transient：Java关键字，变量修饰符。如果用transient声明一个实例变量，当对象存储时，它的值不需要维持。具体讲解点击 → <a href="http://www.importnew.com/12611.html" target="_blank" rel="external">here</a></p>
</blockquote>
<h2 id="字段和构造函数">字段和构造函数</h2>
<p>ArrayList有七个字段加一个定义在AbstractList的modCount：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189</span>L;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = {};</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};</div><div class="line"></div><div class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</div><div class="line"></div><div class="line"><span class="keyword">protected</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>; <span class="comment">//定义在AbstractList中</span></div></pre></td></tr></table></figure>

<p>ArrayList的默认容量<code>DEFAULT_CAPACITY</code>为10，<code>EMPTY_ELEMENTDATA</code> 和 <code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>是两个常量。</p>
<p>当使用有参构造函数，并且initialCapacity为0或者Colletion中没有元素的时候，返回的就是<code>EMPTY_ELEMENTDATA</code>。当使用默认构造函数public ArrayList()，返回的就是<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>。</p>
<p>这两个数组都是空的并不会存放值。当第一次往ArrayList添加元素的时候，其实是将元素存放到elementData中，所以真正用来存放元素的是elementData。</p>
<p><code>MAX_ARRAY_SIZE</code>是array允许分配的最大空间，在Integer最大值减去8是因为 Some VMs reserve some header words in an array.</p>
<blockquote>
<p>modCount：The number of times this list has been structurally modified.</p>
</blockquote>
<p>在一个改变ArrayList的结构的方法中需要对modCount进行自增，比如一些添加，删除的方法中。在ArrayList的迭代器中需要使用这个字段，用来查看是否在迭代的时候，使用了非该迭代器的方法修改了ArrayList的结构，如果被修改了，在迭代的时候就会抛出ConcurrentModificationException异常。</p>
<p>在多次使用默认构造函数进行实例化ArrayList的时候，其实并不是每一个实例都创建一个了Object[]，见下面的程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException {</div><div class="line">		</div><div class="line">	List&lt;Integer&gt;list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">	List&lt;Integer&gt;list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">	List&lt;Integer&gt;list3 = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">20</span>);</div><div class="line">		</div><div class="line">	Field f1 = list1.getClass().getDeclaredField(<span class="string">"elementData"</span>);<span class="comment">//根据变量名elementData获得字段</span></div><div class="line">	f1.setAccessible(<span class="keyword">true</span>);	<span class="comment">//设置字段可访问，即暴力反射</span></div><div class="line">	Object o1 = f1.get(list1);	<span class="comment">//在那个对象上获取此字段的值</span></div><div class="line">	System.out.println(o1);</div><div class="line">		</div><div class="line">	Field f2 = list2.getClass().getDeclaredField(<span class="string">"elementData"</span>);	</div><div class="line">	f2.setAccessible(<span class="keyword">true</span>);	</div><div class="line">	Object o2 = f2.get(list2);	</div><div class="line">	System.out.println(o2);</div><div class="line">		</div><div class="line">	Field f3 = list3.getClass().getDeclaredField(<span class="string">"elementData"</span>);	</div><div class="line">	f3.setAccessible(<span class="keyword">true</span>);	</div><div class="line">	Object o3 = f3.get(list3);	</div><div class="line">	System.out.println(o3);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在我的机器上输出如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[Ljava.lang.Object;@<span class="number">15</span>db9742</div><div class="line">[Ljava.lang.Object;@<span class="number">15</span>db9742</div><div class="line">[Ljava.lang.Object;@<span class="number">6</span>d06d69c</div></pre></td></tr></table></figure>

<p>ArrayList提供了三个构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 默认构造函数</span></div><div class="line"><span class="keyword">public</span> <span class="title">ArrayList</span>() {</div><div class="line">        <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="comment">// initialCapacity是ArrayList的默认容量大小。当由于增加数据导致容量不足时，容量会添加上一次容量大小的一半。</span></div><div class="line"><span class="keyword">public</span> <span class="title">ArrayList</span>(<span class="keyword">int</span> initialCapacity) {</div><div class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) {</div><div class="line">            <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</div><div class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) {</div><div class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</div><div class="line">                                               initialCapacity);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="comment">// 创建一个包含collection的ArrayList</span></div><div class="line"><span class="keyword">public</span> <span class="title">ArrayList</span>(Collection&lt;? extends E&gt; c) {</div><div class="line">        elementData = c.toArray();</div><div class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) {</div><div class="line">            <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></div><div class="line">            <span class="keyword">if</span> (elementData.getClass() != Object[].class)</div><div class="line">                elementData = Arrays.copyOf(elementData, size, Object[].class);</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="comment">// replace with empty array.</span></div><div class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</div><div class="line">        }</div><div class="line">    }</div></pre></td></tr></table></figure>

<h2 id="add方法">add方法</h2>
<p>ArrayList提供了add(E e)、add(int index, E element)、addAll(Collection&lt;? extends E&gt; c)、addAll(int index, Collection&lt;? extends E&gt; c)、set(int index, E element)这个五个方法来实现ArrayList增加。</p>
<p>add(E e)：将指定的元素添加到此列表的尾部。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span>(E e) {</div><div class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></div><div class="line">        elementData[size++] = e;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div></pre></td></tr></table></figure>

<p>这里ensureCapacity()方法是对ArrayList集合进行扩容操作</p>
<p>add(int index, E element)：将指定的元素插入此列表中的指定位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span>(<span class="keyword">int</span> index, E element) {</div><div class="line">        <span class="comment">//判断索引位置是否正确</span></div><div class="line">        rangeCheckForAdd(index);</div><div class="line">        </div><div class="line">        <span class="comment">//扩容</span></div><div class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></div><div class="line">        <span class="comment">//对源数组进行复制处理（位移），向右移动当前位于该位置的元素以及所有后续元素。</span></div><div class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</div><div class="line">                         size - index);</div><div class="line">        elementData[index] = element;</div><div class="line">        size++;</div><div class="line">    }</div></pre></td></tr></table></figure>

<p>在这个方法中最根本的方法就是System.arraycopy()方法，该方法的根本目的就是将index位置空出来以供新数据插入，这里需要进行数组数据的右移，这是非常麻烦和耗时的，所以如果指定的数据集合需要进行大量插入（中间插入）操作，需要考虑性能的消耗。</p>
<p>addAll(Collection&lt;? extends E&gt; c)：按照指定 collection 的迭代器返回的元素顺序，将该 collection 中的所有元素添加到此列表的尾部。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span>(Collection&lt;? extends E&gt; c) {</div><div class="line">        Object[] a = c.toArray();</div><div class="line">        <span class="keyword">int</span> numNew = a.length;</div><div class="line">        ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></div><div class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</div><div class="line">        size += numNew;</div><div class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</div><div class="line">    }</div></pre></td></tr></table></figure>

<p>这个方法无非就是使用System.arraycopy()方法将C集合(先准换为数组a)里面的数据复制到elementData数组中。</p>
<p>System.arraycopy()原型为：public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)。</p>
<p>它的根本目的就是进行数组元素的复制。将源数组src从srcPos位置开始复制到dest数组中，复制长度为length，数据从dest的destPos位置开始粘贴。</p>
<p>addAll(int index, Collection&lt;? extends E&gt; c)：从指定的位置开始，将指定 collection 中的所有元素插入到此列表中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span>(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c) {</div><div class="line">        rangeCheckForAdd(index); <span class="comment">//判断索引位置是否正确</span></div><div class="line"></div><div class="line">        Object[] a = c.toArray();</div><div class="line">        <span class="keyword">int</span> numNew = a.length;</div><div class="line">        ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></div><div class="line"></div><div class="line">         <span class="comment">//将ArrayList容器从index开始的所有元素向右移动到index+numNew的位置，从而腾出numNew长度的空间放c</span></div><div class="line">        <span class="keyword">int</span> numMoved = size - index;</div><div class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">            System.arraycopy(elementData, index, elementData, index + numNew,</div><div class="line">                             numMoved);</div><div class="line"></div><div class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</div><div class="line">        size += numNew;</div><div class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</div><div class="line">    }</div></pre></td></tr></table></figure>

<p>set(int index, E element)：用指定的元素替代此列表中指定位置上的元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> E <span class="title">set</span>(<span class="keyword">int</span> index, E element) {</div><div class="line">        rangeCheck(index);</div><div class="line"></div><div class="line">        E oldValue = elementData(index);</div><div class="line">        elementData[index] = element;</div><div class="line">        <span class="keyword">return</span> oldValue;</div><div class="line">    }</div></pre></td></tr></table></figure>

<h2 id="remove方法">remove方法</h2>
<p>ArrayList提供了remove(int index)、remove(Object o)、removeRange(int fromIndex, int toIndex)、removeAll()四个方法进行元素的删除。</p>
<p>remove(int index)：移除此列表中指定位置上的元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> E <span class="title">remove</span>(<span class="keyword">int</span> index) {</div><div class="line">        rangeCheck(index);</div><div class="line"></div><div class="line">        modCount++;</div><div class="line">        E oldValue = elementData(index);</div><div class="line"></div><div class="line">        <span class="comment">//向左移的位数，下标从0开始，需要再多减1</span></div><div class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</div><div class="line">                             numMoved);</div><div class="line">        <span class="comment">//置空最后一个元素                     </span></div><div class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></div><div class="line"></div><div class="line">        <span class="keyword">return</span> oldValue;</div><div class="line">    }</div></pre></td></tr></table></figure>

<p>remove(Object o)：移除此列表中首次出现的指定元素（如果存在）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span>(Object o) {</div><div class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) {</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</div><div class="line">                <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) {</div><div class="line">                    fastRemove(index);</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                }</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</div><div class="line">                <span class="keyword">if</span> (o.equals(elementData[index])) {</div><div class="line">                    <span class="comment">//fastRemove()方法用于移除指定位置的元素，和remove方法类似，区别是void类型</span></div><div class="line">                    fastRemove(index);</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                }</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    }</div></pre></td></tr></table></figure>

<p>removeRange(int fromIndex, int toIndex)：移除列表中索引在 fromIndex（包括）和 toIndex（不包括）之间的所有元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">removeRange</span>(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex) {</div><div class="line">        modCount++;</div><div class="line">        <span class="keyword">int</span> numMoved = size - toIndex;</div><div class="line">        System.arraycopy(elementData, toIndex, elementData, fromIndex,</div><div class="line">                         numMoved);</div><div class="line"></div><div class="line">        <span class="comment">// clear to let GC do its work</span></div><div class="line">        <span class="keyword">int</span> newSize = size - (toIndex-fromIndex);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = newSize; i &lt; size; i++) {</div><div class="line">            elementData[i] = <span class="keyword">null</span>;</div><div class="line">        }</div><div class="line">        size = newSize;</div><div class="line">    }</div></pre></td></tr></table></figure>

<p>removeAll()：移除ArrayList中所有在c中出现的元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span>(Collection&lt;?&gt; c) {</div><div class="line">        <span class="comment">//Checks that the specified object reference is not null</span></div><div class="line">        Objects.requireNonNull(c);</div><div class="line">        Retains only the elements in <span class="keyword">this</span> list that are contained in the specified collection</div><div class="line">        <span class="comment">//false是移除相同元素，方法retainAll中置为true，是保留相同元素</span></div><div class="line">        <span class="keyword">return</span> batchRemove(c, <span class="keyword">false</span>);</div><div class="line">    }</div><div class="line">    </div><div class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">batchRemove</span>(Collection&lt;?&gt; c, <span class="keyword">boolean</span> complement) {</div><div class="line">        <span class="keyword">final</span> Object[] elementData = <span class="keyword">this</span>.elementData;</div><div class="line">        <span class="keyword">int</span> r = <span class="number">0</span>, w = <span class="number">0</span>;</div><div class="line">        <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            <span class="keyword">for</span> (; r &lt; size; r++)</div><div class="line">                <span class="comment">// 此判断是移除或保留的分水岭，complement为false则移除相同元素</span></div><div class="line">                <span class="keyword">if</span> (c.contains(elementData[r]) == complement)</div><div class="line">                    elementData[w++] = elementData[r];</div><div class="line">        } <span class="keyword">finally</span> {</div><div class="line">            <span class="comment">// Preserve behavioral compatibility with AbstractCollection,</span></div><div class="line">            <span class="comment">// even if c.contains() throws.</span></div><div class="line">            <span class="keyword">if</span> (r != size) {</div><div class="line">                System.arraycopy(elementData, r,</div><div class="line">                                 elementData, w,</div><div class="line">                                 size - r);</div><div class="line">                w += size - r;</div><div class="line">            }</div><div class="line">            <span class="keyword">if</span> (w != size) {</div><div class="line">                <span class="comment">// clear to let GC do its work</span></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &lt; size; i++)</div><div class="line">                    elementData[i] = <span class="keyword">null</span>;</div><div class="line">                modCount += size - w;</div><div class="line">                size = w;</div><div class="line">                modified = <span class="keyword">true</span>;</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> modified;</div><div class="line">    }</div></pre></td></tr></table></figure>

<h2 id="扩容">扩容</h2>
<p>在上面的add方法的源码中我们发现每个方法中都存在这个方法：ensureCapacity()，该方法就是ArrayList的扩容方法。</p>
<p>在前面就提过ArrayList每次新增元素时都会需要进行容量检测判断，若新增元素后元素的个数会超过ArrayList的容量，就会进行扩容操作来满足新增元素的需求。所以当我们清楚知道业务数据量或者需要插入大量元素前，可以使用ensureCapacity来手动增加ArrayList实例的容量，以减少递增式再分配的数量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//外部接口</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span>(<span class="keyword">int</span> minCapacity) {</div><div class="line">    <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</div><div class="line">        <span class="comment">// any size if not default element table</span></div><div class="line">        ? <span class="number">0</span></div><div class="line">        <span class="comment">// larger than default for default empty table. It's already</span></div><div class="line">        <span class="comment">// supposed to be at default size.</span></div><div class="line">        : DEFAULT_CAPACITY;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) {</div><div class="line">        ensureExplicitCapacity(minCapacity);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">//内部接口</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span>(<span class="keyword">int</span> minCapacity) {</div><div class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {</div><div class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</div><div class="line">    }</div><div class="line"></div><div class="line">    ensureExplicitCapacity(minCapacity);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">//内部接口</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span>(<span class="keyword">int</span> minCapacity) {</div><div class="line">    modCount++;</div><div class="line"></div><div class="line">    <span class="comment">// overflow-conscious code</span></div><div class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</div><div class="line">        grow(minCapacity);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span>(<span class="keyword">int</span> minCapacity) {</div><div class="line">    <span class="comment">// overflow-conscious code</span></div><div class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</div><div class="line">    <span class="comment">//扩容到1.5倍</span></div><div class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</div><div class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</div><div class="line">        newCapacity = minCapacity;</div><div class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</div><div class="line">        newCapacity = hugeCapacity(minCapacity);</div><div class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></div><div class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>对比网上的其他教程，可以发现Java 8中ArrayList的代码具有更好的鲁棒性，逻辑也更加清晰。</p>
<p>当然也许你会质疑为毛ArrayList的增长因子是1.5，而HashMap是2.0呢，可以参考<a href="http://stackoverflow.com/questions/5040753/why-arraylist-grows-at-a-rate-of-1-5-but-for-hashmap-its-2" target="_blank" rel="external">这里</a>。</p>
<p>大致就是说HashMap增长因子更大是为了避免哈希碰撞，而ArrayList一方面是根据经验设定，另一方面可能是为了避免增长因子过大而造成空间浪费。</p>
<p>当然你可以手动最小化ArrayList实例的存储量：trimToSize()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span>() {</div><div class="line">        modCount++;</div><div class="line">        <span class="keyword">if</span> (size &lt; elementData.length) {</div><div class="line">            elementData = (size == <span class="number">0</span>)</div><div class="line">              ? EMPTY_ELEMENTDATA</div><div class="line">              : Arrays.copyOf(elementData, size);</div><div class="line">        }</div><div class="line">    }</div></pre></td></tr></table></figure>

<h2 id="迭代器">迭代器</h2>
<p>主要与两种迭代器，Itr和ListItr，在java8中还加入了一个ArrayListSpliterator迭代器。</p>
<p>Itr和ListItr的主要区别就是Itr只能往后遍历，而ListItr可以前后遍历。</p>
<h3 id="Itr">Itr</h3>
<p>该迭代器从下标为0的地方开始遍历，直到ArrayList的最后一个元素。在取值的时候会检查modCount是否被修改了，即ArrayList的结构是否被修改了，是则抛出异常。如果要删除元素，只能使用迭代器中的remove方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>{</div><div class="line">        <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></div><div class="line">        <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></div><div class="line">        <span class="keyword">int</span> expectedModCount = modCount;</div><div class="line"></div><div class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span>() {</div><div class="line">            <span class="keyword">return</span> cursor != size;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">        <span class="keyword">public</span> E <span class="title">next</span>() {</div><div class="line">            checkForComodification();</div><div class="line">            <span class="keyword">int</span> i = cursor;</div><div class="line">            <span class="keyword">if</span> (i &gt;= size)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">            Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</div><div class="line">            <span class="keyword">if</span> (i &gt;= elementData.length)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">            cursor = i + <span class="number">1</span>;</div><div class="line">            <span class="keyword">return</span> (E) elementData[lastRet = i];</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span>() {</div><div class="line">            <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</div><div class="line">            checkForComodification();</div><div class="line"></div><div class="line">            <span class="keyword">try</span> {</div><div class="line">                ArrayList.<span class="keyword">this</span>.remove(lastRet);</div><div class="line">                cursor = lastRet;</div><div class="line">                lastRet = -<span class="number">1</span>;</div><div class="line">                expectedModCount = modCount;</div><div class="line">            } <span class="keyword">catch</span> (IndexOutOfBoundsException ex) {</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// 检查modCount是否修改</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">void</span> checkForComodification() {</div><div class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">        }</div><div class="line">    }</div></pre></td></tr></table></figure>

<h3 id="ListItr">ListItr</h3>
<p>ListItr继承自Itr，添加了向前遍历的功能，set和add方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span>(E e) {</div><div class="line">        <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</div><div class="line">        checkForComodification();</div><div class="line"></div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            ArrayList.<span class="keyword">this</span>.set(lastRet, e);</div><div class="line">        } <span class="keyword">catch</span> (IndexOutOfBoundsException ex) {</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span>(E e) {</div><div class="line">        checkForComodification();</div><div class="line"></div><div class="line">        <span class="keyword">try</span> {</div><div class="line">            <span class="keyword">int</span> i = cursor;</div><div class="line">            ArrayList.<span class="keyword">this</span>.add(i, e);</div><div class="line">            cursor = i + <span class="number">1</span>;</div><div class="line">            lastRet = -<span class="number">1</span>;</div><div class="line">            expectedModCount = modCount;</div><div class="line">        } <span class="keyword">catch</span> (IndexOutOfBoundsException ex) {</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">        }</div><div class="line">    }</div></pre></td></tr></table></figure>

<h3 id="使用示例">使用示例</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">        list.add(<span class="number">1</span>);</div><div class="line">		list.add(<span class="number">2</span>);</div><div class="line">		.add(<span class="number">3</span>);</div><div class="line">		</div><div class="line">		Iterator&lt;Integer&gt;it = list.iterator();</div><div class="line">		</div><div class="line">		<span class="comment">//list.add(2); throw java.util.ConcurrentModificationException</span></div><div class="line">		</div><div class="line">		<span class="keyword">while</span> (it.hasNext()) {</div><div class="line">			System.out.println(it.next());</div><div class="line">		}</div><div class="line">		</div><div class="line">		ListIterator&lt;Integer&gt;listIterator = list.listIterator();</div><div class="line">		listIterator.add(<span class="number">4</span>); <span class="comment">//   调用自身的方法修改 </span></div><div class="line">		<span class="keyword">while</span> (listIterator.hasNext()) {</div><div class="line">			System.out.println(listIterator.next());</div><div class="line">		}</div><div class="line">	}</div></pre></td></tr></table></figure>

<p>程序输出的结果：<br>1,2,3<br>1,2,3<br>注意listIterator输出中并没有4</p>
<p>在获取了iterator实例后，list就不可改变。当ArrayList使用了ListIterator()方法产生自身对应的Iterator后，只能使用Iterator自身的remove()和add()方法来修改ArrayList的结构，因为这些方法对expectedModCount和modCount变量自动同步。</p>
<h3 id="迭代效率">迭代效率</h3>
<p>ArrayList支持3种遍历方式:</p>
<ul>
<li>第一种，通过迭代器遍历。即通过Iterator去遍历。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Integer value = <span class="keyword">null</span>;</div><div class="line">Iterator iter = list.iterator();</div><div class="line"><span class="keyword">while</span> (iter.hasNext()) {</div><div class="line">    value = (Integer)iter.next();</div><div class="line">}</div></pre></td></tr></table></figure>

<ul>
<li>第二种，随机访问，通过索引值去遍历。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Integer value = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">int</span> size = list.size();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) {</div><div class="line">    value = (Integer)list.get(i);        </div><div class="line">}</div></pre></td></tr></table></figure>

<ul>
<li>第三种，for循环遍历。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Integer value = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">for</span> (Integer i : list) {</div><div class="line">    value = i;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>程序测试遍历十万数字，使用时间如下：<br>iteratorThroughIterator：7 ms<br>iteratorThroughRandomAccess：5 ms<br>iteratorThroughFor2：6 ms<br>由此可见，遍历ArrayList时，使用随机访问(即通过索引序号访问)效率最高，而使用迭代器的效率最低。</p>
<p>最后来一道测试题：</p>
<blockquote>
<p>ArrayList list = new ArrayList(20);  中的list扩充几次（）<br>A. 0<br>B. 1<br>C. 2<br>D. 3</p>
</blockquote>
<p>解释：默认ArrayList的长度是10个，所以如果你要往list里添加20个元素肯定要扩充一次（newCapacity 扩充为原来的1.5倍，但和输入的minCapacity相比发现小于minCapacity，于是 newCapacity = minCapacity，所以只扩容一次，具体见扩容里的grow方法），但是这里显示指明了需要多少空间，所以就一次性为你分配这么多空间，也就是不需要扩充了。</p>
]]></content>
    <summary type="html">
    <![CDATA[The ArrayList class extends AbstractList and implements the List interface. ArrayList supports dynamic arrays that can grow as needed.]]>
    
    </summary>
    
      <category term="coding" scheme="http://alexyyek.github.io/tags/coding/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java容器类]]></title>
    <link href="http://alexyyek.github.io/2015/04/06/Collection/"/>
    <id>http://alexyyek.github.io/2015/04/06/Collection/</id>
    <published>2015-04-06T09:24:38.000Z</published>
    <updated>2015-04-07T14:36:55.000Z</updated>
    <content type="html"><![CDATA[<p>Java容器类是java提供的工具包，包含了常用的数据结构：集合、链表、队列、栈、数组、映射等。从本文开始将开启一个系列详细分析Java容器中的每个成员，包括源代码分析，性能分析，不同容器之间对比等等，链接将同步更新在本文和<a href="http://alexyyek.github.io/2015/01/06/sticky/" target="_blank" rel="external">置顶博文</a>内。</p>
<p>Java容器主要可以划分为4个部分：List列表、Set集合、Map映射、工具类（Iterator迭代器、Enumeration枚举类、Arrays和Collections）</p>
<h2 id="容器类框架">容器类框架</h2>
<p>Java容器工具包框架图：</p>
<p><center> <img src="http://alexyoung.qiniudn.com/08171028-a5e372741b18431591bb577b1e1c95e6.jpg" alt=""> <center></center></center></p>
<p>通过上图，可以把握两个基本主体，即Collection和Map。</p>
<ol>
<li><p>Collection是一个接口，是高度抽象出来的集合，它包含了集合的基本操作和属性。Collection包含了List和Set两大分支。</p>
<p> List是一个有序的队列，每一个元素都有它的索引。第一个元素的索引值是0。List的实现类有LinkedList, ArrayList, Vector, Stack。<br> Set是一个不允许有重复元素的集合。 Set的实现类有HastSet和TreeSet。HashSet依赖于HashMap，它实际上是通过HashMap实现的；TreeSet依赖于TreeMap，它实际上是通过TreeMap实现的。</p>
</li>
<li><p>Map是一个映射接口，即key-value键值对。Map中的每一个元素包含“一个key”和“key对应的value”。</p>
<p>AbstractMap是个抽象类，它实现了Map接口中的大部分API。而HashMap，TreeMap，WeakHashMap都是继承于AbstractMap。<br>Hashtable虽然继承于Dictionary，但它实现了Map接口。</p>
</li>
<li><p>Iterator是遍历集合的工具，即我们通常通过Iterator迭代器来遍历集合。我们说Collection依赖于Iterator，是因为Collection的实现类都要实现iterator()函数，返回一个Iterator对象。ListIterator是专门为遍历List而存在的。</p>
</li>
<li><p>Enumeration是JDK 1.0引入的抽象类。作用和Iterator一样，也是遍历集合；但是Enumeration的功能要比Iterator少。在上面的框图中，Enumeration只能在Hashtable, Vector, Stack中使用。</p>
</li>
<li><p>Arrays和Collections是操作数组、集合的两个工具类。</p>
</li>
</ol>
<p>有了上面的整体框架之后，我们接下来对每个类分别进行分析。</p>
<h2 id="Collection接口">Collection接口</h2>
<p>Collection的定义如下：</p>
<p> <code>public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; {}</code> </p>
<p>它是一个接口，是高度抽象出来的集合，它包含了集合的基本操作：添加、删除、清空、遍历(读取)、是否为空、获取大小、是否保护某元素等等。</p>
<p>在Java中所有实现了Collection接口的类都必须提供两套标准的构造函数，一个是无参，用于创建一个空的Collection，一个是带有Collection参数的有参构造函数，用于创建一个新的Collection，这个新的Collection与传入进来的Collection具备相同的元素。</p>
<p>Collection的API：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="keyword">boolean</span>         add(E object)</div><div class="line"><span class="keyword">abstract</span> <span class="keyword">boolean</span>         addAll(Collection&lt;? extends E&gt; collection)</div><div class="line"><span class="keyword">abstract</span> <span class="keyword">void</span>            clear()</div><div class="line"><span class="keyword">abstract</span> <span class="keyword">boolean</span>         contains(Object object)</div><div class="line"><span class="keyword">abstract</span> <span class="keyword">boolean</span>         containsAll(Collection&lt;?&gt; collection)</div><div class="line"><span class="keyword">abstract</span> <span class="keyword">boolean</span>         equals(Object object)</div><div class="line"><span class="keyword">abstract</span> <span class="keyword">int</span>             hashCode()</div><div class="line"><span class="keyword">abstract</span> <span class="keyword">boolean</span>         isEmpty()</div><div class="line"><span class="keyword">abstract</span> Iterator&lt;E&gt;     iterator()</div><div class="line"><span class="keyword">abstract</span> <span class="keyword">boolean</span>         remove(Object object)</div><div class="line"><span class="keyword">abstract</span> <span class="keyword">boolean</span>         removeAll(Collection&lt;?&gt; collection)</div><div class="line"><span class="keyword">abstract</span> <span class="keyword">boolean</span>         retainAll(Collection&lt;?&gt; collection)</div><div class="line"><span class="keyword">abstract</span> <span class="keyword">int</span>             size()</div><div class="line"><span class="keyword">abstract</span> &lt;T&gt; T[]         toArray(T[] array)</div><div class="line"><span class="keyword">abstract</span> Object[]        toArray()</div></pre></td></tr></table></figure>

<h2 id="List接口">List接口</h2>
<p>List的定义如下：</p>
<p><code>public interface List&lt;E&gt; extends Collection&lt;E&gt; {}</code></p>
<p>List是一个继承于Collection的接口，即List是集合中的一种。List是有序的队列，List中的每一个元素都有一个索引；第一个元素的索引值是0，往后的元素的索引值依次+1。和Set不同，List中允许有重复的元素。</p>
<blockquote>
<p>官方文档：A List is a collection which maintains an ordering for its elements. Every element in the List has an index. Each element can thus be accessed by its index, with the first index being zero. Normally, Lists allow duplicate elements, as compared to Sets, where elements have to be unique.</p>
</blockquote>
<p>关于API方面。既然List是继承于Collection接口，它自然就包含了Collection中的全部函数接口；由于List是有序队列，它也额外的有自己的API接口。主要有“添加、删除、获取、修改指定位置的元素”、“获取List中的子队列”等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Collection的API</span></div><div class="line"><span class="keyword">abstract</span> <span class="keyword">boolean</span>         add(E object)</div><div class="line"><span class="keyword">abstract</span> <span class="keyword">boolean</span>         addAll(Collection&lt;? extends E&gt; collection)</div><div class="line"><span class="keyword">abstract</span> <span class="keyword">void</span>            clear()</div><div class="line"><span class="keyword">abstract</span> <span class="keyword">boolean</span>         contains(Object object)</div><div class="line"><span class="keyword">abstract</span> <span class="keyword">boolean</span>         containsAll(Collection&lt;?&gt; collection)</div><div class="line"><span class="keyword">abstract</span> <span class="keyword">boolean</span>         equals(Object object)</div><div class="line"><span class="keyword">abstract</span> <span class="keyword">int</span>             hashCode()</div><div class="line"><span class="keyword">abstract</span> <span class="keyword">boolean</span>         isEmpty()</div><div class="line"><span class="keyword">abstract</span> Iterator&lt;E&gt;     iterator()</div><div class="line"><span class="keyword">abstract</span> <span class="keyword">boolean</span>         remove(Object object)</div><div class="line"><span class="keyword">abstract</span> <span class="keyword">boolean</span>         removeAll(Collection&lt;?&gt; collection)</div><div class="line"><span class="keyword">abstract</span> <span class="keyword">boolean</span>         retainAll(Collection&lt;?&gt; collection)</div><div class="line"><span class="keyword">abstract</span> <span class="keyword">int</span>             size()</div><div class="line"><span class="keyword">abstract</span> &lt;T&gt; T[]         toArray(T[] array)</div><div class="line"><span class="keyword">abstract</span> Object[]        toArray()</div><div class="line"><span class="comment">// 相比与Collection，List新增的API：</span></div><div class="line"><span class="keyword">abstract</span> <span class="keyword">void</span>                add(<span class="keyword">int</span> location, E object)</div><div class="line"><span class="keyword">abstract</span> <span class="keyword">boolean</span>             addAll(<span class="keyword">int</span> location, Collection&lt;? extends E&gt; collection)</div><div class="line"><span class="keyword">abstract</span> E                   get(<span class="keyword">int</span> location)</div><div class="line"><span class="keyword">abstract</span> <span class="keyword">int</span>                 indexOf(Object object)</div><div class="line"><span class="keyword">abstract</span> <span class="keyword">int</span>                 lastIndexOf(Object object)</div><div class="line"><span class="keyword">abstract</span> ListIterator&lt;E&gt;     listIterator(<span class="keyword">int</span> location)</div><div class="line"><span class="keyword">abstract</span> ListIterator&lt;E&gt;     listIterator()</div><div class="line"><span class="keyword">abstract</span> E                   remove(<span class="keyword">int</span> location)</div><div class="line"><span class="keyword">abstract</span> E                   set(<span class="keyword">int</span> location, E object)</div><div class="line"><span class="keyword">abstract</span> List&lt;E&gt;             subList(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</div></pre></td></tr></table></figure>

<p>实现List接口的集合主要有：ArrayList、LinkedList、Vector、Stack。</p>
<h3 id="ArrayList">ArrayList</h3>
<p>ArrayList定义如下：</p>
<p><code>public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</code><br><code>implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</code></p>
<p>ArrayList是一个动态数组，也是我们最常用的集合。它允许任何符合规则的元素插入甚至包括null。每一个ArrayList都有一个初始容量：</p>
<p><code>private static final int DEFAULT_CAPACITY = 10;</code></p>
<p>随着容器中的元素不断增加，容器的大小也会随着增加。在每次向容器中增加元素的同时都会进行容量检查，当快溢出时，就会进行扩容操作。所以如果我们明确所插入元素的多少，最好指定一个初始容量值，避免过多的进行扩容操作而浪费时间、效率。</p>
<p> size、isEmpty、get、set、iterator 和 listIterator 操作都以固定时间运行。add 操作以分摊的固定时间运行，也就是说，添加 n 个元素需要 O(n) 时间（由于要考虑到扩容，所以这不只是添加元素会带来分摊固定时间开销那样简单）。</p>
<p>ArrayList擅长于随机访问。同时ArrayList是非同步的。</p>
<h3 id="LinkedList">LinkedList</h3>
<p>LinkedList定义如下：</p>
<p><code>public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt;</code><br>    <code>implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</code></p>
<p>同样实现List接口的LinkedList与ArrayList不同，ArrayList是一个动态数组，而LinkedList是一个双向链表。所以它除了有ArrayList的基本操作方法外还额外提供了get，remove，insert方法在LinkedList的首部或尾部。</p>
<p>由于实现的方式不同，LinkedList不能随机访问，它所有的操作都是要按照双重链表的需要执行。在列表中索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端，节约一半时间）。这样做的好处就是可以通过较低的代价在List中进行插入和删除操作。</p>
<p>与ArrayList一样，LinkedList也是非同步的。如果多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建List时构造一个同步的List： </p>
<p><code>List list = Collections.synchronizedList(new LinkedList(…));</code></p>
<h3 id="Vector">Vector</h3>
<p>Vector定义如下：</p>
<p><code>public class Vector&lt;E&gt; extends AbstractList&lt;E&gt;</code><br>    <code>implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</code></p>
<p>与ArrayList相似，但是Vector是同步的。所以说Vector是线程安全的动态数组。它的操作与ArrayList几乎一样。</p>
<h3 id="Stack">Stack</h3>
<p>Stack定义如下：</p>
<p><code>public class Stack&lt;E&gt; extends Vector&lt;E&gt; {}</code></p>
<p>Stack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。</p>
<h2 id="Set接口">Set接口</h2>
<p>Set定义如下：</p>
<p><code>public interface Set&lt;E&gt; extends Collection&lt;E&gt; {}</code></p>
<p>Set是一个继承于Collection的接口，Set是一种不包括重复元素的Collection。它维持它自己的内部排序，所以随机访问没有任何意义。与List一样，它同样运行null的存在但是仅有一个。由于Set接口的特殊性，所有传入Set集合中的元素都必须不同，</p>
<p>关于API方面。Set的API和Collection完全一样。</p>
<p>实现了Set接口的集合有：HashSet、TreeSet、LinkedHashSet、EnumSet。</p>
<h3 id="HashSet">HashSet</h3>
<p>HashSet定义如下：</p>
<p><code>public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt;</code><br>    <code>implements Set&lt;E&gt;, Cloneable, java.io.Serializable</code></p>
<p>HashSet堪称查询速度最快的集合，因为其内部是以HashCode来实现的。集合元素可以是null,但只能放入一个null。它内部元素的顺序是由哈希码来决定的，所以它不保证set的迭代顺序；特别是它不保证该顺序恒久不变。</p>
<h3 id="TreeSet">TreeSet</h3>
<p>TreeSet定义如下：</p>
<p><code>public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt;</code><br>    <code>implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable</code></p>
<p>TreeSet是二叉树实现的，基于TreeMap，生成一个总是处于排序状态的set，内部以TreeMap来实现，不允许放入null值。它是使用元素的自然顺序对元素进行排序，或者根据创建Set时提供的 Comparator 进行排序，具体取决于使用的构造方法。</p>
<h3 id="LinkedHashSet">LinkedHashSet</h3>
<p>LinkedHashSet定义如下：</p>
<p><code>public class LinkedHashSet&lt;E&gt; extends HashSet&lt;E&gt;</code><br>    <code>implements Set&lt;E&gt;, Cloneable, java.io.Serializable</code></p>
<p>LinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起 来像是以插入顺序保存的，也就是说，当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。LinkedHashSet在迭代访问Set中的全部元素时，性能比HashSet好，但是插入时性能稍微逊色于HashSet。</p>
<h3 id="EnumSet">EnumSet</h3>
<p>EnumSet定义如下：</p>
<p><code>public abstract class EnumSet&lt;E extends Enum&lt;E&gt;&gt; extends AbstractSet&lt;E&gt;</code><br>    <code>implements Cloneable, java.io.Serializable</code></p>
<p>EnumSet中所有值都必须是指定枚举类型的值，它的元素也是有序的，以枚举值在枚举类的定义顺序来决定集合元素的顺序。EnumSet集合不允许加入null元素，否则会抛出NullPointerException异常。EnumSet类没有暴露任何构造器来创建该类的实例，程序应该通过它提供的static方法来创建EnumSet对象，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line"></div><div class="line">        <span class="comment">//创建一个EnumSet空集合，指定其集合元素是season1的枚举值</span></div><div class="line">		EnumSet&lt;MyEnum&gt;eSet1 = EnumSet.noneOf(MyEnum.class); </div><div class="line">		</div><div class="line">		<span class="comment">////创建一个EnumSet集合，集合元素就是Season里的全部枚举值</span></div><div class="line">		EnumSet&lt;MyEnum&gt;eSet2 = EnumSet.allOf(MyEnum.class);</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">enum</span> MyEnum {  </div><div class="line">	    BLACK, WHITE, RED, BLUR, GREEN, YELLOW  </div><div class="line">	}</div></pre></td></tr></table></figure>

<p>来看一个例子感受一下存储元素的区别：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> Collection fill(Collection&lt;String&gt; collection) {</div><div class="line">		collection.add(<span class="string">"rat"</span>);</div><div class="line">		collection.add(<span class="string">"cat"</span>);</div><div class="line">		collection.add(<span class="string">"dog"</span>);</div><div class="line">		collection.add(<span class="string">"dog"</span>);</div><div class="line">		<span class="keyword">return</span> collection;</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">		System.out.println(fill(<span class="keyword">new</span> HashSet&lt;String&gt;()));</div><div class="line">		System.out.println(fill(<span class="keyword">new</span> TreeSet&lt;&gt;()));</div><div class="line">		System.out.println(fill(<span class="keyword">new</span> LinkedHashSet&lt;&gt;()));</div><div class="line">	}</div></pre></td></tr></table></figure>

<p>HashSet是哈希表实现的，存储顺序并无意义。如果存储顺序很重要，那么可以使用TreeSet，它按比较结果的升序保存对象；或者使用LinkedHashSet，它按照被添加的顺序保存元素。当然它们都是线程不安全的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Result:</span></div><div class="line">[rat, cat, dog]</div><div class="line">[cat, dog, rat]</div><div class="line">[rat, cat, dog]</div></pre></td></tr></table></figure>

<h2 id="Map接口">Map接口</h2>
<p>Map与List、Set接口不同，它是由一系列键值对组成的集合，提供了key到Value的映射。在Map中它保证了key与value之间的一一对应关系。也就是说一个key对应一个value，所以它不能存在相同的key值，当然value值可以相同。</p>
<p>实现map的集合有：HashMap、HashTable、TreeMap、WeakHashMap。</p>
<h3 id="HashMap">HashMap</h3>
<p>HashMap定义如下：</p>
<p><code>public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</code><br>    <code>implements Map&lt;K,V&gt;, Cloneable, Serializable</code></p>
<p>以哈希表数据结构实现，查找对象时通过哈希函数计算其位置，它是为快速查询而设计的，其内部定义了一个hash表数组（Entry[] table），元素会通过哈希转换函数将元素的哈希地址转换成数组中存放的索引，如果有冲突，则使用散列链表的形式将所有相同哈希地址的元素串起来，可能通过查看HashMap.Entry的源码它是一个单链表结构。</p>
<h3 id="HashTable">HashTable</h3>
<p>HashTable的定义如下：</p>
<p><code>public class Hashtable&lt;K,V&gt; extends Dictionary&lt;K,V&gt;</code><br>    <code>implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable</code></p>
<p>也是以哈希表数据结构实现的，解决冲突时与HashMap也一样也是采用了散列链表的形式。HashTable继承Dictionary类，实现Map接口。其中Dictionary类是任何可将键映射到相应值的类（如 Hashtable）的抽象父类。每个键和每个值都是一个对象。在任何一个 Dictionary 对象中，每个键至多与一个值相关联。Map是”key-value键值对”接口。     HashTable采用”拉链法”实现哈希表不过性能比HashMap要低。</p>
<h3 id="TreeMap">TreeMap</h3>
<p>TreeMap的定义如下：</p>
<p><code>public class TreeMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</code><br>    <code>implements NavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable</code></p>
<p>有序散列表，实现SortedMap接口，底层通过红黑树实现。</p>
<h3 id="WeakHashMap">WeakHashMap</h3>
<p>WeakHashMap的定义如下：</p>
<p><code>public class WeakHashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</code><br>    <code>implements Map&lt;K,V&gt;</code></p>
<p>谈WeakHashMap前先看一下Java中的引用（强度依次递减）</p>
<ol>
<li>强引用：普遍对象声明的引用，存在便不会GC</li>
<li>软引用：有用但并非必须，发生内存溢出前，二次回收</li>
<li>弱引用：只能生存到下次GC之前，无论是否内存足够</li>
<li>虚引用：唯一目的是在这个对象被GC时能收到一个系统通知</li>
</ol>
<p>以弱键实现的基于哈希表的Map。在 WeakHashMap 中，当某个键不再正常使用时，将自动移除其条目。更精确地说，对于一个给定的键，其映射的存在并不阻止垃圾回收器对该键的丢弃，这就使该键成为可终止的，被终止，然后被回收。丢弃某个键时，其条目从映射中有效地移除，因此，该类的行为与其他的 Map 实现有所不同。null值和null键都被支持。该类具有与HashMap类相似的性能特征,并具有相同的效能参数初始容量和加载因子。像大多数集合类一样，该类是不同步的。</p>
<h2 id="Iterator">Iterator</h2>
<p>Iterator定义如下：</p>
<p><code>public interface Iterator&lt;E&gt; {}</code></p>
<p>Iterator是一个接口，它是集合的迭代器。集合可以通过Iterator去遍历集合中的元素。Iterator提供的API接口，包括：是否存在下一个元素、获取下一个元素、删除当前元素。<br>注意：Iterator遍历Collection时，是fail-fast机制的。即，当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出ConcurrentModificationException异常，产生fail-fast事件。关于fail-fast的详细内容，我们会在后面专门进行说明。</p>
<p>Iterator的API：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="keyword">boolean</span> hasNext()</div><div class="line"><span class="keyword">abstract</span> E next()</div><div class="line"><span class="keyword">abstract</span> <span class="keyword">void</span> remove()</div></pre></td></tr></table></figure>

<p><br></p>
<p>最后用一张图总结一下大体框架，后面会开始具体分析。</p>
<p><center> <img src="http://alexyoung.qiniudn.com/QQ图片20150407223455.png" alt=""> <center></center></center></p>
]]></content>
    <summary type="html">
    <![CDATA[It’s a fairly simple program that only has a fixed quantity of objects with known lifetimes.]]>
    
    </summary>
    
      <category term="coding" scheme="http://alexyyek.github.io/tags/coding/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[五天七面——正确定位自己]]></title>
    <link href="http://alexyyek.github.io/2015/03/13/Intership/"/>
    <id>http://alexyyek.github.io/2015/03/13/Intership/</id>
    <published>2015-03-13T15:50:59.000Z</published>
    <updated>2015-03-13T15:56:34.000Z</updated>
    <content type="html"><![CDATA[<p>2015年初三月的第二周，也许是研究生近两年以来我生命中最漫长的一周。五家公司，七次面试，从朝阳到五道口，从望京到中关村，从出发的喜悦到归来的沮丧，从昨天的跌倒到今天的爬起，个中滋味恐怕也只有自己能体会。最近适逢暑期实习校招，所以将这段经历分享出来，希望能帮到有需要的人。（全程流水账，回忆起什么写什么）</p>
<h2 id="周一">周一</h2>
<h3 id="创业公司">创业公司</h3>
<p>第一场面的是中关村附近的一家创业公司。因为之前在百度实习过，所以想感受一下创业公司的工作氛围，早上九点半如约来到面试地点，因为已经有了融资，所以公司环境要比想象中更给力，员工数量也颇为可观。前台MM热情的接待了我，让我稍等。五分钟后告诉我说，HR堵在路上了，不过可以先进行笔试环节…</p>
<ul>
<li>笔试<br>上来就是五道编程题，如用p，1-p随机数发生器制造等概率发生器；输入一句话后按规则反转；分词后文件按格式打印只出现一次的单词；还有一道用二叉树的题，基本写完了这四题，剩下的一个也给出了大体思路，此时和蔼可亲的HR也终于如约抵达了，在休息区等了十分钟，被通知笔试过了，于是开始一面。</li>
<li>一面<br>来的面试官是一个略显青涩的少年，估计比我大不了两岁，看他一脸严肃的表情似乎比我还要紧张…简单自我介绍之后，他的注意力主要集中在了我实验室的项目上，于是又是各种机器学习算法的讲解，过程中穿插了一些提升性能可能性的分析，差不多讲完之后，少年点了点头让我先不要乱跑…</li>
<li>二面<br>五分钟后一个非常面善的中年大叔出现了，一看就是leader型成功人士，中年大叔看着我的简历说，你在百度实习过？我说实习了半年。他问你觉得这段实习对你有什么帮助么？于是就跟他讲各种好处balabala，然后他突然问，那你干嘛去年6月辞职了呢？我说因为有世界杯啊，啊不因为要期末考试啊(￣▽￣)”…大叔哦了一声，沉默了一会，你简历里写了常用Java，那就问问你Java吧。我说好嘞。Overload和Override有什么区别啊？多态有什么好处啊？多线程extends Thread好还是implement Runnable好啊？讲讲内存和垃圾回收啊？过了十分钟后大叔觉得可能这样问没有意义，于是说那来做几个题吧，然后又出了两个算法题。搞定后大叔满意的看了我两眼，说基本没什么问题了，你有什么问题么？于是又和他交流了半天他们公司的内部业务方向，当问到他们常用什么语言时，大叔果断告诉我python。我说额，我是不是面试错部门了啊，我简历写的Java啊，大叔说没关系的，看你思维蛮不错的，python应该学起来也没问题吧。我说呵呵…</li>
</ul>
<p>当天下午就收到了公司HR MM的电话，问我何时可以入职，因为之后还有面试，而且还是想写Java吧，于是和HR谈好周五前给她答复。结果当晚八点HR MM又打电话进来，说和leader商量了可以给我增加实习生工资（之前已经高于BAT水准了），表示了感谢后我说明晚前给答复吧。</p>
<h2 id="周二">周二</h2>
<h3 id="搜狐">搜狐</h3>
<p>周二下午面搜狐，不得不说搜狐里面女生质量真心高，还单身找实习的可以多考虑一下…</p>
<ul>
<li>一面<br>下楼接我的就是我的一面面试官，大概讲了自己的实习经历和实验室项目后，便开始了真刀真枪的测试。对Linux熟么？略懂。来用awk处理一下这个文件，需求如下balabala。写完后，来再用Shell写一下…看你简历熟悉hadoop啊？略懂。来讲讲如何用mapreduce实现kmeans。讲完后，喜欢算法么？喜欢。如何将一个单链表反序？写完后，看过Java源码么？扫过一眼。来讲讲HashMap和HashTable的区别，写一下HashTable的rehash方法。挣扎着写完后，看过设计模式么？略懂，来讲讲你知道的一种设计模式并写一段相应程序。再一次挣扎着写完后，四十分钟已经过去了…又问了些零零散散的问题，面试官让我等他同事。</li>
<li>形式上的二面<br>说好的同事呢，为什么来的是个leader啊？leader抱着Mac，一脸高冷的问我刚才面了什么啊，于是讲了五分钟面试内容。leader放下电脑，看着我说，还真不少啊那我就不问你了…说实话，此刻我的内心是拒绝的，因为我不知道你说不面我是真的觉得我还OK呢，还是已经被一面鄙视了懒得问，但没办法，我并不擅长强迫中年男性吐露他们的心声。leader问我，你有什么问题么，于是问了他如果进去后可能做的方向。在leader同志的讲解下，我的内心告诉我，这也许就是我想要的。</li>
</ul>
<p>晚上回到学校，拨通了HR MM的电话，听到她得知我的选择后略显失落的声音，觉得还是蛮抱歉的，再次感谢了她的挽留后，收到了通知周三阿里二面和搜狐另一个部门面试的电话。</p>
<h2 id="周三">周三</h2>
<h3 id="阿里">阿里</h3>
<p>经历了公交和地铁近一个半小时的行程后，终于提前半小时抵达了面试地点。一楼前台拨了面试官的办公电话后，告诉我人还没来，让我稍等一下，结果没等来面试官，等来了一个面试相同岗位的本科校友…</p>
<p>我们被领到同一个会议室后，面试官拿了两份笔试题让我们做，我扫了一眼，你好，我是来面试Java方向的…面试官看了一下题后说，额那你先试着写写，我去找会Java的给你出一份题。</p>
<p>还好有两道和数据结构比较相关的题，写写停停大概二十分钟，面试官带着另一份题进来了，额你写了这个啊，那再写一下Java的吧。我说：…</p>
<p>又是二十分钟，四道题写了两道半，此时校友早已被带出去开始面试了，我觉得写的差不多了后也叫了给我安排的面试官，于是开始了最高潮的面试部门…</p>
<p>面试我的是一位看着不大于三十岁的帅气男子，他拿起我写的厚厚的几页代码后，看了大概一分钟（没有翻页），问我，觉得笔试如何？我说还好吧，可能会有些小问题，但思路和大体框架都还OK。</p>
<p>然后，然后高潮就这样来了。</p>
<p>哦，那我们开始聊聊你的简历吧。</p>
<p>此刻我的内心是拒绝的，因为我苦思冥想写了四十分钟的代码，你怎么也不能一个哦就评价了吧…里面可是有人家精心准备的小惊喜的，都已经想好了如何向面试官展示我思路的优越性呢。</p>
<p>哦，那我们开始聊聊你的项目经历吧。</p>
<p>……</p>
<p>于是我们从朴素贝叶斯聊到SVM，从协同过滤聊到社区发现，并没有Linux，并没有Java，并没有数据库，并没有TCP/IP，全部集中在项目经历上。当然这里并没有任何不满的意思，毕竟你问我项目，那当然很高兴了，因为自己的项目基本还是很清楚的。于是就这样聊了二十分钟，高潮来了。在讲谱聚类时我详细介绍了如果构建拉普拉斯矩阵，如果利用Fiedler向量构建Kmeans的输入矩阵，突然，他打断了我，你这个向量构建的矩阵里都是用户ID，那还需要Kmeans？</p>
<p>我知道，在这一刻，我的眼里还是没能完全掩盖掉能量槽溢出的Despise…</p>
<p>大概是在我重新讲解的过程中理解并感受到了刚才那个问题的高能，该男子便在五分钟内结束了面试，并告诉我回去等结果。</p>
<h3 id="搜狐-1">搜狐</h3>
<p>中午从朝阳怒坐十七站地铁到搜狐大厦，赶在面试时间两点前吃了碗兰州拉面便又开始了下午的征程。</p>
<p>春天淡淡的阳光温暖着我单薄的身躯，脑海中抛去上午的经历，我又一次踏入了搜狐大厦，对面迎接我的是，等等，为什么是同样一脸惊奇的看着我的同实验室的傻逼哥们…好巧啊哈哈，你也投了搜狐啊…于是我们俩建立了坚实的盟友关系…</p>
<ul>
<li><p>一面<br>一个和蔼的帅哥负责一面，大概聊了项目，聊了之前面过的一些问题，写了快排，谈了谈人生，顺利通过。</p>
</li>
<li><p>二面<br>聊了MongoDB和Mysql的区别，什么时候更适合用MongoDB；聊了Mysql的索引问题；聊了Hive的partition和bucket；聊了Java很多相关知识；最后问了如何判断单链表是否有环便基本结束了面试。</p>
</li>
</ul>
<p>晚上回去的路上和基友互通了面试内容，发现基本相同，因为之后再没有面试安排，便呼朋唤友小小腐败了一下。晚上回到宿舍查看了一下阿里的面试进度，不看不知道，一看吓一跳，居然变成了rejecting，心情瞬间一落万丈，因为说实话阿里的offer是我非常希望得到的，但是就这么不明所以的被reject了，心里很难平复，加上晚上聚餐又喝了点酒，于是在心里各种问候了面试官本人，加之连续肉体和精神的疲劳，不到十一点就上床睡着了。</p>
<h2 id="周四">周四</h2>
<h3 id="搜狗">搜狗</h3>
<p>一觉睡到十点，不是自然醒，被电话吵醒了，被通知下午去搜狗面试。</p>
<p>下午两点，搜狗会客厅，上来就是一个leader，大概聊了聊我的实习经历后，说找个技术来和我聊聊。</p>
<p>五分钟后，一张我估计最近几个月都不可能忘记的面孔出现了，不羁的胡须配着极其和善的笑容，我遇到了人生中最大的对手。</p>
<p>不羁哥看着我的简历，和善的笑着，问了问我百度的实习经历，然后抛出一个问题，如何将数据自动每天从Hive导入Mysql，我说写脚本啊Hive -e然后加到crontab里，不羁哥说你在百度所有的都是这么干么，我说并不是，而是balabala。那你尝试实现一下。额，当时这块并不由我负责…你熟悉Java？来讲讲如何用Maven管理项目。额，并没有相关经验。你熟悉hadoop？来讲讲elephant bird。额，不好意思，你说什么？你用github搭建了博客，那平时看到github项目里的build.xml是做什么的。不好意思，这个并不知道…</p>
<p>二十分钟，从最初的尝试挣扎到趋于平静，我强烈感受到了人与人之间的区别，也感受到了自己的稚嫩。</p>
<p>最后不羁哥依旧和善的笑着看着我，我也和善的笑着看着他，我们如此和平的对望了几秒钟，他说，你还有什么问题么？我说了一个字：服。</p>
<p>回去后便感觉身体不适，于是成功的重度感冒了。但又接到了周五面试的电话，还不能休息，于是去实验室默默的弥补着不足的知识点。由于不想洗杯子，但又不能让感冒加重，于是干咽了两包抗病毒颗粒，你永远无法想象干嚼抗病毒颗粒的舒爽，没有自虐倾向的建议不要尝试。</p>
<h2 id="周五">周五</h2>
<h3 id="搜狐-2">搜狐</h3>
<p>意外的又收到了搜狐另一个部门的面试邀请，面试的是一个比较年轻的男性，他也在百度有相关实习经历，所以我们相谈甚欢，讲了很多算法的优缺点，讲了Linux的awk和shell，问了两道算法题，最后他问我你知道百度的日本网站么，我说那不如M-team方便，他说哦1024也不错。我们都含蓄的笑了。</p>
<h3 id="美团">美团</h3>
<p>美团面试下午两点半开始，一面居然是一个美女，问了很多mysql和hive的问题，问了hadoop的流程，问了linux，然后她一笑说，来两个智力题咯？请听题，两根同样长度的绳子，密度都不均匀，但燃烧完所用时间都是20min，如何准确的用这两根绳表示5min？想了一下，告诉她从两端一起烧什么的完美解决。请听题，一个国家重男轻女，如果生了女儿就会再生，直到生个儿子，问该国男女比例。想了五分钟，告诉了她答案和关键思想：数学期望。美女笑了一下，说不错啊，于是结束了一面。二面又问了很多之前经历过的问题就不一一表述了，算法题让求出任意一个很大数字（几千）阶乘后末尾有几个零，想了半天试探着说遍历这个数字，查找其中尾数是5的数字，然后就想不出来了，面试官笑了一下说接近了，让我再想想，但还是没能解决有点遗憾。最后问了他我去之后可能会做的事情，他说应该和百度差不多吧，我说那谢谢了，我不太想做重复性的，然后结束了五天的奔波。</p>
<h2 id="总结">总结</h2>
<p>可能很多人此刻会问我你到底收割了多少offer，我只能告诉你，我收到了自己想要的offer。</p>
<p>也可能会有很多人说，你被阿里拒了才故意黑阿里的面试吧，我只能告诉你，我曾经很想去一个公司，那个公司叫阿里，但在被reject后，我想了很多。其实这只是实习，很多人（包括我）盲目的过分追求所谓大公司的实习经历，认为去了大公司自己就水涨船高了，对抱有这样想法的人，我觉得你需要一次我在搜狗的洗礼，公司牛并不代表你牛，当然如果你是阿里星，腾讯TST这类的，可以右上角红叉不要浪费时间了，如果你认为你还有很多提升的余地，请忽略掉公司的头衔，忽略掉实习的薪水，忽略掉实习转正的那根稻草，请多问问你的面试官，如果我来了，会让我做什么，我能学到什么。如果这正巧是你所欠缺或希望加强的，那么请把握。</p>
<p>当然面试官水平也反应了你所面试部门的水平。╮(╯▽╰)╭</p>
]]></content>
    <summary type="html">
    <![CDATA[You gotta have a little faith man.]]>
    
    </summary>
    
      <category term="life" scheme="http://alexyyek.github.io/tags/life/"/>
    
      <category term="生活感悟" scheme="http://alexyyek.github.io/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[抽象类和接口]]></title>
    <link href="http://alexyyek.github.io/2015/03/06/Interface/"/>
    <id>http://alexyyek.github.io/2015/03/06/Interface/</id>
    <published>2015-03-06T13:31:27.000Z</published>
    <updated>2015-03-06T13:38:48.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>Thinking in Java ： 接口和内部类为我们提供了一种将接口与实现分离的更加结构化的方法。</p>
</blockquote>
<h2 id="抽象类">抽象类</h2>
<p>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。</p>
<p>抽象方法的声明规则：抽象方法只包含一个方法名，而没有方法体（无花括号）：abstract void f(); </p>
<p>以抽象类Shapes为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shapes</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> width, height;</div><div class="line">    <span class="keyword">public</span> <span class="title">Shapes</span>(<span class="keyword">int</span> width, <span class="keyword">int</span> height) {</div><div class="line">        <span class="keyword">this</span>.width = width;</div><div class="line">        <span class="keyword">this</span>.height = height;</div><div class="line">    }</div><div class="line">    <span class="keyword">abstract</span> <span class="keyword">double</span> getArea();</div><div class="line">    <span class="keyword">abstract</span> <span class="keyword">double</span> getPerimeter();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>当Square类继承Shapes时，它提供了getArea和getPerimeter方法的实现：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Shapes</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getArea</span>() {</div><div class="line">        <span class="keyword">return</span> (width * height);</div><div class="line">    }</div><div class="line">    <span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPerimeter</span>() {</div><div class="line">        <span class="keyword">return</span> (<span class="number">2</span> * width + <span class="number">2</span> * height);</div><div class="line">    }</div><div class="line">    <span class="keyword">public</span> <span class="title">Square</span>(<span class="keyword">int</span> width, <span class="keyword">int</span> height) {</div><div class="line">        <span class="keyword">super</span>(width, height);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>包含抽象方法的类叫做抽象类，如果一个类包含一个或多个抽象方法，该类必须被限定为抽象的。</p>
<p>如果从一个抽象类继承，并想创建该导出类的对象，那么就必须为基类中的所有抽象方法提供方法定义。如果选择不做，那么导出类便也是抽象类，编译器会强制用<code>abstract</code>关键字来限定这个类。</p>
<p>抽象类不能被实例化，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Public class Test{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args)  {</div><div class="line">        Shapes s1 = <span class="keyword">new</span> Square();</div><div class="line">        Square s2 = <span class="keyword">new</span> Square();</div><div class="line">        </div><div class="line">        s1.getArea();</div><div class="line">        s2.getPerimeter();</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在使用抽象类时需要注意几点：</p>
<ol>
<li>抽象类不能被实例化，实例化的工作应该交由它的子类来完成。但类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。</li>
<li>抽象方法必须由子类来进行<code>重写</code>。</li>
<li>只要包含一个抽象方法的抽象类，该方法必须要定义成抽象类，不管是否还包含有其他方法。</li>
<li>抽象类中可以包含具体的方法，当然也可以不包含抽象方法。</li>
<li>abstract不能与final并列修饰同一个类。</li>
<li>abstract不能与private、static、final或native并列修饰同一个方法。</li>
</ol>
<blockquote>
<p> Think in java：创建抽象类和抽象方法非常有用,因为他们可以使类的抽象性明确起来,并告诉用户和编译器打算怎样使用他们.抽象类还是有用的重构器,因为它们使我们可以很容易地将公共方法沿着继承层次结构向上移动。</p>
</blockquote>
<h2 id="接口">接口</h2>
<p>接口是一种比抽象类更加抽象的一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）。</p>
<p>接口建立类与类之间的协议，它所提供的只是一种形式，而没有具体的实现。实现该接口的实现类<strong>必须要实现该接口的所有方法</strong>。</p>
<p>接口是抽象类的延伸，Java了保证数据安全是不能多重继承的，也就是说继承只能存在一个父类。但是接口不同，一个类可以同时实现多个接口，不管这些接口之间有没有关系，所以接口弥补了抽象类不能多重继承的缺陷，但是推荐继承和接口共同使用，因为这样既可以保证数据安全性又可以实现多重继承。</p>
<p>以Externalizable接口为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Externalizable</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>{</div><div class="line"></div><div class="line">    <span class="keyword">void</span> writeExternal(ObjectOutput out) <span class="keyword">throws</span> IOException;</div><div class="line"> </div><div class="line">    <span class="keyword">void</span> readExternal(ObjectInput in) <span class="keyword">throws</span> IOException, ClassNotFoundException;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>当你实现这个接口时，你就需要实现上面的两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Externalizable</span> </span>{</div><div class="line"> </div><div class="line">    <span class="keyword">int</span> employeeId;</div><div class="line">    String employeeName;</div><div class="line"> </div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span>(ObjectInput in) <span class="keyword">throws</span> IOException, ClassNotFoundException {</div><div class="line">        employeeId = in.readInt();</div><div class="line">        employeeName = (String) in.readObject();</div><div class="line"> </div><div class="line">    }</div><div class="line"> </div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span>(ObjectOutput out) <span class="keyword">throws</span> IOException {</div><div class="line"> </div><div class="line">        out.writeInt(employeeId);</div><div class="line">        out.writeObject(employeeName);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在使用接口过程中需要注意如下几个问题：</p>
<ol>
<li>Interface的所有<strong>方法访问权限</strong>自动被声明为<code>public</code>。确切的说只能为public，当然你可以显示的声明为protected、private，但是编译会出错.</li>
<li>接口中可以定义“成员变量”，或者说是不可变的常量，因为接口中的“成员变量”会自动变为为<code>public static final</code>。可以通过类命名直接访问：ImplementClass.name。</li>
<li>接口中不存在实现的方法。</li>
<li>实现接口的非抽象类必须要实现该接口的所有方法。抽象类可以不用实现。</li>
<li>不能使用new操作符实例化一个接口，但可以声明一个接口变量，该变量必须引用(refer to)一个实现该接口的类的对象。可以使用 instanceof 检查一个对象是否实现了某个特定的接口。例如：if(anObject instanceof Comparable)。</li>
<li>在实现多接口的时候一定要避免方法名的重复。</li>
</ol>
<h2 id="抽象类与接口的区别">抽象类与接口的区别</h2>
<p>尽管抽象类和接口之间存在较大的相同点，甚至有时候还可以互换，但这样并不能弥补他们之间的差异之处。下面将从语法层次和设计层次两个方面对抽象类和接口进行阐述。</p>
<h3 id="语法层次">语法层次</h3>
<p>在语法层次，java语言对于抽象类和接口分别给出了不同的定义。下面已Demo类来说明他们之间的不同之处。<br>使用抽象类来实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>{</div><div class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> method1();</div><div class="line">    </div><div class="line">    <span class="keyword">void</span> method2(){</div><div class="line">        <span class="comment">//具体实现</span></div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>使用接口来实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">interface Demo {</div><div class="line">    <span class="keyword">void</span> method1();</div><div class="line">    <span class="keyword">void</span> method2();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>抽象类方式中，抽象类可以拥有任意范围的成员数据，同时也可以拥有自己的非抽象方法.</p>
<p>但是接口方式中，它仅能够有静态、不能修改的成员数据（但是我们一般是不会在接口中使用成员数据），同时它所有的方法都必须是抽象的。在某种程度上来说，接口是抽象类的特殊化。</p>
<p>对子类而言，它只能继承一个抽象类（这是java为了数据安全而考虑的），但是却可以实现多个接口。</p>
<p><br></p>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">抽象类</th>
<th style="text-align:center">接口</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">实现</td>
<td style="text-align:center">子类使用extends关键字来继承抽象类,它需要提供抽象类中所有声明的方法的实现。</td>
<td style="text-align:center">子类使用关键字implements来实现接口,它需要提供接口中所有声明的方法的实现</td>
</tr>
<tr>
<td style="text-align:center">构造器</td>
<td style="text-align:center">抽象类可以有构造器</td>
<td style="text-align:center">接口不能有构造器</td>
</tr>
<tr>
<td style="text-align:center">方法</td>
<td style="text-align:center">抽象类中可以拥有自己的成员变量和非抽象类方法</td>
<td style="text-align:center">接口中只能存在静态的不可变的成员数据（不过一般都不在接口中定义成员数据），而且它的所有方法都是抽象的</td>
</tr>
<tr>
<td style="text-align:center">访问修饰符</td>
<td style="text-align:center">抽象方法可以有public、protected和default这些修饰符</td>
<td style="text-align:center">接口方法默认修饰符是public。你不可以使用其它修饰符。</td>
</tr>
<tr>
<td style="text-align:center">main方法</td>
<td style="text-align:center">抽象方法可以有main方法并且我们可以运行它</td>
<td style="text-align:center">接口没有main方法，因此我们不能运行它</td>
</tr>
<tr>
<td style="text-align:center">多继承</td>
<td style="text-align:center">抽象方法可以继承一个类和实现多个接口</td>
<td style="text-align:center">接口只可以继承一个或多个其它接口</td>
</tr>
<tr>
<td style="text-align:center">速度</td>
<td style="text-align:center">它比接口速度要快</td>
<td style="text-align:center">接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。</td>
</tr>
</tbody>
</table>
<p><br></p>
<h3 id="设计层次">设计层次</h3>
<p>上面只是从语法层次和编程角度来区分它们之间的关系，这些都是低层次的，要真正使用好抽象类和接口，我们就必须要从较高层次来区分了。只有从设计理念的角度才能看出它们的本质所在。一般来说他们存在如下三个不同点：</p>
<ol>
<li><strong><code>抽象层次不同</code></strong>。抽象类是对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。</li>
<li><strong><code>跨域不同</code></strong>。抽象类所跨域的是具有相似特点的类，而接口却可以跨域不同的类。我们知道抽象类是从子类中发现公共部分，然后泛化成抽象类，子类继承该父类即可，但是接口不同。实现它的子类可以不存在任何关系，共同之处。例如猫、狗可以抽象成一个动物类抽象类，具备叫的方法。鸟、飞机可以实现飞Fly接口，具备飞的行为，这里我们总不能将鸟、飞机共用一个父类吧！<strong>所以说抽象类所体现的是一种继承关系</strong>，要想使得继承关系合理，父类和派生类之间必须存在”is-a” 关系，即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的，仅仅是实现了接口定义的契约而已。</li>
<li><strong><code>设计层次不同</code></strong>。对于抽象类而言，它是自下而上来设计的，我们要先知道子类才能抽象出父类，而接口则不同，它根本就不需要知道子类的存在，只需要定义一个规则即可，至于什么子类、什么时候怎么实现它一概不知。比如我们只有一个猫类在这里，如果你这是就抽象成一个动物类，是不是设计有点儿过度？我们起码要有两个动物类，猫、狗在这里，我们在抽象他们的共同点形成动物抽象类吧！所以说抽象类往往都是通过重构而来的！但是接口就不同，比如说飞，我们根本就不知道会有什么东西来实现这个飞接口，怎么实现也不得而知，我们要做的就是事前定义好飞的行为接口。<strong>所以说抽象类是自底向上抽象而来的，接口是自顶向下设计出来的</strong>。</li>
</ol>
<p>为了更好的阐述他们之间的区别，下面将使用一个例子来说明:</p>
<p>我们有一个Door的抽象概念，它具备两个行为open()和close()，此时我们可以定义通过抽象类和接口来定义这个抽象概念：</p>
<p>抽象类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> class Door{</div><div class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> open();</div><div class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> close();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">interface Door{</div><div class="line">    <span class="keyword">void</span> open();</div><div class="line">    <span class="keyword">void</span> close();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>至于其他的具体类可以通过使用extends使用抽象类方式定义Door或者Implements使用接口方式定义Door，这里发现两者并没有什么很大的差异。</p>
<p>但是现在如果我们需要门具有报警的功能，那么该如何实现呢？</p>
<ul>
<li>解决方案一：给Door增加一个报警方法:clarm();</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> class Door{</div><div class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> open();</div><div class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> close();</div><div class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> clarm();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">interface Door{</div><div class="line">    <span class="keyword">void</span> open();</div><div class="line">    <span class="keyword">void</span> close();</div><div class="line">    <span class="keyword">void</span> clarm();</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这种方法违反了面向对象设计中的一个核心原则：ISP (Interface Segregation Principle)，在Door的定义中把Door概念本身固有的行为方法和另外一个概念”报警器”的行为方 法混在了一起。这样引起的一个问题是那些仅仅依赖于Door这个概念的模块会因为”报警器”这个概念的改变而改变，反之依然。</p>
<p>ISP（Interface Segregation Principle）：面向对象的一个核心原则。它表明使用多个专门的接口比使用单一的总接口要好。一个类对另外一个类的依赖性应当是建立在最小的接口上的。一个接口代表一个角色，不应当将不同的角色都交给一个接口。没有关系的接口合并在一起，形成一个臃肿的大接口，这是对角色和接口的污染。</p>
<ul>
<li>解决方案二</li>
</ul>
<p>既然open()、close()和alarm()属于两个不同的概念，那么我们依据ISP原则将它们分开定义在两个代表两个不同概念的抽象类里面，定义的方式有三种：</p>
<ol>
<li>两个都使用抽象类来定义。</li>
<li>两个都使用接口来定义。</li>
<li>一个使用抽象类定义，一个是用接口定义。</li>
</ol>
<p>由于Java不支持多继承所以第一种是不可行的。后面两种都是可行的，<strong>但是选择何种就反映了你对问题域本质的理解</strong>。</p>
<p>如果选择第二种都是接口来定义，那么就反映了两个问题：1、我们可能没有理解清楚问题域，AlarmDoor在概念本质上到底是门还报警器。2、如果我们对问题域的理解没有问题，比如我们在分析时确定了AlarmDoor在本质上概念是一致的，那么我们在设计时就没有正确的反映出我们的设计意图。因为你使用了两个接口来进行定义，他们概念的定义并不能够反映上述含义。</p>
<p>第三种，如果我们对问题域的理解是这样的：AlarmDoor本质上Door，但同时它也拥有报警的行为功能，这个时候我们使用第三种方案恰好可以阐述我们的设计意图。AlarmDoor本质是们，所以对于这个概念我们使用抽象类来定义，同时AlarmDoor具备报警功能，说明它能够完成报警概念中定义的行为功能，所以alarm可以使用接口来进行定义。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> class Door{</div><div class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> open();</div><div class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> close();</div><div class="line">}</div><div class="line"></div><div class="line">interface Alarm{</div><div class="line">    <span class="keyword">void</span> alarm();</div><div class="line">}</div><div class="line"></div><div class="line">class AlarmDoor extends Door implements Alarm{</div><div class="line">    <span class="keyword">void</span> open(){}</div><div class="line">    <span class="keyword">void</span> close(){}</div><div class="line">    <span class="keyword">void</span> alarm(){}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这种实现方式基本上能够明确的反映出我们对于问题领域的理解，正确的揭示我们的设计意图。</p>
]]></content>
    <summary type="html">
    <![CDATA[Interfaces and abstract classes provide more structured way to separate interface from implementation.]]>
    
    </summary>
    
      <category term="coding" scheme="http://alexyyek.github.io/tags/coding/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java多态性]]></title>
    <link href="http://alexyyek.github.io/2015/03/04/Polymorphism/"/>
    <id>http://alexyyek.github.io/2015/03/04/Polymorphism/</id>
    <published>2015-03-04T13:39:25.000Z</published>
    <updated>2015-03-04T14:36:31.000Z</updated>
    <content type="html"><![CDATA[<p>面向对象编程有三大特性：封装、继承、多态。</p>
<p>封装隐藏了类的内部实现机制，可以在不影响使用的情况下改变类的内部结构，同时也保护了数据。对外界而已它的内部细节是隐藏的，暴露给外界的只是它的访问方法。</p>
<p>继承是为了重用父类代码。两个类若存在IS-A的关系就可以使用继承。同时继承也为实现多态做了铺垫。</p>
<p>多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。</p>
<p>多态也称作动态绑定。</p>
<h2 id="静态绑定">静态绑定</h2>
<p>静态绑定又名前期绑定。</p>
<p>如果编译器可以在编译阶段就完成绑定，就叫作静态绑定或前期绑定。基本上实例方法都在运行时绑定。</p>
<p>所有的静态方法<code>static</code>都在编译时绑定，所以静态方法是静态绑定的。因为静态方法是属于类的方法，可以通过类名来访问(我们也应该使用类名来访问静态方法，而不是使用对象引用来访问)，所以要访问它们就必须在编译阶段就使用编译类型信息来进行绑定。这也就解释了为什么静态方法实际上不能被重写。</p>
<p>为了防止方法被他人覆盖，我们会将某个方法声明为<code>final</code>（private方法属于final方法），这样做可以有效的关闭动态绑定，或者说告诉编译器不需要对其进行动态绑定。这样编译器就可以为final方法调用生成更有效的代码。</p>
<p>类似的，访问成员变量也是静态绑定的，因为Java不支持(实际上是不鼓励)成员变量的多态行为。下面看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class SuperClass{</div><div class="line">...</div><div class="line"><span class="keyword">public</span> String someVariable = <span class="string">"Some Variable in SuperClass"</span>;</div><div class="line">...</div><div class="line">}</div><div class="line"> </div><div class="line">class SubClass extends SuperClass{</div><div class="line">...</div><div class="line"><span class="keyword">public</span> String someVariable = <span class="string">"Some Variable in SubClass"</span>;</div><div class="line">...</div><div class="line">}</div><div class="line"></div><div class="line">SuperClass superClass1 = <span class="keyword">new</span> SuperClass();</div><div class="line">SuperClass superClass2 = <span class="keyword">new</span> SubClass();</div><div class="line"> </div><div class="line">System.out.println(superClass1.someVariable);</div><div class="line">System.out.println(superClass2.someVariable);</div></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Some Variable in SuperClass</div><div class="line">Some Variable in SuperClass</div></pre></td></tr></table></figure>

<p>我们可以发现成员变量由对象引用声明的类型决定，是由编译器在编译阶段就知道的信息，所以是静态绑定。另外一个静态绑定的例子是私有的方法，因为它们不会被继承，编译器在编译阶段就完成私有方法的绑定了。</p>
<h2 id="动态绑定">动态绑定</h2>
<p>动态绑定又名后期绑定。</p>
<p>动态绑定是指编译器在编译阶段不知道要调用哪个方法，直到运行时才能确定。Java中除了<code>static</code>方法和<code>final</code>方法之外，其他所有方法都是后期绑定。让我们用个例子来解释。譬如我们有一个叫作’SuperClass’的父类，还有一个继承它的子类’SubClass’。现在SuperClass引用也可以赋给SubClass类型的对象。如果SuperClass中有个someMethod()的方法，而子类也重写了这个方法，那么当调用SuperClass引用的这个方法的时候，编译器不知道该调用父类还是子类的方法，因为编译器不知道对象到底是什么类型，只有到运行时才知道这个引用指向什么对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">SuperClass superClass1 = <span class="keyword">new</span> SuperClass();</div><div class="line">SuperClass superClass2 = <span class="keyword">new</span> SubClass();</div><div class="line">...</div><div class="line"> </div><div class="line">superClass1.someMethod(); <span class="comment">// SuperClass version is called</span></div><div class="line">superClass2.someMethod(); <span class="comment">// SubClass version is called</span></div></pre></td></tr></table></figure>

<p>我们可以看到虽然对象引用superClass1和superClass2都是SuperClass类型的，但是在运行时它们分别指向SuperClass和SubClass类型的对象。</p>
<p>所以在编译阶段，编译器不清楚调用引用的someMethod()到底是调用子类还是父类的该方法。</p>
<p>所以方法的动态绑定是基于实际的对象类型，而不是它们声明的对象引用类型。</p>
<h2 id="缺陷">缺陷</h2>
<ul>
<li>“覆盖”私有方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivateOverride</span></span>{</div><div class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">f</span>(){system.out.println(<span class="string">"private f()"</span>);}</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){</div><div class="line">    PrivateOverride po = <span class="keyword">new</span> PrivateOverride();</div><div class="line">    po.f();</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line">class Derived extends PrivateOverride{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span>(){system.out.println(<span class="string">"public f()"</span>);}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="title">f</span>()</div></pre></td></tr></table></figure>

<p>我们期望输出public f()，<strong>但是private方法被自动认为是final方法，而且对导出类是自动屏蔽的</strong>。</p>
<p>因此Derived中的f()方法是一个全新的方法，虽然和PrivateOverride中的方法同名…</p>
<p>所以在导出类中，对于基类的private方法，最好采用不同的名字。</p>
<ul>
<li>域与静态方法：如静态绑定中例子一样，任何域访问操作都是由编译器解析，因此不是多态的。</li>
</ul>
<h2 id="构造器与多态">构造器与多态</h2>
<h3 id="构造器的调用顺序">构造器的调用顺序</h3>
<p>下面的例子展示了组合、继承以及多态在构建顺序上的作用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">class Meal{</div><div class="line">    Meal(){print(<span class="string">"Meal()"</span>);}</div><div class="line">}</div><div class="line"></div><div class="line">class Bread{</div><div class="line">    Bread(){print(<span class="string">"Bread()"</span>);}</div><div class="line">}</div><div class="line"></div><div class="line">class Cheese{</div><div class="line">    Cheese(){print(<span class="string">"Cheese()"</span>);}</div><div class="line">}</div><div class="line"></div><div class="line">class Lunch extends Meal{</div><div class="line">    Lunch(){print(<span class="string">"Lunch()"</span>);}</div><div class="line">}</div><div class="line"></div><div class="line">class PortableLunch extends Meal{</div><div class="line">    PortableLunch(){print(<span class="string">"PortableLunch()"</span>);}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sandwich</span> <span class="title">extend</span> <span class="title">PortableLunch</span> </span>{</div><div class="line">    <span class="keyword">private</span> Bread b = <span class="keyword">new</span> Bread;</div><div class="line">    <span class="keyword">private</span> Cheese c = <span class="keyword">new</span> Cheese;</div><div class="line">    <span class="keyword">public</span> <span class="title">Sandwich</span>(){print(<span class="string">"Sandwich()"</span>)}</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args)  {</div><div class="line">        <span class="keyword">new</span> Sandwich();</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<ol>
<li>调用基类构造器</li>
<li>按声明顺序调用成员的初始化方法</li>
<li>调用导出类构造器的主体</li>
</ol>
<p>因此输出结果为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Meal()</div><div class="line">Lunch()</div><div class="line">PortableLunch()</div><div class="line">Bread()</div><div class="line">Cheese()</div><div class="line">Sandwich()</div></pre></td></tr></table></figure>

<h3 id="构造器内部的多态方法的行为">构造器内部的多态方法的行为</h3>
<p>如果在一个构造器内部调用正在构造的对象的动态绑定方法，就要用到那个方法被覆盖后的定义。然后，这个方法所操纵的成员可能还未进行初始化——这可能会导致灾难。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">class Glyph {</div><div class="line">    <span class="keyword">void</span> draw() {print(<span class="string">"Glyph()"</span>);}</div><div class="line">    Glyph() {</div><div class="line">    print(<span class="string">"Glyph() before draw()"</span>);</div><div class="line">    draw();</div><div class="line">    print(<span class="string">"Glyph() after draw()"</span>);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line">class RoundGlyph extends Glyph  {</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> radius = <span class="number">1</span>;</div><div class="line">    RoundGlyph(<span class="keyword">int</span> r)   {</div><div class="line">        radius = r;</div><div class="line">        print(<span class="string">"RoundGlyph.RoundGlyph.radius = "</span> + radius);</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keyword">void</span> draw() {</div><div class="line">        print(<span class="string">"RoundGlyph.RoundGlyph.radius = "</span> + radius);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlyConstructor</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){</div><div class="line">        <span class="keyword">new</span> RoundGlyph(<span class="number">5</span>);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>上一节讲述的初始化顺序其实并不完整，实际过程是：</p>
<ol>
<li>在其他任何事物发生之前，将分配给对象的存储空间初始化为二进制的零</li>
<li>调用基类构造器。由于步骤1，发现radius是0</li>
<li>按照声明的顺序调用成员的初始化方法。</li>
<li>调用导出类的构造器主题</li>
</ol>
<p>输出结果为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Glyph() before draw()</div><div class="line">RoundGlyph.RoundGlyph.radius = <span class="number">0</span></div><div class="line">Glyph() after draw()</div><div class="line">RoundGlyph.RoundGlyph.radius = <span class="number">5</span></div></pre></td></tr></table></figure>

<p><br></p>
<blockquote>
<p>Thinking in Java : As a result, a good guideline for constructors is, “Do as little as possible to set the object into a good state, and if you can possibly avoid it, don’t call any other methods in this class.” </p>
</blockquote>
<p>The only safe methods to call inside a constructor are those that are final in the base class. (This also applies to private methods, which are automatically final.) These cannot be overridden and thus cannot produce this kind of surprise. You may not always be able to follow this guideline, but it’s something to strive towards.</p>
<p>分享一篇较为通俗的<a href="http://www.cnblogs.com/chenssy/p/3372798.html" target="_blank" rel="external">讲解</a></p>
]]></content>
    <summary type="html">
    <![CDATA[多态是一项让程序员将改变的事物与未变的事物分离开来的重要技术。]]>
    
    </summary>
    
      <category term="coding" scheme="http://alexyyek.github.io/tags/coding/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java复用类]]></title>
    <link href="http://alexyyek.github.io/2015/01/14/Reusing/"/>
    <id>http://alexyyek.github.io/2015/01/14/Reusing/</id>
    <published>2015-01-14T12:48:39.000Z</published>
    <updated>2015-01-15T13:44:20.000Z</updated>
    <content type="html"><![CDATA[<p>多数时候我们不希望重新编写代码，而是希望使用已有的代码并加以更改或添加，类的复用为我们提供了这种机制，这也是面向对象语言重要的特点之一。复用类的主要方法有两种，组合与继承。继承和组合都是一种随思想渗透而下的编码方式，其根本目的都是为了复用类，减少重复代码。要实现一个类的复用，可以分为组合语法和继承语法。</p>
<h2 id="组合语法">组合语法</h2>
<blockquote>
<p>《Thinking in Java》：在新的类中产生现有类的对象。</p>
</blockquote>
<p>组合就是通过将一个对象置于一个新类中，将其作为新类的成员变量，组成类的一部分。由于新的类是由现有类的对象组成，所以称此方法为组合。</p>
<p>来看一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">class WaterSource{</div><div class="line">	<span class="keyword">private</span> String s;</div><div class="line">	WaterSource(){</div><div class="line">		System.out.println(<span class="string">"WaterSource()"</span>);</div><div class="line">		s = <span class="string">"constructed"</span>;</div><div class="line">	}</div><div class="line">	<span class="keyword">public</span> String <span class="title">toString</span>(){</div><div class="line">		<span class="keyword">return</span> s;</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SprinklerSystem</span> </span>{</div><div class="line">	<span class="keyword">private</span> String name = <span class="string">"Alex"</span>;<span class="comment">//Initializing at point of definition</span></div><div class="line">	<span class="keyword">private</span> String sex;</div><div class="line">	<span class="keyword">private</span> WaterSource wSource;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">double</span> d;</div><div class="line">	<span class="keyword">public</span>  <span class="title">SprinklerSystem</span>(){</div><div class="line">		System.out.println(<span class="string">"In Sprinkler"</span>);</div><div class="line">		d = <span class="number">1.0</span>;    <span class="comment">//Initailizing in the constructor of class</span></div><div class="line">		wSource = <span class="keyword">new</span> WaterSource();</div><div class="line">	}</div><div class="line">	<span class="keyword">public</span> String <span class="title">toString</span>(){</div><div class="line">		<span class="keyword">if</span> (sex == <span class="keyword">null</span>) { sex = <span class="string">"male"</span>; }<span class="comment">//Delayed initialization</span></div><div class="line">		<span class="keyword">return</span> </div><div class="line">			<span class="string">"string"</span> + <span class="string">"="</span> + name + <span class="string">" "</span> +</div><div class="line">			<span class="string">"sex"</span> + <span class="string">"="</span> + sex + <span class="string">" "</span> +</div><div class="line">			<span class="string">"double"</span> + <span class="string">"="</span> + d + <span class="string">" "</span> +</div><div class="line">			<span class="string">"WaterSource"</span> + <span class="string">"="</span> + wSource;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){</div><div class="line">		SprinklerSystem sprinklers = <span class="keyword">new</span> SprinklerSystem();</div><div class="line">		System.out.println(sprinklers);</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>我们可以看到，类SprinklerSystem中直接产生现有的类WaterSource，以此可以使用关于WaterSource的各种方法。</p>
<p>但注意这里两个类中都有一个很特殊的方法：toString()。</p>
<p>当编译器需要一个String而你只有一个对象wSource时，由于只能将两个String对象相加，因此编译器会调用toString方法，将wSource转化为一个String。当然如果没有写toString方法，这里会打印对象的地址。</p>
<p>打印输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">In Sprinkler</div><div class="line">WaterSource()</div><div class="line">string=Alex sex=male <span class="keyword">double</span>=<span class="number">1.0</span> WaterSource=constructed</div></pre></td></tr></table></figure>

<p>此外，编译器并不是简单的为每一个引用都创建默认对象，避免不必要的负担。如果想初始化这些引用，可以在例子中的这些位置进行：</p>
<ol>
<li>定义对象的地方</li>
<li>在类的构造器中</li>
<li>在正要使用这些对象之前</li>
<li>使用实例初始化</li>
</ol>
<p>由此可以看出：组合是在新类产生现有类的对象，组合出功能给更强的新类。</p>
<p><strong>如果将继承比作Is-A的关系（什么是什么..），组合则是Has-A(什么有什么)的关系。</strong></p>
<h2 id="继承">继承</h2>
<blockquote>
<p>《Thinking in Java》：通过现有类的类型创建新类，采用现有类的形式并在其中添加新代码。</p>
</blockquote>
<p>当创建一个类时，总是在继承，因此除非已明确指出要从其他类中继承，否则就是隐式的从Java的标准根类Object进行继承。继承通过<code>extends</code>关键字自动获得基类中的所有域和方法。在看下面的例子前建议先理解<code>super</code>关键字的 → <a href="http://docs.oracle.com/javase/tutorial/java/IandI/super.html" target="_blank" rel="external">用法</a>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line">class Base {</div><div class="line">	<span class="keyword">static</span> <span class="keyword">int</span> s1 = prt(<span class="string">"s1 initialized."</span>, <span class="number">11</span>);</div><div class="line">	<span class="keyword">int</span> i1 = prt(<span class="string">"i1 initialized."</span>, <span class="number">12</span>);</div><div class="line"></div><div class="line">	Base() {</div><div class="line">		System.out.println(<span class="string">"Base construcor"</span>);</div><div class="line">		System.out.println(<span class="string">"s1 = "</span> + s1 + <span class="string">" ,i1 = "</span> + i1);</div><div class="line">		draw();<span class="comment">// （d）</span></div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">void</span> draw() {</div><div class="line">		System.out.println(<span class="string">"base.draw：s1 = "</span> + s1 + <span class="string">" ,i1 = "</span> + i1);</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">static</span> <span class="keyword">int</span> prt(String s, <span class="keyword">int</span> num) {</div><div class="line">		System.out.println(s);</div><div class="line">		<span class="keyword">return</span> num;</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line">class Cleanser extends Base {</div><div class="line">	<span class="keyword">private</span> String s = <span class="string">"Cleaner"</span>;</div><div class="line">	<span class="keyword">static</span> <span class="keyword">int</span> s2 = prt(<span class="string">"s2 initialized."</span>, <span class="number">21</span>);</div><div class="line">	<span class="keyword">int</span> i2 = prt(<span class="string">"i2 initialized."</span>, <span class="number">22</span>);</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="title">Cleanser</span>() {</div><div class="line">		System.out.println(<span class="string">"Cleanser constructor"</span>);</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="title">Cleanser</span>(<span class="keyword">int</span> i) {</div><div class="line">		System.out.println(<span class="string">"Cleanser constructor init i:"</span> + i);</div><div class="line">		System.out.println(<span class="string">"s2 = "</span> + s2 + <span class="string">" ,i2 = "</span> + i2);</div><div class="line">		draw();</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">append</span>(String a) {</div><div class="line">		s += a;</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dilute</span>() {</div><div class="line">		append(<span class="string">" dilute()"</span>);</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrub</span>() {</div><div class="line">		append(<span class="string">" scrub()"</span>);</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">void</span> draw(){</div><div class="line">        System.out.println(<span class="string">"Cleanser.draw：s2 = "</span> + s2 + <span class="string">" ,i2 = "</span> + i2);</div><div class="line">    }</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> String <span class="title">toString</span>() {</div><div class="line">		<span class="keyword">return</span> s;</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">		Cleanser x = <span class="keyword">new</span> Cleanser();</div><div class="line">		x.dilute();</div><div class="line">		x.scrub();</div><div class="line">		System.out.println(x);</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Detergent</span> <span class="keyword">extends</span> <span class="title">Cleanser</span> </span>{</div><div class="line">	<span class="keyword">static</span> <span class="keyword">int</span> s3 = prt(<span class="string">"s3 initialized."</span>, <span class="number">31</span>);</div><div class="line">    <span class="keyword">int</span> i3 = prt(<span class="string">"i3 initialized"</span>, <span class="number">31</span>);</div><div class="line">    </div><div class="line">	<span class="keyword">public</span> <span class="title">Detergent</span>() {</div><div class="line">		<span class="keyword">super</span>(<span class="number">1024</span>);</div><div class="line">		System.out.println(<span class="string">"Detergent construcor"</span>);</div><div class="line">		System.out.println(<span class="string">"s3 = "</span> + s3 + <span class="string">" ,i3 = "</span> + i3);</div><div class="line">		draw();</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrub</span>() {</div><div class="line">		append(<span class="string">" Detergent.scrub()"</span>);</div><div class="line">		<span class="keyword">super</span>.scrub();</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foam</span>() {</div><div class="line">		append(<span class="string">" foam()"</span>);</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">void</span> draw(){</div><div class="line">        System.out.println(<span class="string">"Detergent.draw：s3 = "</span> + s3 + <span class="string">" ,i3 = "</span> + i3);</div><div class="line">    }</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">		Detergent detergent = <span class="keyword">new</span> Detergent();</div><div class="line">		detergent.dilute();</div><div class="line">		detergent.scrub();</div><div class="line">		detergent.foam();</div><div class="line">		System.out.println(detergent);</div><div class="line">		System.out.println(<span class="string">"Test base class:"</span>);</div><div class="line">		Cleanser.main(args);</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个例子糅合了继承中许多重要的点，我们首先分析一下基本框架，程序包含三个类，Base类、继承Base的Cleanser类，继承Cleanser的Detergent类。类中包含了静态成员，非静态成员，以及类内部的方法。下面来梳理程序流程。</p>
<h3 id="继承的初始化">继承的初始化</h3>
<p>$1$. 装载Detergent.class文件<br>$2$. 发现Detergent有关键字extends，装载Cleanser.class文件<br>$3$. 发现Cleanser有关键字extends，装载Base.class文件<br>$4$. 初始化Base class中的静态成员。初始化Cleanser class中的静态成员。初始化Detergent class中的静态成员。<strong>如果Detergent的main函数为空，到这里已经初始化完毕。</strong>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">s1 initialized.</div><div class="line">s2 initialized.</div><div class="line">s3 initialized.</div></pre></td></tr></table></figure>

<blockquote>
<p>《Thinking in Java》：继承并不只是复制基类的接口。当创建了一个导出类的对象时，该对象包含了一个基类的子对象。</p>
</blockquote>
<p>$5$. 为detergent对象分配存储空间，并把存储空间初始化为0。在Detergent的构造器中调用super(1024)，试图产生一个Cleanser class实例。<br>$6$. 为Cleanser对象分配存储空间。由于Cleanser类继承自Base类，会在Cleanser类的构造器中调用Base的无参构造函数。<br>$7$. 产生一个Base class实例。先初始化成员变量，再调用构造函数。回到Cleanser类执行同样步骤，Detergent类亦如此。</p>
<p>至创建detergent对象结束后，初始化的输出结果如下，其中要注意几点：</p>
<ul>
<li>继承中的构建过程是“向外”扩散的，先初始化基类，后初始化导出类。</li>
<li>注意Detergent类构造函数中<code>super</code>的使用，super用于导出类的构造函数，可以调用基类的构造方法。如果基类<strong>没有默认构造器或者带有参数</strong>，则需要显式构造，构造方法则是上面提到过的super，当然super要放在构造函数内第一行。</li>
<li>注意Base类和Cleanser类构造函数中的draw()方法，并没有按想象中直接调用类内部的draw()，而是统一调用了子类Detergent中的draw()方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">i1 initialized.</div><div class="line">Base construcor</div><div class="line">s1 = <span class="number">11</span> ,i1 = <span class="number">12</span></div><div class="line">Detergent.draw：s3 = <span class="number">31</span> ,i3 = <span class="number">0</span></div><div class="line">i2 initialized.</div><div class="line">Cleanser constructor init i:<span class="number">1111</span></div><div class="line">s2 = <span class="number">21</span> ,i2 = <span class="number">22</span></div><div class="line">Detergent.draw：s3 = <span class="number">31</span> ,i3 = <span class="number">0</span></div><div class="line">i3 initialized</div><div class="line">Detergent construcor</div><div class="line">s3 = <span class="number">31</span> ,i3 = <span class="number">31</span></div><div class="line">Detergent.draw：s3 = <span class="number">31</span> ,i3 = <span class="number">31</span></div></pre></td></tr></table></figure>

<h3 id="继承语法">继承语法</h3>
<p>在创建完detergent对象后，detergent对象开始调用不同方法，在Cleanser的接口中有一组方法：append()，dilute()，scrub()，draw()和toString()。由于Detergent是由关键字<code>extends</code>从Cleanser导出的，所以它可以再其接口中自动获得这些方法，因此可以将继承视作是对类的复用。</p>
<p>在Detergent中，我们复用了部分Cleanser中的方法，但改写了其中的scrub()，如果需要在新版本中调用从基类继承而来的方法，可以利用<code>super</code>关键字，正如开头链接中<code>super</code>的第一种使用方法：Accessing Superclass Members。</p>
<p>当然在继承中并不一定非要使用基类的方法，可以在导出类中添加新的方法，如Detergent类中新增的foam()方法。后续输出结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Cleaner dilute() Detergent.scrub() scrub() foam()</div><div class="line">Test base class:</div><div class="line">i1 initialized.</div><div class="line">Base constructor</div><div class="line">s1 = <span class="number">11</span> ,i1 = <span class="number">12</span></div><div class="line">Cleanser.draw：s2 = <span class="number">21</span> ,i2 = <span class="number">0</span></div><div class="line">i2 initialized.</div><div class="line">Cleanser constructor</div><div class="line">Cleaner dilute() scrub()</div></pre></td></tr></table></figure>

<h3 id="清理">清理</h3>
<p>清理过程是先执行导出类的清理代码，再执行基类的清除代码。这就像一棵大树，生长的时候要从根向叶子生长，但剪除的时候要从叶子向根剪除。如果一下子去掉了根，那么叶子你也就都找不到了。这种清理与以前说过的finalize方法不同，如果要执行这种清理工作，最好还是自己编写清理代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class Shape {</div><div class="line">    Shape(<span class="keyword">int</span> i) { print(<span class="string">"Shape constructor"</span>); }</div><div class="line">    <span class="keyword">void</span> dispose() { print(<span class="string">"Shape dispose"</span>); }</div><div class="line">}</div><div class="line">class Circle extends Shape {</div><div class="line">    Circle(<span class="keyword">int</span> i) {</div><div class="line">        <span class="keyword">super</span>(i);</div><div class="line">        print(<span class="string">"Drawing Circle"</span>);</div><div class="line">    }</div><div class="line">    <span class="keyword">void</span> dispose() {</div><div class="line">        print(<span class="string">"Erasing Circle"</span>);</div><div class="line">        <span class="keyword">super</span>.dispose();</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="名称屏蔽">名称屏蔽</h3>
<p>如果Java的基类拥有某个已被多次重载的方法名称，那么在导出类中重新定义该方法名称并不会屏蔽其在基类中的任何版本（与C++不同）。Java SE5新增了<code>@Override</code>注释，它并不是关键字，但是可以当做关键字使用。当你想要<strong><code>覆写</code></strong>某个方法时，可以选择添加这个注解，防止你不留心重载了该方法。通过下面表格区分重载和覆写：<br><br></p>
<table>
<thead>
<tr>
<th style="text-align:center">范围</th>
<th style="text-align:center">重载（Overload）</th>
<th style="text-align:center">覆写（Override）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">范围</td>
<td style="text-align:center">类内定义方法的不同版本</td>
<td style="text-align:center">子类为满足需要重复定义某个方法的不同实现</td>
</tr>
<tr>
<td style="text-align:center">方法名</td>
<td style="text-align:center">相同</td>
<td style="text-align:center">相同</td>
</tr>
<tr>
<td style="text-align:center">参数列表</td>
<td style="text-align:center">必须不同</td>
<td style="text-align:center">相同</td>
</tr>
<tr>
<td style="text-align:center">返回值类型</td>
<td style="text-align:center">可以不同</td>
<td style="text-align:center">相同</td>
</tr>
</tbody>
</table>
<h2 id="组合与继承的选择">组合与继承的选择</h2>
<p>组合与继承都允许在新的类中放置子对象，组合是显示的这样做，而继承是隐式地做。</p>
<p>组合技术通常用于想在新类中使用现有类的功能，而非它的接口。即在新类中嵌入某个对象，让其实现所需要的功能，但新类的用户只能看到为新类定义的接口，而非所有嵌入对象的接口。为取得此效果，<strong>需要在新类中嵌入一个现有类的private对象</strong>。</p>
<p>继承常用于你在使用一个通用类时，为了某种特殊需求而将其特殊化，开发一个它的特殊版本。就像开头说的：<strong>如果将继承比作Is-A的关系（什么是什么..），组合则是Has-A(什么有什么)的关系。</strong></p>
<h2 id="Protected关键字">Protected关键字</h2>
<p>讲完了继承，关键字protected也终于有了意义。在实际项目中，经常会想要境某些事物尽可能<strong>对这个世界隐藏起来，但仍然允许导出类或者其他位于同一个包内的类来说，它却是可以访问的</strong>。（protected也提供了包内访问权限）</p>
<p>尽管可以创建protected域，但是最好的方式还是将域保持为private；你应当一直保留<strong>更改底层实现的权利。</strong>然后通过protected方法来控制类的继承者的访问权限。</p>
<blockquote>
<p>The protected modifier specifies that the member can only be accessed within its own package (as with package-private) and, in addition, by a subclass of its class in another package.</p>
</blockquote>
<h2 id="向上转型">向上转型</h2>
<blockquote>
<p>《Thinking in Java》：The most important aspect of <strong>inheritance</strong> is not that it provides methods for the new class.It’s the <strong>relationship</strong> expressed between the new class and the base class. </p>
</blockquote>
<p>Wind类继承了基类Instrument，并创建了Wind对象，但是Instrument类仍可以使用Wind对象，程序代码可以对Instrument和它所有的导出类起作用。由于继承可以确保基类中所有的方法在导出类中也同样有效，所以能够向基类发送的所有信息同样也可以向导出类发送。这种将Wind引用转换为Instrument引用的动作，称为向上转型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Instrument {</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span>() {}</div><div class="line">    <span class="keyword">static</span> <span class="keyword">void</span> tune(Instrument i) {</div><div class="line">    i.play(); }</div><div class="line">}</div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wind</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>{</div><div class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">        Wind flute = <span class="keyword">new</span> Wind();</div><div class="line">        Instrument.tune(flute); <span class="comment">// Upcasting</span></div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>由于向上转型是从一个较专用类型向较通用类型转换，所以总是很安全的。在向上转型中，类接口中唯一可能发生的事情是丢失方法，而不是获取它们。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">class Game{</div><div class="line">	Game(<span class="keyword">int</span> i){</div><div class="line">		System.out.println(<span class="string">"Game constructor"</span>);</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line">class BoardGame extends Game{</div><div class="line">	BoardGame(<span class="keyword">int</span> i){</div><div class="line">		<span class="keyword">super</span>(i);</div><div class="line">		System.out.println(<span class="string">"BoardGame constructor"</span>);</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chess</span> <span class="keyword">extends</span> <span class="title">BoardGame</span></span>{</div><div class="line">	Chess(){</div><div class="line">		<span class="keyword">super</span>(<span class="number">250</span>);</div><div class="line">		System.out.println(<span class="string">"Chess constructor"</span>);</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span>(){};</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){</div><div class="line">		Game game = <span class="keyword">new</span> Chess();    <span class="comment">//向上转型</span></div><div class="line">		<span class="comment">/* Error </span></div><div class="line">		 * The method f() is undefined for the type Game</div><div class="line">		   game.f(); */</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果运行Chess，输出的是Game constructor 还是三个类全部初始化？</p>
<p>答案是全部初始化，即创建了子类Chess对象。这是因为game实际上指向的是一个子类对象。当然，你不用担心，Java虚拟机会自动准确地识别出究竟该调用哪个具体的方法。不过，由于向上转型，game对象会遗失和父类不同的方法，例如f()。</p>
<p>向上转型可以简化程序代码，例如这里的Monitor类 → <a href="http://blog.csdn.net/shanghui815/article/details/6088588" target="_blank" rel="external">栗子</a></p>
<h2 id="final关键字">final关键字</h2>
<p>为了设计或效率这两个截然不同的目的，我们可能会使用到final关键字。</p>
<h3 id="final_data">final data</h3>
<p>相比于C/C++中的const关键字，Java使用final来声明数据。对于基本类型，final保证数值恒定不变；用于对象引用，则保证引用恒定不变，也就是说无法再把该引用指向另一个对象。通常声明一个常量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VALUE = <span class="number">10</span>;</div></pre></td></tr></table></figure>

<p>定义为static强调只有一份，定义为final说明它是一个常量。</p>
<ul>
<li>final声明的变量，意味着无法将其引用对象再次指向另一个新的对象，而不是无法改变它的值。</li>
<li>带有恒等初始值的final static基本类型全用大写字母命名。</li>
<li>final成员变量必须在声明的时候初始化，或在构造器中初始化。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">class Vincent{</div><div class="line">	<span class="keyword">int</span> i;</div><div class="line">	<span class="keyword">public</span> <span class="title">Vincent</span>(<span class="keyword">int</span> i){</div><div class="line">		<span class="keyword">this</span>.i = i;</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalData</span></span>{</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> String id;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random(<span class="number">25</span>);</div><div class="line">	FinalData(String id){</div><div class="line">		<span class="keyword">this</span>.id = id;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> first = <span class="number">1024</span>;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SECOND = <span class="number">2048</span>;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THIRD = <span class="number">3072</span>;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> Vincent v1 = <span class="keyword">new</span> Vincent(<span class="number">1024</span>);</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Vincent v2 = <span class="keyword">new</span> Vincent(<span class="number">2048</span>);</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Vincent V3 = <span class="keyword">new</span> Vincent(<span class="number">3072</span>);</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> rand = random.nextInt(<span class="number">100</span>);</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RAND = random.nextInt(<span class="number">100</span>); </div><div class="line">	</div><div class="line">	<span class="keyword">public</span> String <span class="title">toString</span>(){</div><div class="line">		<span class="keyword">return</span> id + <span class="string">"\t"</span> + rand + <span class="string">"\t"</span> + RAND; </div><div class="line">	}</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){</div><div class="line">		FinalData fData = <span class="keyword">new</span> FinalData(<span class="string">"first trial"</span>);</div><div class="line">		</div><div class="line">		<span class="comment">/*	Error: Can't change value</span></div><div class="line">		 * 	fData.first++;</div><div class="line">		 */</div><div class="line">		</div><div class="line">		fData.v1.i++;</div><div class="line">		fData.v2.i++;</div><div class="line">		</div><div class="line">		fData.v1 = <span class="keyword">new</span> Vincent(<span class="number">1</span>); <span class="comment">//withour final</span></div><div class="line">		</div><div class="line">		<span class="comment">/* Error: Can't change reference </span></div><div class="line">		 * fData.v2 = new Value(2);</div><div class="line">		 * fData.V3 = new Value(3);</div><div class="line">		 */</div><div class="line">		</div><div class="line">		System.out.println(fData);	<span class="comment">//first trial	28	81</span></div><div class="line">		FinalData fData2 = <span class="keyword">new</span> FinalData(<span class="string">"second trial"</span>);</div><div class="line">		System.out.println(fData2); <span class="comment">//second trial	47	81</span></div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<ol>
<li>对final修饰的基本类型视为常量，不能再修改（如first、SECOND和THIRD）</li>
<li>final修饰的引用对象，可以改变值，如<code>fData.v2.i++;</code>，但不可修改指向对象。</li>
<li>不能因为数据是final的就认为在编译时已知了它的值，如rand和RAND，用static修饰的RAND在最开始便初始化完毕，故两次值不变。</li>
</ol>
<h3 id="final_method">final method</h3>
<p>现在使用final方法的原因只有一个：把方法锁定，以防止任何继承类修改他的含义，想要确保继承中使方法行为<strong>保持不变</strong>，并且<strong>不会覆盖</strong>。</p>
<ul>
<li>对于实例方法，final意味着在子类<strong>不能重写</strong>该方法，但<strong>可以重载</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Father{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">f</span>(){};</div><div class="line">}</div><div class="line">class Child extends Father{</div><div class="line">    <span class="comment">/* Error: Cannot override the final method from Father</span></div><div class="line">     * public final void f(){};</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">f</span>(<span class="keyword">int</span> i){};</div><div class="line">}</div></pre></td></tr></table></figure>

<ul>
<li>对于静态方法final的含义为，子类中<strong>不能隐藏（覆盖或重写）</strong>这个方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class Father{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f1</span>(){};</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">f2</span>(){};</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father</span></span>{</div><div class="line">	<span class="comment">/* Error: This instance method cannot override the static method from Father</span></div><div class="line">	 * public void f(){System.out.println("Alex");}</div><div class="line">	 */</div><div class="line">	</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f1</span>(<span class="keyword">int</span> i){System.out.println(<span class="string">"Alex"</span>);}</div><div class="line">    </div><div class="line">    <span class="comment">/* Error: Cannot override the final method from Father</span></div><div class="line">     * public static void f2(){};</div><div class="line">     */</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">f2</span>(<span class="keyword">int</span> i){};</div><div class="line">}</div></pre></td></tr></table></figure>

<p>静态方法是可以继承的，但是在子类中即使可以定义一个与父类方法签名相同的方法覆盖掉父类的方法，但是这并不是重写。重写应该在多态性上有所体现，但是覆盖父类静态方法并不会体现<a href="http://segmentfault.com/blog/zhaobing/1190000000669897" target="_blank" rel="external">多态性</a>。</p>
<h3 id="final_classes">final classes</h3>
<p>当将某个类整体定义为final时，就表明你不打算继承该类，而且也不允许别人这么做。换句话说，你对该类的设计用不需要做出任何变动，或者是出于安全考虑，你不希望它有子类。</p>
<p>由于final类禁止继承，所以final类中所有的方法都隐式指定为final的，因为无法覆盖他们。</p>
]]></content>
    <summary type="html">
    <![CDATA[One of the most compelling features about Java is code reuse. But to be revolutionary, you’ve got to be able to do a lot more than copy code and change it.]]>
    
    </summary>
    
      <category term="coding" scheme="http://alexyyek.github.io/tags/coding/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java访问权限控制]]></title>
    <link href="http://alexyyek.github.io/2015/01/12/Inherit/"/>
    <id>http://alexyyek.github.io/2015/01/12/Inherit/</id>
    <published>2015-01-12T14:47:08.000Z</published>
    <updated>2015-01-12T14:50:51.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>《Thinking in Java》：把数据和方法包装进类中，以及具体实现的隐藏，常共同被称作封装。</p>
</blockquote>
<p>在Thinking in Java这本书中，并没有用封装这个词来为这一章命名，而是选择访问控制权这个更接近本质的词。</p>
<p>访问控制权主要解决两个问题：</p>
<ol>
<li>设定客户端程序猿可以使用和不可用使用的界限。<br>利用这个界限可以在结构中建立自己的内部机制，而不用担心客户端程序猿将内部机制当作可以调用的接口。</li>
<li>接口和具体实现的分离。<br>客户端程序员只是调用你的接口，所以你可以任意修改所有访问权限控制不是public的代码，而不会破坏客户端的代码。</li>
</ol>
<p>在Java中，提供了四种访问权限控制：default（包访问权限），public，private 以及 protected，具体权限范围相信大家都比较熟悉，下面主要分享一些更深入的观点。</p>
<h2 id="类访问权限">类访问权限</h2>
<p>类中的访问权限只包含两种：public和包访问权限，为什么没有private和protect呢？</p>
<p>public就是说这个类可以随便外界使用，包访问权限就是辅助类的权限了，只允许同一个包内的别的类使用该辅助类。  </p>
<p>如果是要添加private控制一个类的权限，那么想表达什么意思呢？可能会说，我在辅助类的前面添加上一个Private，就想控制：仅仅允许同一个java文件内的主类使用这个类。有没有这个需求呢？肯定有，因为如果这个辅助类仅仅属于这一个主类，那么我就可以方便修改了，而不用管别的类是否在使用。 但是Java为什么没有设定这个private权限？ </p>
<p>答案是：Java提供了一个更容易理解的方式－－内部类实现了这个需求。用private修饰一个辅助类，其实是不符合private的意思的。所以用内部类来表示显的更自然。</p>
<p>那类为什么没有protected呢？其实可以发现并没有这个需求。 别的类要想继承我这个类，必须先能看到我这个类。如果你看不到我这个类，那还继承个毛线。</p>
<p>假设这样一种情况：不希望其他任何人对该类拥有访问权限，可以把所有的构造器都指定为private，从而阻止任何人创建该类的对象。该如何的实现呢？看下面一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">class Alex1 {</div><div class="line">	<span class="keyword">private</span> <span class="title">Alex1</span>() {</div><div class="line">	};</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Alex1 <span class="title">makeAlex1</span>() {</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Alex1();</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line">class Alex2 {</div><div class="line">	<span class="keyword">private</span> <span class="title">Alex2</span>() {</div><div class="line">	};</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Alex2 alex = <span class="keyword">new</span> Alex2();</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Alex2 <span class="title">access</span>() {</div><div class="line">		<span class="keyword">return</span> alex;</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span>() {</div><div class="line">	};</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Geek</span> </span>{</div><div class="line">	<span class="keyword">void</span> testPrivate() {</div><div class="line">		<span class="comment">/* Error : The constructor Alex1() is not visible </span></div><div class="line">		 * Alex1 alex1 = new Alex1();</div><div class="line">		 */</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">void</span> testStatic() {</div><div class="line">		Alex1 alex1 = Alex1.makeAlex1();</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">void</span> testSingleton() {</div><div class="line">		Alex2.access().f();</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>Alex1类和Alex2类展示了如何通过将所有的构造器指定为private来阻止直接创建某个类的实例。</p>
<p>但是现在别人该如何使用这个类呢？</p>
<p>上面的例子给出了两种选择：</p>
<ol>
<li>在Alex1中，创建一个static方法，该方法创建一个新的Alex1对象并返回一个对它的引用。如果想要在返回引用之前在Alex1上做一些额外的工作，或是如果想要记录到底创建了多少个Alex1对象，这种做法将会大有裨益。</li>
<li>Alex2用到了所谓的设计模式，这种特定的模式被称为singleton（单例），这是因为你始终只能创建它的一个对象。Alex2类的对象时作为Alex2的一个static private成员而创建的，所以有且仅有一个，而且除非调用public方法access()，否则是无法访问到它的。</li>
</ol>
<h2 id="域/变量访问权限">域/变量访问权限</h2>
<p>访问权限请看下面的表格，具体<a href="http://www.cnblogs.com/dolphin0520/p/3734915.html" target="_blank" rel="external">事例</a>不再赘述。<br><br></p>
<table>
<thead>
<tr>
<th style="text-align:center">范围</th>
<th style="text-align:center">private</th>
<th style="text-align:center">default</th>
<th style="text-align:center">protect</th>
<th style="text-align:center">public</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">在同一包的同一类</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">同一包的不同类</td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">不同包的子类</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">不同包的非子类</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[把数据和方法包装进类中，以及具体实现的隐藏，常共同被称作封装。]]>
    
    </summary>
    
      <category term="coding" scheme="http://alexyyek.github.io/tags/coding/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编译与解释]]></title>
    <link href="http://alexyyek.github.io/2015/01/08/CompileAndInterpreter/"/>
    <id>http://alexyyek.github.io/2015/01/08/CompileAndInterpreter/</id>
    <published>2015-01-08T14:20:56.000Z</published>
    <updated>2015-01-08T14:40:07.000Z</updated>
    <content type="html"><![CDATA[<p>很多文章和书籍习惯将高级编程语言分成编译型语言和解释型语言，其实这是有误导成分的，如果你从编程语言底层分析其运行过程，会发现编译与解释往往并不是独立存在的，下面分析理解其内部机理。</p>
<h2 id="解析器与解释器">解析器与解释器</h2>
<p>首先来明确两个基本概念：解析器是<a href="http://en.wikipedia.org/wiki/Parsing" target="_blank" rel="external">parser</a>，而解释器是<a href="http://en.wikipedia.org/wiki/Interpreter_computing" target="_blank" rel="external">interpreter</a>。两者不是同一样东西。</p>
<p><code>解析器</code>是编译器/解释器的重要组成部分，也可以用在IDE之类的地方；其主要作用是进行语法分析，提取出句子的结构。</p>
<p>广义来说输入一般是程序的源码，输出一般是<a href="http://en.wikipedia.org/wiki/Parse_tree" target="_blank" rel="external">语法树</a>（syntax tree，也叫parse tree等）或<a href="http://en.wikipedia.org/wiki/Abstract_syntax_tree" target="_blank" rel="external">抽象语法树</a>（abstract syntax tree，AST）。</p>
<p>广义的解析器里一般包含：</p>
<ol>
<li>扫描器（scanner，也叫tokenizer或者lexical analyzer，词法分析器）。扫描器的输入一般是文本，经过词法分析，输出是将文本切割为单词的流。</li>
<li>狭义的解析器（parser，也叫syntax analyzer，语法分析器）。狭义的解析器输入是单词的流，经过语法分析，输出是语法树或者精简过的AST。</li>
</ol>
<p>来看一段源码：$i = a + b * c$</p>
<p><center>　<img src="http://alexyoung.qiniudn.com/parser.png" alt=""> <center></center></center></p>
<p>其中词法分析由扫描器完成，语法分析由狭义的解析器完成。 </p>
<p><code>解释器</code>则是实现程序执行的一种实现方式，与<code>编译器</code>相对。它直接实现程序源码的语义，输入是程序源码，输出则是执行源码得到的计算结果；编译器的输入与解释器相同，而输出是用别的语言实现了输入源码的语义的程序。通常编译器的输入语言比输出语言高级，但不一定；也有输入输出是同种语言的情况，此时编译器很可能主要用于优化代码。 </p>
<p>把同样的源码分别输入到编译器与解释器中，得到的输出不同： </p>
<p><center> <img src="http://alexyoung.qiniudn.com/parser1.png" alt=""> <center></center></center></p>
<p>值得留意的是，编译器生成出来的代码执行后的结果应该跟解释器输出的结果一样——它们都应该实现源码所指定的语义。</p>
<h2 id="“编译器”与“编译型语言”">“编译器”与“编译型语言”</h2>
<p>一种高级编程语言，从源代码开始，一直到被执行生成相应的动作，大约经历了这几个步骤：</p>
<p><center> 源代码 ====&gt; 中间表示形式（e.g obj） ====&gt; 基本操作序列 ====&gt; 生成最终动作 <center></center></center></p>
<p>编译型语言的代表是C，源代码被编译之后生成中间文件（.o和.obj），然后用链接器和汇编器生成机器码，也就是一系列基本操作的序列，机器码最后被执行生成最终动作。编译生成了目标文件，而这个目标文件是针对特定的 CPU 体系的，为 ARM 生成的目标文件，不能被用于 MIPS 的 CPU。这段代码在编译过程中就已经被翻译成了目标 CPU 指令，所以，如果这个程序需要在另外一种 CPU 上面运行，这个代码就必须重新编译。</p>
<p>解释型的语言以Ruby为例，也经历了这些步骤，不同的是，C语言会把那些从源代码“变”来的基本操作序列（保存）起来，而Ruby直接将这些生成的基本操作序列（Ruby虚拟机）指令丢给Ruby虚拟机执行然后产生动作了。即解释型语言同样也可能存在某种编译过程，但他们编译生成的通常是一种『平台无关』的中间代码，这种代码一般不是针对特定的 CPU 平台，他们是在运行过程中才被翻译成目标 CPU 指令的，因而，在 ARM CPU 上能执行，换到 MIPS 也能执行，换到 X86 也能执行，不需要重新对源代码进行编译。</p>
<p>所以我们看到的现象是，编译型语言要先编译再运行，而解释性语言直接“运行”源代码。</p>
<p>换个角度说，采用编译和解释方式实现虚拟机最大的区别就在于是否存下目标代码：编译的话会把输入的源程序以某种单位（例如基本块/函数/方法/trace等）翻译生成为目标代码，并存下来（无论是存在内存中还是磁盘上，无所谓），后续执行可以复用之；解释的话则是把源程序中的指令逐条解释，不生成也不存下目标代码，后续执行没有多少可复用的信息。</p>
<h2 id="“解释器”与“解释型语言”">“解释器”与“解释型语言”</h2>
<p>很多资料会说，Python、Ruby、JavaScript都是“解释型语言”，是通过解释器来实现的。这么说其实很容易引起误解：<strong>语言一般只会定义其抽象语义，而不会强制性要求采用某种实现方式</strong>。</p>
<p>例如说C一般被认为是“编译型语言”，但C的解释器也是存在的，例如<a href="http://www.softintegration.com/" target="_blank" rel="external">Ch</a>。同样，C++也有解释器版本的实现，例如<a href="https://root.cern.ch/drupal/content/cint" target="_blank" rel="external">Cint</a>。 </p>
<p>一般被称为“解释型语言”的是主流实现为解释器的语言，但并不是说它就无法编译。例如说经常被认为是“解释型语言”的Scheme就有好几种编译器实现，其中率先支持R6RS规范的大部分内容的是Ikarus，支持在x86上编译Scheme；它最终不是生成某种虚拟机的字节码，而是直接生成x86机器码。 </p>
<p>解释器就是个黑箱，输入是源码，输出就是输入程序的执行结果，对用户来说中间没有独立的“编译”步骤。这非常抽象，内部是怎么实现的都没关系，只要能实现语义就行。你可以写一个C语言的解释器，里面只是先用普通的C编译器把源码编译为in-memory image，然后直接调用那个image去得到运行结果；用户拿过去，发现直接输入源码可以得到源程序对应的运行结果就满足需求了，无需在意解释器这个“黑箱子”里到底是什么。 </p>
<p>实际上很多解释器内部是以“编译器+虚拟机”的方式来实现的，先通过编译器将源码转换为AST或者字节码，然后由虚拟机去完成实际的执行。<strong>所谓“解释型语言”并不是不用编译，而只是不需要用户显式去使用编译器得到可执行代码而已</strong> 。</p>
]]></content>
    <summary type="html">
    <![CDATA[很多文章习惯将高级编程语言分成编译型语言和解释型语言，其实这是有误导成分的。语言一般只会定义其抽象语义，而不会强制性要求采用某种实现方式。]]>
    
    </summary>
    
      <category term="coding" scheme="http://alexyyek.github.io/tags/coding/"/>
    
      <category term="JVM" scheme="http://alexyyek.github.io/categories/JVM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[博客文章汇总目录]]></title>
    <link href="http://alexyyek.github.io/2015/01/06/sticky/"/>
    <id>http://alexyyek.github.io/2015/01/06/sticky/</id>
    <published>2015-01-06T12:00:49.000Z</published>
    <updated>2015-05-01T09:07:27.000Z</updated>
    <content type="html"><![CDATA[<p>为了方便大家更好的梳理本博客的资源，更快的检索自己需要的博文，现将文章涉及的知识来源作如下归类，以后发表新的教程也会在本置顶帖内<strong>同步更新</strong>，后期考虑将加入更多的博客以外的资源链接，欢迎关注AlexYoung’s blog，与我一同成长。</p>
<h2 id="Thinking_in_Java系列">Thinking in Java系列</h2>
<ul>
<li><p><a href="http://alexyyek.github.io/2014/12/29/wrapperClass/" target="_blank" rel="external"><strong>JAVA基本类型和包装类</strong></a></p>
</li>
<li><p><a href="http://alexyyek.github.io/2014/12/29/Reference/" target="_blank" rel="external"><strong>对象和引用</strong></a></p>
</li>
<li><p><a href="http://alexyyek.github.io/2015/01/03/initial/" target="_blank" rel="external"><strong>JAVA初始化</strong></a></p>
</li>
<li><p><a href="http://alexyyek.github.io/2015/01/12/Inherit/" target="_blank" rel="external"><strong>Java访问权限控制</strong></a></p>
</li>
<li><p><a href="http://alexyyek.github.io/2015/01/14/Reusing/" target="_blank" rel="external"><strong>Java复用类</strong></a></p>
</li>
<li><p><a href="http://alexyyek.github.io/2015/03/04/Polymorphism/" target="_blank" rel="external"><strong>Java多态性</strong></a></p>
</li>
<li><p><a href="http://alexyyek.github.io/2015/03/06/Interface/" target="_blank" rel="external"><strong>抽象类和接口</strong></a></p>
</li>
<li><p><a href="http://alexyyek.github.io/2015/04/06/Collection/" target="_blank" rel="external"><strong>JAVA容器类</strong></a></p>
</li>
<li><p><a href="http://alexyyek.github.io/2015/04/12/ArrayList/" target="_blank" rel="external"><strong>ArrayList</strong></a></p>
</li>
<li><p><a href="http://alexyyek.github.io/2015/05/01/LinkedList/" target="_blank" rel="external"><strong>LinkedList</strong></a></p>
</li>
</ul>
<h2 id="算法导论系列">算法导论系列</h2>
<ul>
<li><p><a href="http://alexyyek.github.io/2014/12/07/heap/" target="_blank" rel="external"><strong>堆排序</strong></a></p>
</li>
<li><p><a href="http://alexyyek.github.io/2014/12/07/lineSort/" target="_blank" rel="external"><strong>线性时间排序</strong></a></p>
</li>
<li><p><a href="http://alexyyek.github.io/2014/12/08/select/" target="_blank" rel="external"><strong>中位数和顺序统计学</strong></a></p>
</li>
<li><p><a href="http://alexyyek.github.io/2014/12/11/hash/" target="_blank" rel="external"><strong>散列函数</strong></a></p>
</li>
<li><p><a href="http://alexyyek.github.io/2014/12/14/hashCollapse/" target="_blank" rel="external"><strong>哈希碰撞附Hashtable源码分析</strong></a></p>
</li>
<li><p><a href="http://alexyyek.github.io/2014/12/17/BinaryTree/" target="_blank" rel="external"><strong>二叉查找树</strong></a></p>
</li>
<li><p><a href="http://alexyyek.github.io/2014/12/23/RBTree/" target="_blank" rel="external"><strong>红黑树</strong></a></p>
</li>
</ul>
<h2 id="黑科技系列">黑科技系列</h2>
<ul>
<li><p><a href="http://alexyyek.github.io/2014/12/27/ipv6/" target="_blank" rel="external"><strong>教育网配置IPV6回避收费及轻松翻墙</strong></a></p>
</li>
<li><p><a href="http://alexyyek.github.io/2014/12/31/GFW/" target="_blank" rel="external"><strong>GAE + goagent + switchysharp + chrome翻墙</strong></a></p>
</li>
</ul>
<h2 id="影评书评系列">影评书评系列</h2>
<ul>
<li><a href="http://alexyyek.github.io/2015/01/05/BeginAgain/" target="_blank" rel="external"><strong>歌曲改变人生</strong></a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[博客传送机，帮你快速定位所需教程，以后的文章也将在此帖同步更新，后期将不断加入博客外的优秀学习资源链接和下载地址。]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[歌曲改变人生]]></title>
    <link href="http://alexyyek.github.io/2015/01/05/BeginAgain/"/>
    <id>http://alexyyek.github.io/2015/01/05/BeginAgain/</id>
    <published>2015-01-05T07:42:31.000Z</published>
    <updated>2015-01-05T10:10:55.000Z</updated>
    <content type="html"><![CDATA[<p><center> <img src="http://alexyoung.qiniudn.com/c4b9d7a5547a66ef3613f5c52584ab6c.jpg" alt=""> <center></center></center></p>
<hr>
<p><br><br>当你结束一天疲惫的工作，回到家独自静静的蜷缩在被窝，为自己重复的人生轨迹默哀、麻木时， <a href="http://movie.douban.com/celebrity/1280127/" target="_blank" rel="external">John Carney</a>总会在在不经意间用一段总时长不到一百分钟，编剧毫无好莱坞大片般的起伏跌宕，甚至场景都略显的不怎么上心的普通故事，轻松的叩开你最深层的防备，让流淌的音乐代替所有的言语，灌进你缺少母爱的心灵。影片结束的一瞬间，你仿佛有千言万语，却也只是最后通通化作淡然的一笑。因为你已阅片无数，作为一个老观影人你能轻松解构评价这种类型的影片，但你只是迅速的登陆了BT账号搜索原声OST，在发现居然没有人上传后，忍痛连上一个月10G的校园网，开启虾米VIP默默的下载了Soundtrack，然后开启列表循环写下这些文字。</p>
<p>感觉跑题的观众姥爷不要在意，上面只是一个屌丝的故事而已。</p>
<p>2006年的<a href="http://movie.douban.com/subject/2053515/" target="_blank" rel="external">Once</a>，八年后<a href="http://movie.douban.com/subject/6874403/" target="_blank" rel="external">Begin Again</a>，这位爱尔兰出身的导演兼音乐人似乎永远有走不完的年少青春，无论岁月如何在所有人的身上静静流逝，只要音乐存在，他就永远是那个不变的他。你可以四十五度角仰望天空并用轻蔑的语气说从中仿佛看到了岛国中年大叔对某种低级情趣的执迷不悟，也可以低垂眼睑用修长的睫毛为之刻上男人至死都是少年的信念，或者干脆大声指责这根本就是一个音乐疯子才可能经历的故事，但不管你如何一本正经或是假装不屑，都已在这短短的一百分钟被烙上了John Carney的烙印，他用大街小巷随处可见的故事告诉你：这就是生活的美丽。</p>
<p>So，why not to be better?</p>
<p>影片中的场景缤纷多彩，无论是经典的酒吧，难得一见的录音棚，别出新意的帝国大厦楼顶、夜间的地下铁，还是随处可见的大街小巷，都在旋律的悦动中被激发出了不同以往的感觉，不需要花哨的演奏技巧，跟着演员们自然甚至略显生涩的演奏，很难保证自己的身体不随之而颤动。而更令人惊艳的便是女主角<a href="http://movie.douban.com/celebrity/1054448/" target="_blank" rel="external">Keira Knightley</a>在众多场景的不同着装，当你感觉真心不会有比这更好看更自然的搭配时，她就身着另一套不同的搭配出现在你的视野里，颠覆你的审美，刷新你的三观，告诉你做人flag不要立的太早。</p>
<p><center> <img src="http://alexyoung.qiniudn.com/BeginAgain2.jpg" alt=""> <center> </center></center></p>
<p>当然各路配角们同样的出彩，学院气质拉大小提琴的姐弟、嘻哈风格的黑人鼓手和贝斯手、看似古板实则为音乐而躁动的钢琴手，配上男主角的贝斯和女儿的吉他，相信你也会产生这才是音乐的共鸣。</p>
<p>为什么要推荐Begin Again这部电影呢，你或许会以为肯定是博主小清新爆棚，三观幼稚，性格中二，所以推荐了这样一部看人看风景听音乐的爱情电影。当然你这么想也无妨，毕竟看过才能体会。</p>
<p>那么除此以外呢，我想大概是因为它毫不掩饰的描述了人们追寻梦想的路径，但导演并没有把梦想悬空，更没有一点点对梦想的歌颂腔。男女主角遭遇了都市中的一切困窘与冷漠，物质上的贫困和精神上的挫败都是他们生活中的常态。他们处理着这些事务，但没有被琐碎打败。他们做着奔向梦想的事情，但绝没有到处声称自己是理想主义者以博得同情。更有意味的是，电影中和男女主角一起追梦的还有一群和他们同样的普通人。当他们的音乐被大唱片公司拒绝，他们就决定在纽约这座城市的各处独立录音。Gretta和Dan找来了街头卖艺的音乐人、黑人鼓手、心怀梦想但一直只能给学校舞蹈队伴奏的键盘演奏家，无论地铁站、帝国大厦的楼顶、大桥下、唐人街都成为了他们的露天录音棚。他们录下了音乐，也录下了这座城市的所有声响，从这个意义上讲，他们所做的不只是对音乐的追寻和完成一张唱片，而是真的融化进了纽约，或者说，把纽约融化进了自己的身体，呈现了这座城市以及生活在其中的人们的呼吸与脉动。做这些时，Gretta和Dan没有区隔哪些是梦想，哪些是生存，每一天，他们尽量快乐地活在当下，也尽最大努力接近梦想。 </p>
<p><center> <img src="http://alexyoung.qiniudn.com/BeginAgain4.jpg" alt=""> <center> </center></center></p>
<p><br><br>这部电影告诉我们，梦想从来都不是挂在嘴边炫耀的名词，它是个动词，你应该因它成为一个Doer，而不是一个Talker，更不是做一个自鸣得意沾沾自喜的Thinker，梦想从来都是因行动而伟大。</p>
<p>所以看到这里的少男少女们，燥起来吧，用心体会生活的美妙，追寻生命的意义，就像结尾男主角所唱的<a href="http://www.xiami.com/song/1773303359?spm=a1z1s.6626017.226669510.11.NXNvB1&amp;from=search_popup_song#wall_list" target="_blank" rel="external"><strong>Lost stars</strong></a>里最后一句：<strong>But are we all lost stars, trying to light up the dark?</strong></p>
<p><center> <img src="http://alexyoung.qiniudn.com/BeginAgain1.jpg" alt=""> <center><br><br></center></center></p>
<p>一百分钟的人生转瞬即逝，片尾回想起Gretta和Dan第一次见面时说的话</p>
<blockquote>
<p>Gretta：”This really is a bit of a long shot, isn’t it?”<br>Dan Mulligan：”Absolutely! That’s when the magic happens.”</p>
</blockquote>
<p>也许就是人生，你永远不知道你会成就什么，但仍然将为之而义无反顾。<br>多年后，偶然回想起那些依稀闪光的片段，这也许也正是人生美妙的地方。</p>
<p>PS. 喜欢电影的同学可以关注博主的豆瓣，博客这里将不定期更新推荐电影或不涉及剧透的影评，欢迎大家一起分享自己的观影体验。当然喜欢本博客的土豪们可以在首页进行支付宝赞助，所得赞助将全部用于博客图床扩容和域名购买。</p>
]]></content>
    <summary type="html">
    <![CDATA[Gretta："This really is a bit of a long shot, isn't it?" <br> Dan Mulligan："Absolutely! That's when the magic happens."]]>
    
    </summary>
    
      <category term="Movie" scheme="http://alexyyek.github.io/tags/Movie/"/>
    
      <category term="生活感悟" scheme="http://alexyyek.github.io/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JAVA初始化]]></title>
    <link href="http://alexyyek.github.io/2015/01/03/initial/"/>
    <id>http://alexyyek.github.io/2015/01/03/initial/</id>
    <published>2015-01-03T13:13:55.000Z</published>
    <updated>2015-01-04T11:22:57.000Z</updated>
    <content type="html"><![CDATA[<p>初始化和清理是涉及安全的两个问题，许多C程序的错误都源于忘记初始化变量，当使用完一个元素时，也很容易忘记清理它。C++引入了构造器的概念，这是一个在创建对象时被自动调用的特殊方法，Java中也采用了构造器，并额外提供了垃圾回收器，对于不再使用的内存资源，垃圾回收器能自动将其释放。</p>
<p>在Java中，通过提供构造器，类的设计者可确保每个对象都会得到初始化。创建对象时，如果类具有构造器，就会自动调用相应的构造器。</p>
<p>本文提纲源于Thingking in Java，但主体讲解内容在其上有更深入的探讨。我们首先明确一下this关键词在构造器中的作用，然后分析构造器的初始化流程。    </p>
<h2 id="this关键字">this关键字</h2>
<p>从本质上讲，<code>this</code>是一个指向对象的指针（引用）。通常写<code>this</code>的时候，都是指这个对象或当前对象。而在构造器中，如果为<code>this</code>添加参数列表，将产生对符合此参数列表的某个构造器的明确调用，从而可以直接调用其他构造器。</p>
<p>首先看一个<a href="http://stackoverflow.com/questions/3728062/what-is-the-meaning-of-this-in-java" target="_blank" rel="external">stackoverflow</a>上的例子：</p>
<figure class="highlight JAVA"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThisTest</span> </span>{</div><div class="line">		<span class="keyword">private</span> <span class="keyword">int</span> a;</div><div class="line"></div><div class="line">		<span class="keyword">public</span> <span class="title">MyThisTest</span>() {</div><div class="line">			<span class="keyword">this</span>(<span class="number">42</span>); <span class="comment">// calls the other constructor</span></div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">public</span> <span class="title">MyThisTest</span>(<span class="keyword">int</span> a) {</div><div class="line">			<span class="keyword">this</span>.a = a; <span class="comment">// assigns the value of the parameter a to the field of</span></div><div class="line">						<span class="comment">// the same name</span></div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">frobnicate</span>() {</div><div class="line">			<span class="keyword">int</span> a = <span class="number">1</span>;</div><div class="line"></div><div class="line">			System.out.println(a); <span class="comment">// refers to the local variable a</span></div><div class="line">			System.out.println(<span class="keyword">this</span>.a); <span class="comment">// refers to the field a</span></div><div class="line">			System.out.println(<span class="keyword">this</span>); <span class="comment">// refers to this entire object</span></div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">public</span> String <span class="title">toString</span>() {</div><div class="line">			<span class="keyword">return</span> <span class="string">"MyThisTest a="</span> + a; <span class="comment">// refers to the field a</span></div><div class="line">		}</div><div class="line">		</div><div class="line">		MyThisTest increment(){</div><div class="line">			a++;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">this</span>; <span class="comment">// refer to the reference of class MyThisTest</span></div><div class="line">		}</div><div class="line">	}</div></pre></td></tr></table></figure>

<p>从这个例子可以总结<code>this</code>的几种关键用法：</p>
<ol>
<li>区分同名变量：<code>this</code>关键字是类内部当中对自己的一个引用，可以方便类中方法访问自己的属性。成员变量与方法内部的变量重名时，希望在方法内部调用成员变量，如<code>this.a = a</code></li>
<li>返回类自身的引用，在<code>increment()</code>方法中通过<code>this</code>关键字返回了对当前对象的引用</li>
<li>在当前类的一个构造函数当中调用另一个构造函数，在无参构造器中通过<code>this(42)</code>调用构造器<code>MyThisTest(int a)</code><br><br></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">class Flower {</div><div class="line">		<span class="keyword">int</span> petals = <span class="number">0</span>;</div><div class="line">		String s = <span class="string">"initial value"</span>;</div><div class="line"></div><div class="line">		Flower() {</div><div class="line">			<span class="keyword">this</span>(<span class="string">"hello"</span>, <span class="number">5</span>);</div><div class="line">		}</div><div class="line"></div><div class="line">		Flower(<span class="keyword">int</span> petals) {</div><div class="line">			<span class="keyword">this</span>.petals = petals;</div><div class="line">		}</div><div class="line"></div><div class="line">		Flower(String s) {</div><div class="line">			<span class="keyword">this</span>.s = s;</div><div class="line">		}</div><div class="line"></div><div class="line">		Flower(String s, <span class="keyword">int</span> petals) {</div><div class="line">			<span class="keyword">this</span>(petals);</div><div class="line">			<span class="comment">/* Error : this(s);</span></div><div class="line">			 * Constructor call must be the first statement in a constructor */</div><div class="line">			<span class="keyword">this</span>.s = s;			</div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">void</span> print() {</div><div class="line">			<span class="comment">/* Error : this(s);</span></div><div class="line">			 * can not call the constructor in any method other than a constructor. */</div><div class="line">			System.out.println(<span class="keyword">this</span>.petals + <span class="string">" "</span> + s);</div><div class="line">		}</div><div class="line">	}</div></pre></td></tr></table></figure>

<p>上面的例子列出了一些要注意的使用情况：</p>
<ol>
<li>在构造方法中调用另一个构造方法，调用动作必须置于最起始的位置。</li>
<li>在一个构造方法内只能调用一个构造方法。</li>
<li>不能在构造方法以外的任何方法内调用构造方法。 </li>
</ol>
<h2 id="构造器初始化">构造器初始化</h2>
<h3 id="初始化顺序">初始化顺序</h3>
<ol>
<li>变量定义的先后顺序决定了初始化的顺序</li>
<li>但是不论变量定义在什么位置，都会在任何方法（包括构造器）被调用之前得到初始化</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class House{</div><div class="line">	Window window1 = <span class="keyword">new</span> Window(<span class="number">1</span>);</div><div class="line">	House(){</div><div class="line">		System.out.println(<span class="string">"In House"</span>);</div><div class="line">		window3 = <span class="keyword">new</span> Window(<span class="number">33</span>);</div><div class="line">	}</div><div class="line">	Window window2 = <span class="keyword">new</span> Window(<span class="number">2</span>);</div><div class="line">	<span class="keyword">void</span> f(){System.out.println(<span class="string">"f()"</span>);}</div><div class="line">	Window window3 = <span class="keyword">new</span> Window(<span class="number">3</span>);</div><div class="line">}</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExplicitStatic</span> </span>{</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){</div><div class="line">		House h = <span class="keyword">new</span> House();</div><div class="line">		h.f();</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在House类中，故意将几个Window对象的定义散布到各处，从而证明他们全部会在<strong>调用构造函器或其他方法之前</strong>得到初始化。此外window3在构造器内再次被初始化，第一次引用的对象将被丢弃，作为垃圾回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Windows:<span class="number">1</span></div><div class="line">Windows:<span class="number">2</span></div><div class="line">Windows:<span class="number">3</span></div><div class="line">In House</div><div class="line">Windows:<span class="number">33</span></div><div class="line">f()</div></pre></td></tr></table></figure>

<p><br></p>
<hr>
<h3 id="静态数据初始化">静态数据初始化</h3>
<p>无论创建多少个对象，静态数据都只占<strong>一份存储区域</strong>。静态数据初始化遵循以下原则：</p>
<ul>
<li>初始化的顺序是先静态对象，而后是非静态对象。</li>
<li>静态数据成员的初始化只有在必要时才会进行。<ol>
<li>创建类的对象             </li>
<li>引用类的静态数据成员</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">class Window{</div><div class="line">	Window(<span class="keyword">int</span> marker){</div><div class="line">		System.out.println(<span class="string">"Window:"</span> + marker);</div><div class="line">	}</div><div class="line">	<span class="keyword">void</span> f1(<span class="keyword">int</span> marker){</div><div class="line">		System.out.println(<span class="string">"f1():"</span> + marker);</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line">class House{</div><div class="line">	<span class="keyword">static</span> Window window1 = <span class="keyword">new</span> Window(<span class="number">1</span>);</div><div class="line">	House(){</div><div class="line">		System.out.println(<span class="string">"Table():"</span>);</div><div class="line">		window2.f1(<span class="number">1</span>);</div><div class="line">	}</div><div class="line">	<span class="keyword">void</span> f2(<span class="keyword">int</span> marker){</div><div class="line">		System.out.println(<span class="string">"f2():"</span> + marker);</div><div class="line">	}</div><div class="line">	<span class="keyword">static</span> Window window2 = <span class="keyword">new</span> Window(<span class="number">2</span>);</div><div class="line">}</div><div class="line"></div><div class="line">class People{</div><div class="line">	Window window3 = <span class="keyword">new</span> Window(<span class="number">3</span>);</div><div class="line">	<span class="keyword">static</span> Window window4 = <span class="keyword">new</span> Window(<span class="number">4</span>);</div><div class="line">	People(){</div><div class="line">		System.out.println(<span class="string">"People():"</span>);</div><div class="line">		window4.f1(<span class="number">2</span>);</div><div class="line">	}</div><div class="line">	<span class="keyword">void</span> f3(<span class="keyword">int</span> marker){</div><div class="line">		System.out.println(<span class="string">"f3():"</span> + marker);</div><div class="line">	}</div><div class="line">	<span class="keyword">static</span> Window window5 = <span class="keyword">new</span> Window(<span class="number">5</span>);</div><div class="line">}</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExplicitStatic</span> </span>{</div><div class="line">	<span class="keyword">static</span> House house = <span class="keyword">new</span> House();</div><div class="line">	<span class="keyword">static</span> People people = <span class="keyword">new</span> People();</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){</div><div class="line">		System.out.println(<span class="string">"Creating new House in main"</span>);</div><div class="line">		<span class="keyword">new</span> People();</div><div class="line">		System.out.println(<span class="string">"Creating new House in main"</span>);</div><div class="line">		<span class="keyword">new</span> People();</div><div class="line">		house.f2(<span class="number">1</span>);</div><div class="line">		people.f3(<span class="number">1</span>);</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<ol>
<li>要加载main()，必须加载ExplicitStatic类，然后其静态域house和people被初始化，这导致他们对应的类也被加载。类House内先初始化静态数据成员window1和window2，然后初始化构造器，调用类Window的f1()方法；类People内同理，注意先初始化静态成员，后非静态成员，所以顺序是4,5,3.</li>
<li>main函数中生成新的People对象，由于之前类People中静态成员加载过，故不再加载。</li>
</ol>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Window:<span class="number">1</span></div><div class="line">Window:<span class="number">2</span></div><div class="line">Table():</div><div class="line">f1():<span class="number">1</span></div><div class="line">Window:<span class="number">4</span></div><div class="line">Window:<span class="number">5</span></div><div class="line">Window:<span class="number">3</span></div><div class="line">People():</div><div class="line">f1():<span class="number">2</span></div><div class="line">Creating <span class="keyword">new</span> House in main</div><div class="line">Window:<span class="number">3</span></div><div class="line">People():</div><div class="line">f1():<span class="number">2</span></div><div class="line">Creating <span class="keyword">new</span> House in main</div><div class="line">Window:<span class="number">3</span></div><div class="line">People():</div><div class="line">f1():<span class="number">2</span></div><div class="line">f2():<span class="number">1</span></div><div class="line">f3():<span class="number">1</span></div></pre></td></tr></table></figure>


<p><br></p>
<hr>
<h3 id="显示的静态初始化">显示的静态初始化</h3>
<p>Java允许将多个静态初始化动作组织成一个特殊的“静态子句”（静态块）。与其他静态初始化动作一样，仅执行一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExplicitStatic</span> </span>{</div><div class="line">    <span class="comment">//  static Cups cup3 = new Cups();</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){</div><div class="line">		Cups.cup1.f(<span class="number">99</span>);</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line">class Cup{</div><div class="line">	Cup(<span class="keyword">int</span> marker){</div><div class="line">		System.out.println(<span class="string">"Cup:"</span> + marker);</div><div class="line">	}</div><div class="line">	<span class="keyword">void</span> f(<span class="keyword">int</span> marker){</div><div class="line">		System.out.println(<span class="string">"f:"</span> + marker);</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line">class Cups{</div><div class="line">	<span class="keyword">static</span> Cup cup1;</div><div class="line">	<span class="keyword">static</span> Cup cup2;</div><div class="line">	<span class="keyword">static</span>{                 <span class="comment">//静态块</span></div><div class="line">		cup1 = <span class="keyword">new</span> Cup(<span class="number">1</span>);</div><div class="line">		cup2 = <span class="keyword">new</span> Cup(<span class="number">2</span>);</div><div class="line">	}</div><div class="line">	Cups(){</div><div class="line">		System.out.println(<span class="string">"Cups"</span>);</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>程序访问Cups的静态成员cup1，类Cups初始化，首先初始化静态数据成员cup1、cup2，<strong>由于这里并没有生成类Cups的对象</strong>，所以类Cups的无参构造函数并不执行。<br>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Cup:<span class="number">1</span></div><div class="line">Cup:<span class="number">2</span></div><div class="line">f:<span class="number">99</span></div></pre></td></tr></table></figure>

<p>如果把main方法上面的cup3的注释去掉，那么由于生成了Cups类的对象，此时输出结果变成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Cup:<span class="number">1</span></div><div class="line">Cup:<span class="number">2</span></div><div class="line">Cups</div><div class="line">f:<span class="number">99</span></div></pre></td></tr></table></figure>

<p><strong>注意</strong>：如果类Cups里包含了非静态数据成员<code>Cup cup3 = new Cup();</code>，在执行main程序访问类Cups静态成员cup1时<code>Cups.cup1.f(99);</code>，也只会初始化静态成员cup1和cup2，输出结果不变。<br><br></p>
<hr>
<h3 id="非静态实例初始化">非静态实例初始化</h3>
<p>非静态初始化与静态初始化子句一模一样，只不过少了<code>static</code>关键字。这种语法对于支持“匿名内部类”的初始化时必须的，但是它也使得你可以保证无论调用了哪个显示构造器，某些操作都会发生。同时它不再具备静态对象初始化的优先级，所以可能先初始化构造器，后执行实例初始化。</p>
<p><br></p>
<h2 id="数组初始化">数组初始化</h2>
<p>Thinking in Java中数组初始化的问题讲的并不透彻，现在我们来深入一下对Java数组的认识。</p>
<h3 id="理解数组">理解数组</h3>
<p>数组也是一种数据类型，本身就是一种引用类型，我们从它的初始化方法，通过关键字new去完成定义及初始化就可以知道。</p>
<p>数组的长度是不变的，一旦数组完成初始化后，它的长度就固定下来了，在内存中占有的空间也就固定了，即使里面的数据被清空了，占有的空间还是保留下来了，依然是属于数组的，当然长度依旧是不变的。</p>
<p>数组里边存放的数据类型要一致，可以基本数据类型，也可以是引用数据类型，但是唯一的标准就是相同的类型。在Java中，类与类是支持继承关系的，所以就可能造成数组里面可以存在多中数据类型的假象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">class Animal {</div><div class="line">    <span class="keyword">public</span> String name;</div><div class="line">   </div><div class="line">    <span class="keyword">public</span> <span class="title">Animal</span>(String name) {</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    }</div><div class="line">}</div><div class="line">class Cat extends Animal {</div><div class="line">    <span class="keyword">public</span> <span class="title">Cat</span>(String name) {</div><div class="line">        <span class="keyword">super</span>(name);</div><div class="line">    }</div><div class="line">}</div><div class="line">class Dog extends Animal {</div><div class="line">    <span class="keyword">public</span> <span class="title">Dog</span>(String name) {</div><div class="line">        <span class="keyword">super</span>(name);</div><div class="line">    }</div><div class="line">}</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayDemo</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">        Animal[] animals = <span class="keyword">new</span> Animal[<span class="number">2</span>];</div><div class="line">        Cat cat = <span class="keyword">new</span> Cat(<span class="string">"little cat"</span>);</div><div class="line">        Dog dog = <span class="keyword">new</span> Dog(<span class="string">"little dog"</span>);</div><div class="line">        animals[<span class="number">0</span>] = cat;</div><div class="line">        animals[<span class="number">1</span>] = dog;</div><div class="line">        System.out.println(animals[<span class="number">0</span>].name);</div><div class="line">        System.out.println(animals[<span class="number">1</span>].name);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这样看上去，好像数组里面存放了Cat类型和Dog类型，但是实际上他们都是Animal类型，数组里面都是相同的类型，请大家不要搞混淆了。</p>
<h3 id="定义数组和初始化数组">定义数组和初始化数组</h3>
<p>定义数组的语法格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">type[] arrayName;</div><div class="line">type arrayName[];</div></pre></td></tr></table></figure>

<p>无论是Thinking in Java还是我个人都推荐第一种方式，直观的告诉别人定义了一个type类型数组，而不是type类型变量。</p>
<p>初始化数组：</p>
<p>$1$. 静态初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arrayName = <span class="keyword">new</span> type[]{element1,element2, element3......};</div></pre></td></tr></table></figure>

<p>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> [] int_arr_1 = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>};</div><div class="line">Integer arr = {<span class="keyword">new</span> Integer(<span class="number">1</span>), <span class="keyword">new</span> Integer(<span class="number">2</span>), <span class="number">3</span>}; <span class="comment">// JAVA基本类型和包装类探讨过的*自动装箱功能*</span></div></pre></td></tr></table></figure>

<p>$2$. 动态初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arrayName = <span class="keyword">new</span> type[length];</div></pre></td></tr></table></figure>

<p>当然不同的数据类型，系统分配的初始值不同。<br><br></p>
<table>
<thead>
<tr>
<th style="text-align:center">基本类型</th>
<th style="text-align:center">初始值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">整数类型（byte、short、int、long）</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">浮点类型（float、double）</td>
<td style="text-align:center">0.0</td>
</tr>
<tr>
<td style="text-align:center">字符类型（char）</td>
<td style="text-align:center">‘\u0000’（代表空格）</td>
</tr>
<tr>
<td style="text-align:center">布尔类型（boolean）</td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td style="text-align:center">引用类型（类、接口、数组）</td>
<td style="text-align:center">null</td>
</tr>
</tbody>
</table>
<h3 id="内存中的数组">内存中的数组</h3>
<p>们让一个引用变量指向另外一个实际的数组的时候，可能产生数组长度可变的假象，大家来看看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayDemo3</span> </span>{</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">        </div><div class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[]{<span class="number">1</span>, <span class="number">2</span>};</div><div class="line">        <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</div><div class="line">        System.out.println(<span class="string">"length of b:"</span> + b.length);</div><div class="line">        </div><div class="line">        b = a;</div><div class="line">        System.out.println(<span class="string">"length of b:"</span> + b.length);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>结果：b数组的长度好像发生了变化，但是实际上不是这样的，我们来分析一下内存中的变化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">length of b:<span class="number">4</span></div><div class="line">length of b:<span class="number">2</span></div></pre></td></tr></table></figure>

<p>如果你不能明确的理解Java中对象和引用以及参数传递的本质，建议你首先看一下<a href="http://alexyyek.github.io/2014/12/29/Reference/" target="_blank" rel="external">之前的博客</a>。</p>
<p>上面的程序中：</p>
<ol>
<li>在堆中创建数组对象{1,2}，占用两个长度，并在堆栈中创建引用a指向堆中数组{1,2}的首地址。</li>
<li>在堆中开辟长度为4的数组空间，初始化为{0,0,0,0}；然后在堆栈中创建引用b指向堆中数组{0,0,0,0}的首地址。</li>
<li>将引用a指向的地址副本传递给引用b，故引用b不再指向{0,0,0,0}，而是指向引用a所指的{1,2}</li>
</ol>
<p><strong>总结</strong>：我们所说的<strong>数组的长度不变是针对堆内存中真正数组的长度</strong>，引用变量是可以改变指向的，指到哪里肯定就显示指到的数组的长度了，但是真正的长度是不曾改变的。</p>
<h2 id="可变参数列表">可变参数列表</h2>
<h3 id="基本使用">基本使用</h3>
<p>当调用方法时，方法的参数个数或类型未知时，称其为可变参数列表。可变长参数列表是Java 5中的一个新特性。如果方法需要传入多个同类型参数的话，这个功能就非常有用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArrays</span>(Object[] args ){</div><div class="line">        <span class="keyword">for</span> (Object arg : args)</div><div class="line">            System.out.println( arg );</div><div class="line">}</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){</div><div class="line">		printArrays(<span class="keyword">new</span> Object[]{<span class="keyword">new</span> Integer(<span class="number">25</span>),<span class="keyword">new</span> Float(<span class="number">3.1415</span>),<span class="keyword">new</span> Character(<span class="string">'a'</span>), <span class="keyword">new</span> String(<span class="string">"shit"</span>)});</div><div class="line">		printArrays(<span class="keyword">new</span> Object[]{<span class="keyword">new</span> A(),<span class="keyword">new</span> A(),<span class="keyword">new</span> A()});</div><div class="line">}</div></pre></td></tr></table></figure>

<p>由于所有的类都直接或间接继承于Object类，所以可以创建以Object数组为参数的方法并如上调用。然而Java 5增加了对可变参数的支持，现在你可以用下面的方法更简洁的调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class A{}</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArrays</span>(Object... args ){</div><div class="line">        <span class="keyword">for</span> (Object arg : args)</div><div class="line">            System.out.println( arg );</div><div class="line">}</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){</div><div class="line">		printArrays(<span class="number">3</span>,<span class="number">3.547</span>,<span class="number">3.456</span>f,<span class="string">"Alex"</span>,<span class="keyword">new</span> A(),<span class="keyword">new</span> Date(),<span class="string">"string"</span>+<span class="number">50</span>);</div><div class="line">		printArrays((Object[])<span class="keyword">new</span> Integer[]{<span class="number">1</span>,<span class="number">2</span>,<span class="number">32</span>,<span class="number">4</span>});</div><div class="line">}</div></pre></td></tr></table></figure>

<p>注意main程序最后一行，Integer数组传递给了printArrays()，因为它已经是一个数组，所以不再进行转换。<br>因此，如果你有一组事物，可以把它们当做列表传递；而如果你已经有了一个数组，该方法可以把其当做可变参数列表来接受。</p>
<h3 id="使用规范">使用规范</h3>
<p>$1$. 一个方法只能有一个可变长参数，并且这个可变长参数必须是该方法的最后一个参数   </p>
<p>正确体位：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> printArrays(String arg, String...args){</div><div class="line">		System.out.println(arg);</div><div class="line">		<span class="keyword">for</span>(Object obj : args){</div><div class="line">			System.out.print(obj + <span class="string">"\t"</span>);</div><div class="line">		}</div><div class="line">	}</div></pre></td></tr></table></figure>

<p>$2$. 你应该总是只在重载方法的一个版本上使用可变参数列表，或者压根就不用丫。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> printArrays(String... args){</div><div class="line">		<span class="keyword">for</span>(Object obj : args){</div><div class="line">			System.out.print(obj + <span class="string">"\t"</span>);</div><div class="line">		}</div><div class="line">		System.out.println();</div><div class="line">	}</div><div class="line">	<span class="keyword">static</span> <span class="keyword">void</span> printArrays(String arg, String...args){</div><div class="line">		System.out.println(arg);</div><div class="line">		<span class="keyword">for</span>(Object obj : args){</div><div class="line">			System.out.print(obj + <span class="string">"\t"</span>);</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){</div><div class="line">	<span class="comment">/*  Compile Error</span></div><div class="line">	 *  printArrays("what","the","fuck");*/</div><div class="line">}</div></pre></td></tr></table></figure>

<p>此时编译器无法知道你到底是要调用哪个方法，因为两个方法看起来都可以。除非你为这两个方法都添加一个非可变参数。</p>
<p>$3$. 别让null值和空值威胁到变长方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> func(Integer...args){}</div><div class="line">	</div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> func(String...args){}</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){</div><div class="line">            func(<span class="number">0</span>);</div><div class="line">		    func(<span class="string">"Alex"</span>);</div><div class="line">		    func(); <span class="comment">//Compile Error</span></div><div class="line">		    </div><div class="line">		    String word = <span class="keyword">null</span>;</div><div class="line">	    	func(word); <span class="comment">//That's OK</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>在每一种情况，编译器都会使用<a href="http://alexyyek.github.io/2014/12/29/wrapperClass/" target="_blank" rel="external">自动包装</a>机制来匹配重载的方法，然后调用最明确的匹配方法。但是调用<code>f()</code>时，编译器不知道应该调用哪个方法，可以通过第10、11行的修改编译通过。</p>
<p>最后来个简单的测试，看看你是否还清醒：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span>(String arg, String... args) {</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) {</div><div class="line">            System.out.println(args[i]);</div><div class="line">        }</div><div class="line">    }</div><div class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){   </div><div class="line">            f(<span class="string">""</span>);</div><div class="line">               f(<span class="string">"aaa"</span>);</div><div class="line">               f(<span class="string">"aaa"</span>, <span class="string">"bbb"</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这是看到的一个<a href="http://java-performance.info/java-varargs-performance-issues/" target="_blank" rel="external">英文版讲解</a></p>
]]></content>
    <summary type="html">
    <![CDATA[Java采用构造器的概念（在创建对象时被自动调用的特殊方法），并额外提供垃圾回收器，来确保避免不安全的编程方式，本节主要讨论初始化的相关问题。]]>
    
    </summary>
    
      <category term="coding" scheme="http://alexyyek.github.io/tags/coding/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[写在2014边上]]></title>
    <link href="http://alexyyek.github.io/2014/12/31/2014/"/>
    <id>http://alexyyek.github.io/2014/12/31/2014/</id>
    <published>2014-12-31T13:46:08.000Z</published>
    <updated>2014-12-31T15:55:18.000Z</updated>
    <content type="html"><![CDATA[<h2 id="2014总结">2014总结</h2>
<p>2014年对我来说是过得非常快的一年，这种快不是由于过于重复单调而产生的那种令人忘却的快，而是因为在这一年我遇见了很多有趣的人，走遍了很多有趣的地方，激发了很多想要列上Todo List的想法，也更加坚定了自己前进的方向后，那种突然将未来的所有可能性放在眼前让人应接不暇的快。</p>
<h3 id="实习">实习</h3>
<p>2013年研究生刚刚入学，十一月份便跑去参加了百度的实习面试，现在回想起来当初其实并不是非常想要实习，只是想试试自己能不能获得某种程度的认可。一共面了两家公司，搜狗和百度，搜狗的面试让我充分意识到了机器学习中人工标注和预处理的重要性，但并不是非常符合我的预期，所以委婉拒绝了搜狗的实习。第二天面百度，两轮下来就两个小时没了，虽然有的问题没有回答上来，但给出了基本的思路和尝试方法，一周内便接到了入职的电话。</p>
<p>一实习便是半年，从最初的很多东西都不懂，通过不断的请教各位大神，自己查资料想解决办法，到能独立的完成每天的Job，再开始略加指导新来的同事，这半年见证了我的成长。当然实习有利有弊，在获得实习能力提升的时候，往往很难顾及实验室的工作，这是我比较遗憾的地方，人的精力还是有限的，需要合理分配。</p>
<p>这里想说一下百度给我个人的印象，也方便想去实习的同学有个参考吧。首先百度的公司氛围非常好，有很浓厚的技术气息，因为基本上都是三十岁以下的年轻人，讨论或者咨询问题都非常舒服，可以充分开发你的脑洞，提出不同的想法和思路。其次百度的作息时间也比较合理，早上十点上班，下午六点下班，周末放假。最后也是最幸福的一点便是每个季度都可以免费向公司买书，这对于实习生有莫大的价值。</p>
<h3 id="生活">生活</h3>
<p>五月末辞了实习，便和妹子去杭州玩了一趟，至于为什么选择杭州，当然是有阿里的成分在里面，相比帝都的房价和雾霾，我可能更偏向选择较为舒适的南方城市。</p>
<p>杭州的景色并没有辜负我的期望，想去游玩的同学不要错过，土豪记得带上你们的单反，出片率高到飞起。杭州的美食也非常可口，虽然饮食口味偏于清淡，但灵活多变的美食做法也不会让你厌倦。</p>
<p>唯一可惜的就是阿里上市了，就这么在我还没毕业之前上市了…</p>
<h3 id="感悟">感悟</h3>
<p>常常和别人谈论到一个很土的话题，成功与失败。</p>
<p>聪明的人告诉我你应该理性分析，合理投资，回避风险，最大化收益。话并没有错，但如果你是一个程序猿，请听下面的建议：</p>
<p>我觉得你应该尝试经历失败。</p>
<p>常常让我感触比较深的是在学习一种新的技术时，明明有网上的教程指导，但还是出现了各种奇怪的问题，按理说不应该发生的问题。于是我不断的寻找解决方案，对比不同的解决方法，分析他们的原理，最后选择合适的方案继续下一步，然后再遇到突发问题，再解决掉，如此不断反复，总算是亦趋亦步的走了过来。</p>
<p>然后回头再看那个教程，你应该会有这样一种感觉，我可以针对你这个教程专门再写一个教程来纠正和补充你，并且解释其中的原理。并且无论以后面试中问到这方面的问题，还是实际工作中遇到这方面的问题，我相信都能理性的分析，并快速定位问题源头，最终合理的解决。</p>
<p>而如果我当初按照那个教程傻傻的一遍成功了，可能我并不会了解这么深。</p>
<p>所以想说的本质其实就是一句话：<strong>一定要重视理解的深度。</strong></p>
<p>我相信这便是人与人的区别。</p>
<h2 id="2015_Todo_List">2015 Todo List</h2>
<ul>
<li>一两个拿得出手的项目</li>
<li>实习经验，创业公司为先，有项目可参与</li>
<li>刷面试书籍 </li>
<li>学习一门动态语言</li>
<li>论文中稿，求过！！！ </li>
<li>五月去内蒙古</li>
<li>拿到理想中的offer好养活妹纸</li>
</ul>
<p>最后祝大家元旦快乐~单身狗早日脱单，找到想要的实习和工作~~<br>请接收我最真诚的祝福。</p>
]]></content>
    <summary type="html">
    <![CDATA[You do what you love, and fuck the rest.]]>
    
    </summary>
    
      <category term="life" scheme="http://alexyyek.github.io/tags/life/"/>
    
      <category term="生活感悟" scheme="http://alexyyek.github.io/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[免费且使用便捷的翻墙方案]]></title>
    <link href="http://alexyyek.github.io/2014/12/31/GFW/"/>
    <id>http://alexyyek.github.io/2014/12/31/GFW/</id>
    <published>2014-12-31T09:55:42.000Z</published>
    <updated>2014-12-31T10:52:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="目录">目录</h2>
<p>翻墙方法多如牛毛，但都因为自身的因素而各有利弊。Freegate使用简单，适合初学者，但开启后访问国内网站将出现问题；VPN有的收费有的免费，免费的VPN由于使用者众多网速low的一比，收费的能够提供更好的服务，但需要为之买单。而且从技术角度分析VPN加密流程会发现：你的机子-&gt;(加密)-&gt;VPN-&gt;(解密后的)-&gt;访问目标机子，就算你的机子和VPN之间怎么加密，在最终发给目标机子都会还原成没加密的。这并不是吓唬大家，只是万事有利有弊，自行取舍罢了。而上一篇<a href="http://alexyyek.github.io/2014/12/27/ipv6/" target="_blank" rel="external">改Hosts</a>的办法虽然简单，但能翻的网站有限，而且需要不断更新。</p>
<p>下面推荐的是一种基于GAE（Google App Engine）+ goagent + switchysharp + chrome的翻墙之法，相对刚才介绍的方案，此方法上手较易，使用体验也非常不错（当你配置完后便能充分的感受到），并且完全免费。所以请不要害怕这过长的篇幅，按部就班10分钟左右搞定。</p>
<p>那么让我们一起迎接2015这新世界吧。</p>
<p><center> <img src="http://alexyoung.qiniudn.com/464564.jpg" alt=""> <center><br><br></center></center></p>
<hr>
<h3 id="入门介绍">入门介绍</h3>
<ol>
<li>GAE（Google App Engine）是一个开发、托管网络应用程序的平台；</li>
<li>goagent是一个使用Python和Google Appengine SDK编写的代理软件；</li>
<li>switch sharp是一个chrome插件，具体功能类似于Firefox的AutoProxy.</li>
</ol>
<h3 id="申请Google_App_Engine并创建app">申请Google App Engine并创建app</h3>
<ul>
<li>首先去注册一个google账户，没有绑定手机号码的建议<a href="https://security.google.com/settings/security/signinoptions/rescuephone" target="_blank" rel="external">绑定</a>。</li>
<li>创建属于你的<a href="https://appengine.google.com/start/createapp" target="_blank" rel="external"><strong>Application</strong></a>，填写你的APP ID，</li>
</ul>
<p><strong>错误体位</strong>：</p>
<p><center> <img src="http://alexyoung.qiniudn.com/GAE1.png" alt=""> <center></center></center></p>
<p><strong>正确体位</strong></p>
<p><center> <img src="http://alexyoung.qiniudn.com/GAE2.png" alt=""> <center></center></center></p>
<p><strong>填写方式</strong></p>
<p><center> <img src="http://alexyoung.qiniudn.com/GAE3.png" alt=""> <center></center></center></p>
<ul>
<li>一切正常的话就会看到下面的界面（告诉你App已经申请成功了）<br><center> <img src="http://alexyoung.qiniudn.com/GAE4.png" alt=""> <center></center></center></li>
</ul>
<p><br><br><strong>注意</strong>：GAE的check不一定可靠，可能出现提示available但是commit后提示<code>This application ID or version is already in use</code>的情况，所以请另换ID。现在每个用户可以创建25个APP，每个应用每天有1GB的免费流量。如果你经常下载或者观看视频建议多创建几个Google App Engine应用。<br><br></p>
<hr>
<h3 id="下载_goagent_并上传至_Google_App_Engine">下载 goagent 并上传至 Google App Engine</h3>
<ul>
<li>去Github下载 <a href="https://github.com/goagent/goagent" target="_blank" rel="external"><strong>goagent客户端</strong></a> 并解压，目前是3.2.3版</li>
<li>修改<code>\local\proxy.ini</code>，把其中 appid = goagent 中的 goagent 改成你之前申请的应用的 appid 后保存。<br><center> <img src="http://alexyoung.qiniudn.com/GFW9.jpg" alt=""> <center></center></center></li>
</ul>
<p>如果要使用多个appid，appid之间用<code>|</code>隔开，如：<code>appid1|appid2|appid3</code>，每个 appid 必须确认上传成功才能使用</p>
<blockquote>
<p>[gae]<br>appid = appid1|appid2|appid3</p>
</blockquote>
<ul>
<li>双击 server 文件夹下的 uploader.bat， 依次输入你的Application ID，邮箱地址和密码（如果设置了Gmail的两步验证请输入两步验证中生成的16位密码，即为独立应用单独生成的随机16位字符，而不是你的邮箱密码，Gmail两步验证在这里<a href="http://www.cooear.com/archives/168.htm" target="_blank" rel="external">详细介绍</a>）<br><center> <img src="http://alexyoung.qiniudn.com/GFW10.jpg" alt=""> <center></center></center></li>
</ul>
<p><br></p>
<ul>
<li>看到下面的提示便上传成功。<br><center> <img src="http://alexyoung.qiniudn.com/GFW6.jpg" alt=""> <center></center></center></li>
</ul>
<p><strong>注意</strong>：如果输完账户密码后出现：<code>AttributeError: can’t set attribute</code> 的问题，可尝试进入 <a href="https://www.google.com/settings/security" target="_blank" rel="external"><strong>Google 安全性</strong></a> 页面里看到了『帐户所授权限』 中的『不够安全的应用的访问权限』，进入设置之后，点击『启用』即可。<br><br></p>
<hr>
<h3 id="Chrome下安装Switchysharp">Chrome下安装Switchysharp</h3>
<ul>
<li>去chrome的<a href="https://chrome.google.com/webstore/category/home" target="_blank" rel="external">应用商店</a>安装Switchysharp</li>
<li><p>下载好后Switchysharp图标会出现在chrome的右上角，点击选项<br><center> <img src="http://alexyoung.qiniudn.com/GFW11.jpg" alt=""> <center></center></center></p>
</li>
<li><p>在导入/导出界面，选择从文件恢复，选中<code>\local\SwitchyOptions.bak</code>确认导入<br><center> <img src="http://alexyoung.qiniudn.com/GFW8.jpg" alt=""> <center></center></center></p>
</li>
<li><p>成功导入后，想去外网时选择自动切换模式即可，不访问时便选择直接连接<br><center> <img src="http://alexyoung.qiniudn.com/GFW12.jpg" alt=""> <center></center></center></p>
</li>
</ul>
<p><strong>注意</strong>：使用Firefox浏览器和opera浏览器的同学去<a href="https://github.com/goagent/goagent/blob/wiki/InstallGuide.md" target="_blank" rel="external"><strong>这里</strong></a>看配置插件教程。<br><br></p>
<hr>
<h3 id="最后">最后</h3>
<p>恭喜你已经成功配置好了插件，想去外网时记得先打开<code>local\goagent.exe</code>，最好管理员权限打开，如果嫌每次都打开麻烦，设置开机自动启动也OK，浏览器会根据你浏览的具体界面选择代理方式，一键都不用便可翻墙，这便是此方案便捷的地方。</p>
<p>有兴趣的同学可以研究研究<a href="http://shadowsocks.cn/" target="_blank" rel="external">ShadowSocks</a>，ShadowSocks服务器端提供了各种版本，如Python、Nodejs、Go、C libev等等，安装配置过程极其简单。而用户端则可以在windows、mac、iOS和android上轻松运行。首先，当然你需要有一个shadowsocks账号。(￣∇￣;)</p>
]]></content>
    <summary type="html">
    <![CDATA[不要问我为什么翻墙，因为墙就在那里。]]>
    
    </summary>
    
      <category term="skill" scheme="http://alexyyek.github.io/tags/skill/"/>
    
      <category term="黑科技" scheme="http://alexyyek.github.io/categories/%E9%BB%91%E7%A7%91%E6%8A%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[对象和引用]]></title>
    <link href="http://alexyyek.github.io/2014/12/29/Reference/"/>
    <id>http://alexyyek.github.io/2014/12/29/Reference/</id>
    <published>2014-12-29T13:43:15.000Z</published>
    <updated>2014-12-30T13:08:38.000Z</updated>
    <content type="html"><![CDATA[<p>Java中对象和引用的东西之前看了不少，但一方面因为网上知识过于繁杂，不能很好的梳理，另一方面不同的博客讲解专业程度不一样，可能会导致一定的误解。此篇博客争取以最精炼，最具条理的方式理清其中的难点和疑点。</p>
<h2 id="对象和引用">对象和引用</h2>
<h3 id="对象">对象</h3>
<blockquote>
<p>《Java编程思想》：按照通俗的说法，每个对象都是某个类（class）的一个实例（instance），这里，‘类’就是‘类型’的同义词。</p>
</blockquote>
<p><strong>理解本质</strong>：对象是类的实例。例如<a href="http://ww2.sinaimg.cn/bmiddle/53539f83jw1emh2fiopjtj20u01hc4qp.jpg" target="_blank" rel="external">Alex</a>是人类，Alex是对象，就是“人类”的实例。对象一般存储在堆中。</p>
<h3 id="引用">引用</h3>
<blockquote>
<p>《Java编程思想》： 每种编程语言都有自己的数据处理方式。有些时候，程序员必须注意将要处理的数据是什么类型。你是直接操纵元素，还是用某种基于特殊语法的间接表示（例如C/C++里的指针）来操作对象。所有这些在 Java 里都得到了简化，一切都被视为对象。因此，我们可采用一种统一的语法。尽管将一切都“看作”对象，但操纵的标识符实际是指向一个对象的“引用”（reference）。</p>
</blockquote>
<p><strong>理解本质</strong>：引用是指向对象的标识符。可以理解对象是一个个气球，我们通过引用这条绳子和它链接。引用存储在速度更快的堆栈中。 </p>
<h3 id="实例讲解">实例讲解</h3>
<p>首先看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>{</div><div class="line">	String name;</div><div class="line">	String sex;</div><div class="line">	<span class="keyword">int</span> age;</div><div class="line">	</div><div class="line">	<span class="comment">//构造函数</span></div><div class="line">	<span class="keyword">public</span> <span class="title">People</span>(){</div><div class="line">	</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="title">People</span>(String name, String sex, <span class="keyword">int</span> age){</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">		<span class="keyword">this</span>.sex = sex;</div><div class="line">		<span class="keyword">this</span>.age = age;</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>people是一个类，包含属性 name、sex、age，有了这个类，我们创建对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">People one = <span class="keyword">new</span> People();</div></pre></td></tr></table></figure>

<p>这条语句的动作称为创建一个对象，它包含了四个动作:</p>
<ol>
<li>右边的new People，是以Pelple类为模板，在堆空间中创建一个People类对象</li>
<li>结尾的()，在对象创建后，立刻调用People类的构造函数，对刚生成的对象初始化。这个例子中包含了构造函数，如果没写，java会自动帮你补上。</li>
<li>左侧的People one创建了一个People类的引用变量。即one是指向People对象的引用。</li>
<li>“=”操作符使对象引用<strong>指向</strong>刚创建的People对象。注意是指向，不是赋值。</li>
</ol>
<p>可以将上面的话拆成两句，效果一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">People one;</div><div class="line">one = <span class="keyword">new</span> People();</div></pre></td></tr></table></figure>

<p>如果只执行了第一条语句，还没执行第二条，此时创建的引用变量one还没指向任何一个对象，它的值是null。引用变量可以指向某个对象，或者为null。然后看下面这段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">People two;</div><div class="line">two = one;</div></pre></td></tr></table></figure>

<p>首先又创建了一个引用two，此时two指向null，第二句将one指向的地址传给two，发生了复制行为，注意这里复制的是<code>对象引用</code>，此时two也指向one所指的对象，具体如何传递后面会讲。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">two = <span class="keyword">new</span> People();</div></pre></td></tr></table></figure>

<p>这句将two指向了一个新的对象，所以可以分析如下两条性质：</p>
<ol>
<li>一个引用可以指向0个或1个对象（一根绳子可以不系汽球，也可以系一个汽球）；</li>
<li>一个对象可以有N个引用指向它（可以有N条绳子系住一个汽球）。 </li>
</ol>
<p>如果发生这样的情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">People one = <span class="keyword">new</span> People(<span class="string">"张三"</span>);</div><div class="line">People two = <span class="keyword">new</span> People(<span class="string">"李四"</span>);</div><div class="line">one = two;</div></pre></td></tr></table></figure>

<p>按上面的逻辑，引用one先指向对象“张三”，然后又指向了引用two指向的“李四”，所以最后one和two都指向对象“李四”，问题是之前的对象“张三”呢？还在堆里么？</p>
<p>多数书里说，它被Java的垃圾回收机制回收了。这不确切。</p>
<blockquote>
<p>正确地说，它已成为垃圾回收机制的处理对象。至于什么时候真正被回收，那要看垃圾回收机制的心情了。 </p>
</blockquote>
<p><br></p>
<hr>
<h3 id="参数传递">参数传递</h3>
<p>参数传递是个大坑，面试时常常会被问及，但其实并不难，看透本质即可。</p>
<blockquote>
<p>《thinking in Java》：When you’re passing primitives into a method，you get a distinct copy of the primitive. When you’re passing a reference into a method, you get a copy of the reference.</p>
</blockquote>
<p><strong>本质</strong>：不管JAVA参数类型是什么，一律传递参数的<strong><code>副本</code></strong></p>
<p><br></p>
<h4 id="例一">例一</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){</div><div class="line">		<span class="keyword">boolean</span> test = <span class="keyword">true</span>;</div><div class="line">		System.out.println(<span class="string">"before test() :"</span> + test);</div><div class="line">		test(test);</div><div class="line">		System.out.println(<span class="string">"after test() :"</span> + test);</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span>(<span class="keyword">boolean</span> test){</div><div class="line">		test = !test;</div><div class="line">		System.out.println(<span class="string">"In test() :"</span> + test);</div><div class="line">	}</div></pre></td></tr></table></figure>

<p><strong>分析</strong>：首先声明一个基本类型为boolean的对象true，并用test指向它，在函数test内，引用test将值的副本传递进去，所以原本的test不改变，在test内输出false，而after test仍然还是true。<br><strong>注意</strong>：基本类型传值的副本，对象变量传引用的副本<br><br></p>
<h4 id="例二">例二</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){</div><div class="line">		StringBuffer string = <span class="keyword">new</span> StringBuffer(<span class="string">"Hello"</span>);</div><div class="line">		test(string);</div><div class="line">		System.out.println(string);</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span>(StringBuffer str){</div><div class="line">		str.append(<span class="string">",world!"</span>);</div><div class="line">	}</div></pre></td></tr></table></figure>

<p><strong>分析</strong>：首先声明一个stringbuffer类型的对象型变量，string指向对象Hello，在test内将string的引用副本传给str，因此string和str都在栈内指向同一个堆地址，只不过所处栈地址不同。test内改变了str指向的对象，因此string指向的对象也改变了，变成Hello,world!.<br><br></p>
<h4 id="例三">例三</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">class value{</div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> i = <span class="number">15</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">dataType</span> </span>{</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){</div><div class="line">		dataType type = <span class="keyword">new</span> dataType();</div><div class="line">		type.first();</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span>(){</div><div class="line">		<span class="keyword">int</span> i = <span class="number">5</span>;</div><div class="line">		value v = <span class="keyword">new</span> value();</div><div class="line">		v.i = <span class="number">25</span>;</div><div class="line">		second(v, i);</div><div class="line">		System.out.println(v.i);</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">second</span>(value v, <span class="keyword">int</span> i){</div><div class="line">		i = <span class="number">0</span>;</div><div class="line">		v.i = <span class="number">20</span>;</div><div class="line">		value val = <span class="keyword">new</span> value();</div><div class="line">		v = val;</div><div class="line">		System.out.println(v.i + <span class="string">" "</span> + i);</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<ol>
<li><p>在first内，首先程序在栈内存中开辟了一块地址编号为AD9500内存空间，用于存放<code>v</code>的引用地址，里边放的值是堆内存中的一个地址，示例中的值为BE2500<br><center> <img src="http://alexyoung.qiniudn.com/QQ图片20141229225902.png" alt=""> <center></center></center></p>
</li>
<li><p>调用函数second，程序在栈内开辟地址为AD9600内存空间存放v的副本，v的副本同样指向堆地址为BE2500的空间，然后将v的副本传入second，并且在second内，将v的副本所指对象<code>i=25</code>改为<code>i=20</code><br><center> <img src="http://alexyoung.qiniudn.com/QQ图片20141229225924.png" alt=""> <center></center></center></p>
</li>
<li><p>在second内，程序新建一个对象放在地址为BE2600的堆内，并用新的引用val（栈中地址为AD9700）指向它，所以second中输出结果为：15 0<br><center> <img src="http://alexyoung.qiniudn.com/QQ图片20141229225934.png" alt=""> <center></center></center></p>
</li>
<li><p>但原v并未改变，改变的只是它传入second的副本，所以在first中仍然输出<code>i=20</code><br><br></p>
</li>
</ol>
<hr>
<p><strong>PS</strong>：在JAVA里，“=”不能被看成是一个赋值语句，它不是在把一个对象赋给另外一个对象，它的执行过程实质上是将右边对象的地址传给了左边的引用，使得左边的引用指向了右边的对象。JAVA表面上看起来没有指针，但它的引用其实质就是一个指针，引用里面存放的并不是对象，而是该对象的地址，使得该引用指向了对象。在JAVA里，“=”语句不应该被翻译成赋值语句，因为它所执行的确实不是一个赋值的过程，而是一个传地址的过程，被译成赋值语句会造成很多误解，译得不准确。 </p>
]]></content>
    <summary type="html">
    <![CDATA[When you're passing primitives into a method，you get a distinct copy of the primitive. When you're passing a reference into a method, you get a copy of the reference.]]>
    
    </summary>
    
      <category term="coding" scheme="http://alexyyek.github.io/tags/coding/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JAVA基本类型和包装类]]></title>
    <link href="http://alexyyek.github.io/2014/12/29/wrapperClass/"/>
    <id>http://alexyyek.github.io/2014/12/29/wrapperClass/</id>
    <published>2014-12-29T09:03:38.000Z</published>
    <updated>2014-12-29T14:20:05.000Z</updated>
    <content type="html"><![CDATA[<h2 id="JAVA的包装类">JAVA的包装类</h2>
<p>Java语言是一个面向对象的语言，但是Java中的基本数据类型却是不面向对象的，这在实际使用时存在很多的不便，为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表，这样八个和基本数据类型对应的类统称为包装类(Wrapper Class)，有些地方也翻译为外覆类或数据类型类，如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">基本类型</th>
<th style="text-align:center">大小</th>
<th style="text-align:center">包装器类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">boolean</td>
<td style="text-align:center">/</td>
<td style="text-align:center">Boolean</td>
</tr>
<tr>
<td style="text-align:center">char</td>
<td style="text-align:center">16bit</td>
<td style="text-align:center">Character</td>
</tr>
<tr>
<td style="text-align:center">byte</td>
<td style="text-align:center">8bit</td>
<td style="text-align:center">Byte</td>
</tr>
<tr>
<td style="text-align:center">short</td>
<td style="text-align:center">16bit</td>
<td style="text-align:center">Short</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">32bit</td>
<td style="text-align:center">Integer</td>
</tr>
<tr>
<td style="text-align:center">long</td>
<td style="text-align:center">64bit</td>
<td style="text-align:center">Long</td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">32bit</td>
<td style="text-align:center">Float</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">64bit</td>
<td style="text-align:center">Double</td>
</tr>
<tr>
<td style="text-align:center">void</td>
<td style="text-align:center">/</td>
<td style="text-align:center">Void</td>
</tr>
</tbody>
</table>
<p>Java中的包装器类有两个主要的目的： </p>
<ol>
<li>提供一种机制，将基本值“包装”到对象中，从而使基本值能够包含在为对象而保留的操作中，比如添加到Collections 中，或者从带对象返回值的方法中返回。注意，java5增加了自动装箱和拆箱，程序员过去需手工执行的许多包装操作，现在可以由java自动处理了。 </li>
<li>为基本值提供分类功能。这些功能大多数于各种转换有关：在基本值和String对象间相互转换，在基本值和String对象之间按不同基数转换，如二进制、八进制和十六进制。 </li>
</ol>
<h3 id="包装类共同的方法">包装类共同的方法</h3>
<ul>
<li>带有<code>基本值参数</code>并创建包装类对象的构造函数。如利用Integer包装类创建对象，Integer obj=new Integer(145);</li>
<li>带有<code>字符串参数</code>并创建包装类对象的构造函数.如：new Integer(“-45.36”);</li>
<li>可生成对象基本值的<code>typeValue</code>方法，如：obj.intValue();</li>
<li>将字符串转换为基本值的<code>parseType</code>方法，如：Integer.parseInt(args[0]);</li>
<li>生成哈稀表代码的<code>hashCode</code>方法，如：obj.hasCode();</li>
<li>对同一个类的两个对象进行比较的<code>equals()</code>方法，如：obj1.eauqls(obj2);</li>
<li>生成字符串表示法的<code>toString()</code>方法，如：obj.toString().<br><br></li>
</ul>
<hr>
<h3 id="装箱和拆箱">装箱和拆箱</h3>
<p>自动装箱和拆箱问题是Java中一个老生常谈的问题了，今天就来一些看一下装箱和拆箱中的若干问题。本文先讲述装箱和拆箱最基本的东西，再来看一下面试笔试中经常遇到的与装箱、拆箱相关的问题。<br><br></p>
<h4 id="定义">定义</h4>
<p>在前面的文章中提到，Java为每种基本数据类型都提供了对应的包装器类型，至于为什么会为每种基本数据类型提供包装器类型在此不进行阐述，有兴趣的朋友可以查阅相关资料。在Java SE5之前，如果要生成一个数值为10的Integer对象，必须这样进行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">100</span>);</div></pre></td></tr></table></figure>

<p>而在从Java SE5开始就提供了自动装箱的特性，如果要生成一个数值为10的Integer对象，只需要这样就可以了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">100</span>;</div></pre></td></tr></table></figure>

<p>这个过程中会自动根据数值创建对应的 Integer对象，这就是装箱。<br>那什么是拆箱呢？顾名思义，跟装箱对应，就是自动将包装器类型转换为基本数据类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Integer i = <span class="number">10</span>; <span class="comment">//装箱</span></div><div class="line"><span class="keyword">int</span> index = i;  <span class="comment">//拆箱</span></div></pre></td></tr></table></figure>

<p>简单一点说，装箱就是自动将基本数据类型转换为包装器类型；拆箱就是自动将包装器类型转换为基本数据类型。</p>
<p>注意：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Integer test = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">int</span> f = test.intValue();</div></pre></td></tr></table></figure>

<p>上面的代码编写时不会报错，但编译是通不过的。<br><br></p>
<h4 id="实现机制">实现机制</h4>
<p>我们就以Interger类为例，下面看一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){</div><div class="line">    Integer i = <span class="number">10</span>; <span class="comment">//装箱</span></div><div class="line">    <span class="keyword">int</span> index = i;  <span class="comment">//拆箱</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>反编译class文件之后得到如下内容：</p>
<p><center> <img src="http://alexyoung.qiniudn.com/101641567956500.jpg" alt=""> <center></center></center></p>
<p>从反编译得到的字节码内容可以看出，在装箱的时候自动调用的是Integer的<code>valueOf(int)</code>方法。而在拆箱的时候自动调用的是Integer的<code>intValue</code>方法。</p>
<p>其他的也类似，比如Double、Character，不相信的朋友可以自己手动尝试一下。</p>
<p>因此可以用一句话总结装箱和拆箱的实现过程：</p>
<p><strong>装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的xxxValue方法实现的。（xxx代表对应的基本数据类型）。</strong></p>
<p><br></p>
<hr>
<p><br></p>
<h4 id="面试问题">面试问题</h4>
<p>虽然大多数人对装箱和拆箱的概念都清楚，但是在面试和笔试中遇到了与装箱和拆箱的问题却不一定会答得上来。下面列举一些常见的与装箱/拆箱有关的面试题，建议先自己尝试编译看源码做做。</p>
<ul>
<li>下面这段代码的输出结果是什么？</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">        Integer i1 = <span class="number">100</span>;</div><div class="line">        Integer i2 = <span class="number">100</span>;</div><div class="line">        Integer i3 = <span class="number">200</span>;</div><div class="line">        Integer i4 = <span class="number">200</span>;</div><div class="line">        </div><div class="line">        System.out.println(i1==i2);</div><div class="line">        System.out.println(i3==i4);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>也许有些朋友会说都会输出false，或者也有朋友会说都会输出true。这里注意“==”和“equal”的区别：<br><br></p>
<table>
<thead>
<tr>
<th style="text-align:center">基本类型</th>
<th style="text-align:center">==</th>
<th style="text-align:center">equals</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">字符串变量</td>
<td style="text-align:center">对象在内存中的首地址</td>
<td style="text-align:center">字符串内容</td>
</tr>
<tr>
<td style="text-align:center">非字符串变量</td>
<td style="text-align:center">对象在内存中的首地址</td>
<td style="text-align:center">对象在内存中的首地址</td>
</tr>
<tr>
<td style="text-align:center">基本类型</td>
<td style="text-align:center">值</td>
<td style="text-align:center">不可用</td>
</tr>
<tr>
<td style="text-align:center">包装类</td>
<td style="text-align:center">地址</td>
<td style="text-align:center">内容</td>
</tr>
</tbody>
</table>
<p>结果：<br>true<br>false</p>
<p>为什么会出现这样的结果？输出结果表明 i1 和 i2 指向的是同一个对象，而 i3 和 i4 指向的是不同的对象。此时只需一看源码便知究竟，下面这段代码是Integer的<code>valueOf</code>方法的具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span>(<span class="keyword">int</span> i) {</div><div class="line">        <span class="keyword">if</span>(i &gt;= -<span class="number">128</span> && i &lt;= IntegerCache.high)</div><div class="line">            <span class="keyword">return</span> IntegerCache.cache[i + <span class="number">128</span>];</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</div><div class="line">    }</div></pre></td></tr></table></figure>

<p>从这2段代码可以看出，在通过valueOf方法创建Integer对象的时候，如果数值在 [-128,127] 之间，便返回指向IntegerCache.cache中已经存在的对象的引用；否则创建一个新的Integer对象。</p>
<p>上面的代码中 i1 和 i2 的数值为100，因此会直接从cache中取已经存在的对象，所以 i1 和 i2 指向的是同一个对象，而 i3 和 i4 则是分别指向不同的对象。</p>
<ul>
<li>下面这段代码的输出结果是什么？</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">        Double i1 = <span class="number">100.0</span>;</div><div class="line">        Double i2 = <span class="number">100.0</span>;</div><div class="line">        Double i3 = <span class="number">200.0</span>;</div><div class="line">        Double i4 = <span class="number">200.0</span>;</div><div class="line">        </div><div class="line">        System.out.println(i1==i2);</div><div class="line">        System.out.println(i3==i4);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>也许有的朋友会认为跟上面一道题目的输出结果相同，但是事实上却不是。实际输出结果为：<br>false<br>false<br>至于具体为什么，读者可以去查看Double类的<code>valueOf</code>的实现。</p>
<p>在这里只解释一下为什么Double类的valueOf方法会采用与Integer类的valueOf方法不同的实现。很简单：在某个范围内的整型数值的个数是有限的，而浮点数却不是。</p>
<p>注意，Integer、Short、Byte、Character、Long这几个类的valueOf方法的实现是类似的，Double、Float的valueOf方法的实现是类似的。</p>
<ul>
<li>下面这段代码的输出结果是什么？</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">        Boolean i1 = <span class="keyword">false</span>;</div><div class="line">        Boolean i2 = <span class="keyword">false</span>;</div><div class="line">        Boolean i3 = <span class="keyword">true</span>;</div><div class="line">        Boolean i4 = <span class="keyword">true</span>;</div><div class="line">         </div><div class="line">        System.out.println(i1==i2);</div><div class="line">        System.out.println(i3==i4);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>输出结果为：<br>true<br>true<br>至于为什么是这个结果，同样地，看了Boolean类的源码也会一目了然。下面是Boolean的valueOf方法的具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span>(<span class="keyword">boolean</span> b) {</div><div class="line">        <span class="keyword">return</span> (b ? TRUE : FALSE);</div><div class="line">    }</div></pre></td></tr></table></figure>

<p>至于TRUE和FALSE的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="javadoc">/**</span></div><div class="line">     * The {@code Boolean} object corresponding to the primitive</div><div class="line">     * value {@code true}.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean TRUE = <span class="keyword">new</span> Boolean(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    <span class="javadoc">/**</span></div><div class="line">     * The {@code Boolean} object corresponding to the primitive</div><div class="line">     * value {@code false}.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean FALSE = <span class="keyword">new</span> Boolean(<span class="keyword">false</span>);</div></pre></td></tr></table></figure>

<ul>
<li>谈谈Integer i = new Integer(xxx)和Integer i =xxx;这两种方式的区别。<br>当然，这个题目属于比较宽泛类型的。但是要点一定要答上，我总结一下主要有以下这两点区别：</li>
</ul>
<p>1）第一种方式不会触发自动装箱的过程；而第二种方式会触发；</p>
<p>2）在执行效率和资源占用上的区别。第二种方式的执行效率和资源占用在一般性情况下要优于第一种情况（注意这并不是绝对的）。</p>
<ul>
<li>下面这段代码的输出结果是什么？</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">        Integer a = <span class="number">1</span>;</div><div class="line">        Integer b = <span class="number">2</span>;</div><div class="line">        Integer c = <span class="number">3</span>;</div><div class="line">        Integer d = <span class="number">3</span>;</div><div class="line">        Integer e = <span class="number">321</span>;</div><div class="line">        Integer f = <span class="number">321</span>;</div><div class="line">        Long g = <span class="number">3</span>L;</div><div class="line">        Long h = <span class="number">2</span>L;</div><div class="line">         </div><div class="line">        System.out.println(c==d);</div><div class="line">        System.out.println(e==f);</div><div class="line">        System.out.println(c==(a+b));</div><div class="line">        System.out.println(c.equals(a+b));</div><div class="line">        System.out.println(g==(a+b));</div><div class="line">        System.out.println(g.equals(a+b));</div><div class="line">        System.out.println(g.equals(a+h));</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>先别看输出结果，读者自己想一下这段代码的输出结果是什么。这里面需要注意的是：当 “==” 运算符的两个操作数都是 包装器类型的引用，则是比较指向的是否是同一个对象，而如果其中有一个操作数是表达式（即包含算术运算）则比较的是数值（即会触发自动拆箱的过程）。另外，对于包装器类型，equals方法并不会进行类型转换。明白了这2点之后，上面的输出结果便一目了然：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">true</span></div><div class="line"><span class="keyword">false</span></div><div class="line"><span class="keyword">true</span></div><div class="line"><span class="keyword">true</span></div><div class="line"><span class="keyword">true</span></div><div class="line"><span class="keyword">false</span></div><div class="line"><span class="keyword">true</span></div></pre></td></tr></table></figure>

<p>第一个和第二个输出结果没有什么疑问。第三句由于  a+b 包含了算术运算，因此会触发自动拆箱过程（会调用intValue方法），因此它们比较的是数值是否相等。而对于c.equals(a+b)会先触发自动拆箱过程，再触发自动装箱过程，也就是说a+b，会先各自调用intValue方法，得到了加法运算后的数值之后，便调用Integer.valueOf方法，再进行equals比较。同理对于后面的也是这样，不过要注意倒数第二个和最后一个输出的结果（如果数值是int类型的，装箱过程调用的是Integer.valueOf；如果是long类型的，装箱调用的Long.valueOf方法）。</p>
]]></content>
    <summary type="html">
    <![CDATA[Java语言是一个面向对象的语言，但是Java中的基本数据类型却是不面向对象的，为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表，统称为包装类(Wrapper Class).]]>
    
    </summary>
    
      <category term="coding" scheme="http://alexyyek.github.io/tags/coding/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[教育网配置IPV6回避收费及轻松翻墙]]></title>
    <link href="http://alexyyek.github.io/2014/12/27/ipv6/"/>
    <id>http://alexyyek.github.io/2014/12/27/ipv6/</id>
    <published>2014-12-27T09:06:18.000Z</published>
    <updated>2014-12-30T02:20:08.000Z</updated>
    <content type="html"><![CDATA[<p>明光村职业技术学院终于还是没能逃离收费的命运，虽然还有半年就卷铺盖跑路了，但面对每个月只给10G外网流量，100块都不给我的抠门政策，废话不多说，直接上干货。</p>
<h2 id="目录">目录</h2>
<h3 id="设置IPV6">设置IPV6</h3>
<ul>
<li>首先安装ipv6，这个是基础，win7默认安装，xp运行命令<code>ipv6 install</code>。访问网站 <a href="http://6rank.edu.cn/" target="_blank" rel="external">http://6rank.edu.cn</a> 看看IPv6配置是否正常。更详细介绍请自行百度。</li>
<li>打开网络和共享中心 → 更改适配器设置 → 本地连接 → 属性 → 双击Internet协议版本6（IPV6），设置首选DNS服务器为：<strong>2001:778::37</strong></li>
</ul>
<p><center> <img src="http://alexyoung.qiniudn.com/QQ图片20141227164226.jpg" alt=""> <center></center></center></p>
<p><a href="http://ipv6.lt/nat64_en.php" target="_blank" rel="external"><strong>原理</strong></a>：NAT64服务器，能将所有ipv4的网站都转化对应的ipv6地址，也相当于一种代理。晚上速度比较受影响，日间科研完全可以满足。</p>
<p><center> <img src="http://alexyoung.qiniudn.com/graph_relay.png" alt=""> <center></center></center></p>
<ul>
<li>将Internet协议版本4（IPV4）前的对勾去掉，确定后退出，即可只通过IPV6访问网站，不用登陆 <a href="http://10.3.8.211/" target="_blank" rel="external">http://10.3.8.211/</a>，此时流量不计入已使用流量</li>
</ul>
<h3 id="设置hosts翻墙">设置hosts翻墙</h3>
<p>如果你是通过代理访问 <a href="https://www.youtube.com/" target="_blank" rel="external">youtube</a>，往往速度很不给力。如果是教育网有ipv6的话，那就好办了，看1080P流畅的一比，而且是教育网使用ipv6是不计费的。方法很简单，就是修改hosts.</p>
<ul>
<li><p>访问 <a href="http://serve.netsh.org/pub/ipv6-hosts/" target="_blank" rel="external"><strong>网站</strong></a>，勾选你所要的服务，如下图，点击立刻获取。<br><center> <img src="http://alexyoung.qiniudn.com/QQ图片20141227165359.jpg" alt=""> <center></center></center></p>
</li>
<li><p>将生成的hosts文件内容贴到你的hosts文件里并保存：<code>C:\Windows\System32\drivers\etc</code></p>
</li>
<li>最后总是以<strong>HTTPS</strong>的方式打开Youtube、facebook，如：<a href="https://www.youtube.com/" target="_blank" rel="external">https://www.youtube.com/</a>，<a href="https://www.facebook.com/" target="_blank" rel="external">https://www.facebook.com/</a><br>如果嫌麻烦，可以 <a href="http://blog.netsh.org/posts/chrome-http-redirect-https_369.netsh.html" target="_blank" rel="external"><strong>点这里</strong></a> 设置chrome强制http定向到https</li>
</ul>
<p>PS.如果某天发生访问不了例如youtube的情况，是因为ipv6地址会经常失效，也可能是地址变更，或者河蟹出现，记得更新hosts。<br>访问youtube看1080P无压力</p>
<p><img src="http://alexyoung.qiniudn.com/QQ图片20141227161806.jpg" alt=""></p>
<p><a href="https://code.google.com/p/ipv6-hosts/" target="_blank" rel="external">https://code.google.com/p/ipv6-hosts/</a></p>
<p><strong>PS</strong>：本方法只是临时解决方案，目的是培养大家合理利用搜索引擎，解决实际问题的意识，欢迎大家提出不同的改进意见和更完善的解决方案。</p>
]]></content>
    <summary type="html">
    <![CDATA[IPV6谁用谁知道]]>
    
    </summary>
    
      <category term="skill" scheme="http://alexyyek.github.io/tags/skill/"/>
    
      <category term="黑科技" scheme="http://alexyyek.github.io/categories/%E9%BB%91%E7%A7%91%E6%8A%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[红黑树]]></title>
    <link href="http://alexyyek.github.io/2014/12/23/RBTree/"/>
    <id>http://alexyyek.github.io/2014/12/23/RBTree/</id>
    <published>2014-12-23T08:13:09.000Z</published>
    <updated>2014-12-25T08:13:10.000Z</updated>
    <content type="html"><![CDATA[<h2 id="红黑树">红黑树</h2>
<p>红黑树(Red-Black Tree，简称R-B Tree)，它一种特殊的二叉查找树。<br>红黑树是特殊的二叉查找树，意味着它满足二叉查找树的特征：任意一个节点所包含的键值，大于等于左孩子的键值，小于等于右孩子的键值。<br>除了具备该特性之外，红黑树还包括许多额外的信息。</p>
<h3 id="性质">性质</h3>
<p>红黑树的每个节点上都有存储位表示节点的颜色，颜色是红(Red)或黑(Black)。<br>红黑树的特性:</p>
<ol>
<li>每个节点或者是黑色，或者是红色。</li>
<li>根节点是黑色。</li>
<li>每个叶子节点是黑色。 [注意：这里叶子节点，是指为空的叶子节点！]</li>
<li>如果一个节点是红色的，则它的子节点必须是黑色的。</li>
<li>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</li>
</ol>
<p>关于它的特性，需要注意的是：<br>第一，特性(3)中的叶子节点，是只为空(NIL或null)的节点。<br>第二，特性(5)，确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树。</p>
<p>红黑树结构图类似：</p>
<p><center> <img src="http://alexyoung.qiniudn.com/8394323_13013004048ddW.jpg" alt=""> <center><br><br></center></center></p>
<hr>
<h3 id="基本操作">基本操作</h3>
<p>从某个结点x出发（不包括该结点）到达一个叶节点的任意一条路径上，黑色结点的个数成为该结点x的黑高度，用<code>bh(x)</code>表示。根据性质5黑高度概念是明确定义的，红黑树的黑高度定义为其根节点的黑高度。</p>
<p><strong>性质</strong>：一颗有n个内结点的红黑树的高度至多为<code>2lg(n+1)</code>，红黑树的插入和删除操作都可以在<code>O(lgn)</code>时间内完成。<br><br></p>
<h4 id="旋转">旋转</h4>
<p>红黑树的旋转分为左旋和右旋，因为在插入和删除基本操作中可能改变树的结构，从而破坏红黑树的基本性质，所以需要一定的旋转操作。</p>
<p><center> <img src="http://alexyoung.qiniudn.com/251733282013849.jpg" alt=""> <center></center></center></p>
<p>从图上可以看到，左旋操作中将Y节点顶替其父节点X，之前的父节点X成为Y的左子树，Y的右子树不动，Y的左子树移到X的右子树</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">leftRotate</span>(Node&lt;T&gt; x){</div><div class="line">		<span class="comment">//consider the left child of y</span></div><div class="line">		Node&lt;T&gt; y = x.right;</div><div class="line">		x.right = y.left;</div><div class="line">		<span class="keyword">if</span> (y.left != <span class="keyword">null</span>) {</div><div class="line">			y.left.parent = x;</div><div class="line">		}</div><div class="line">		<span class="comment">//consider the node y</span></div><div class="line">		y.parent = x.parent;</div><div class="line">		<span class="keyword">if</span> (x.parent == <span class="keyword">null</span>) {</div><div class="line">			root = y;</div><div class="line">		}<span class="keyword">else</span>{</div><div class="line">			<span class="keyword">if</span>(x == x.parent.left)</div><div class="line">			x.parent.left = y;</div><div class="line">			<span class="keyword">else</span> </div><div class="line">			x.parent.right = y;</div><div class="line">		}</div><div class="line">		<span class="comment">//consider the Node x</span></div><div class="line">		y.left = x;</div><div class="line">		x.parent = y;</div><div class="line">	}</div></pre></td></tr></table></figure>

<p>右旋同理，是左旋的逆操作：</p>
<p><center> <img src="http://alexyoung.qiniudn.com/251735527958942.jpg" alt=""> <center></center></center></p>
<p><br></p>
<hr>
<p><br></p>
<h4 id="插入">插入</h4>
<p>将一个节点插入到红黑树中，需要执行哪些步骤呢？首先，将红黑树当作一颗二叉查找树，将节点插入；然后，将节点着色为红色；最后，通过”旋转和重新着色”等一系列操作来修正该树，使之重新成为一颗红黑树。详细描述如下：<br><strong>第一步</strong>： 将红黑树当作一颗二叉查找树，将节点插入。<br>红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。此外，无论是左旋还是右旋，若旋转之前这棵树是二叉查找树，旋转之后它一定还是二叉查找树。这也就意味着，任何的旋转和重新着色操作，都不会改变它仍然是一颗二叉查找树的事实。</p>
<p><strong>第二步</strong>：将插入的节点着色为”红色”。<br>为什么着色成红色，而不是黑色呢？为什么呢？在回答之前，我们需要重新温习一下红黑树的特性：<br>(1) 每个节点或者是黑色，或者是红色。<br>(2) 根节点是黑色。<br>(3) 每个叶子节点是黑色。 注意：这里叶子节点，是指为空的叶子节点！<br>(4) 如果一个节点是红色的，则它的子节点必须是黑色的。<br>(5) 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</p>
<p>将插入的节点着色为红色，不会违背”特性(5)”！少违背一条特性，就意味着我们需要处理的情况越少。接下来，就要努力的让这棵树满足其它性质即可；满足了的话，它就又是一颗红黑树了。</p>
<p><strong>第三步</strong>：通过一系列的旋转或着色等操作，使之重新成为一颗红黑树。<br>    第二步中，将插入节点着色为”红色”之后，不会违背”特性(5)”。那它到底会违背哪些特性呢？<br>    对于”特性(1)”，显然不会违背了。因为我们已经将它涂成红色了。<br>    对于”特性(2)”，唯一可能违背的情况是插入的节点为根节点。<br>    对于”特性(3)”，显然不会违背了。这里的叶子节点是指的空叶子节点，插入非空节点并不会对它们造成影响。<br>    对于”特性(4)”，如果插入节点的父节点是红色的，就有可能违背！<br>    那接下来，想办法使之”满足特性”，就可以将树重新构造成红黑树了。</p>
<p>插入操作代码见最后的完整代码，下面主要研究插入后的修正操作：</p>
<ul>
<li>修复情况1：当前结点的父结点是红色，祖父结点的另一个子结点（叔叔结点）是红色。</li>
</ul>
<p><center> <img src="http://alexyoung.qiniudn.com/Red-black_tree_insert_case_3.png" alt=""> <center></center></center></p>
<p>父节点和叔叔节点都是RED，则祖父节点肯定存在，且为BLACK，改变祖父节点、父节点和叔叔节点的颜色，将N上移到祖父节点继续迭代。</p>
<ul>
<li>修复情况2：当前节点的父节点是红色,叔叔节点是黑色，当前节点是其父节点的右孩子</li>
</ul>
<p><center> <img src="http://alexyoung.qiniudn.com/Red-black_tree_insert_case_4.png" alt=""> <center></center></center></p>
<p>此时当前节点的父节点做为新的当前节点，以新当前节点为支点左旋。</p>
<ul>
<li>插入修复情况3：当前节点的父节点是红色,叔叔节点是黑色，当前节点是其父节点的左孩子</li>
</ul>
<p><center> <img src="http://alexyoung.qiniudn.com/Red-black_tree_insert_case_5.png" alt=""> <center></center></center></p>
<p>情况2通过一个左旋转变成情况三，因为节点N和父节点P都是红色的，所以旋转不影响数的黑高度。情况三中改变一些节点颜色，然后通过一个右旋解决。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertFixUp</span>(Node&lt;T&gt; node){</div><div class="line">		<span class="comment">//	若父节点存在，并且父节点的颜色是红色</span></div><div class="line">		<span class="keyword">while</span>(node.parent != <span class="keyword">null</span> && isRed(node.parent)) {</div><div class="line">			<span class="comment">// 若父节点”是“祖父节点的左孩子</span></div><div class="line">			<span class="keyword">if</span> (parentOf(node) == parentOf(parentOf(node)).left) {</div><div class="line">				Node&lt;T&gt; uncle = parentOf(parentOf(node)).right;	 <span class="comment">//叔叔节点，即父节点的兄弟节点</span></div><div class="line">				<span class="comment">//情况一：如果叔叔节点是红色，因为父节点是红色，显然祖父节点是黑色</span></div><div class="line">				<span class="keyword">if</span> (isRed(uncle)) {									</div><div class="line">					parentOf(node).color = BLACK;</div><div class="line">					uncle.color = BLACK;</div><div class="line">					parentOf(parentOf(node)).color = RED;</div><div class="line">					node = parentOf(parentOf(node));</div><div class="line">				}</div><div class="line">				<span class="keyword">else</span> {	</div><div class="line">					<span class="keyword">if</span> (parentOf(node).right == node) {	<span class="comment">//情况二：叔叔节点是黑色，而Z是右孩子</span></div><div class="line">						 node = parentOf(node);</div><div class="line">						 leftRotate(node);</div><div class="line">					}</div><div class="line">					</div><div class="line">					parentOf(node).color = BLACK;	<span class="comment">//情况三：叔叔节点黑色，Z是左孩子</span></div><div class="line">					parentOf(parentOf(node)).color = RED;</div><div class="line">					rightRotate(parentOf(parentOf(node)));</div><div class="line">				}</div><div class="line">			}</div><div class="line">			<span class="comment">// 若父节点”是“祖父节点的右孩子</span></div><div class="line">			<span class="keyword">else</span> {</div><div class="line">				Node&lt;T&gt; uncle = parentOf(parentOf(node)).left;</div><div class="line">				<span class="keyword">if</span> (isRed(uncle)) {</div><div class="line">					parentOf(node).color = BLACK;</div><div class="line">					uncle.color = BLACK;</div><div class="line">					parentOf(parentOf(node)).color = RED;</div><div class="line">					node = parentOf(parentOf(node));</div><div class="line">				}</div><div class="line">				<span class="keyword">else</span> {</div><div class="line">					<span class="keyword">if</span> (parentOf(node).left == node) {</div><div class="line">						 node = parentOf(node);</div><div class="line">						 rightRotate(node);</div><div class="line">					}</div><div class="line">					parentOf(node).color = BLACK;</div><div class="line">					parentOf(parentOf(node)).color = RED;</div><div class="line">					leftRotate(parentOf(parentOf(node)));</div><div class="line">				}</div><div class="line">			}</div><div class="line">		}</div><div class="line">		<span class="comment">/* 1.防止插入节点为根节点        </span></div><div class="line">		 * 2.防止树深度较低时grandparent为root节点,从而在情况一uncle为red时，把root节点置为red 	 */</div><div class="line">		<span class="keyword">if</span> (node == root) {</div><div class="line">			node.color = BLACK;</div><div class="line">		}</div><div class="line">	}</div></pre></td></tr></table></figure>

<p><br></p>
<hr>
<p><br></p>
<h4 id="删除">删除</h4>
<p>将红黑树内的某一个节点删除。需要执行的操作依次是：首先，将红黑树当作一颗二叉查找树，将该节点从二叉查找树中删除；然后，通过”旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树。详细描述如下：<br><strong>第一步</strong>：将红黑树当作一颗二叉查找树，将节点删除。<br>这和”删除常规二叉查找树中删除节点的方法是一样的”。分3种情况：</p>
<ol>
<li>被删除节点没有儿子，即为叶节点。那么，直接将该节点删除就OK了。</li>
<li>被删除节点只有一个儿子。那么，直接删除该节点，并用该节点的唯一子节点顶替它的位置。</li>
<li>被删除节点有两个儿子。那么，先找出它的后继节点；然后把“它的后继节点的内容”复制给“该节点的内容”；之后，删除“它的后继节点”。在这里，后继节点相当于替身，在将后继节点的内容复制给”被删除节点”之后，再将后继节点删除。这样就巧妙的将问题转换为”删除后继节点”的情况了,从而转换成为情况1或情况2</li>
</ol>
<p><strong>第二步</strong>：通过”旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树。<br>因为”第一步”中删除节点之后，可能会违背红黑树的特性。所以需要通过”旋转和重新着色”来修正该树，使之重新成为一棵红黑树。</p>
<p>删除操作代码见最后的完整代码，下面主要研究插入后的修正操作：<br>当删除节点是红色的，红黑性质仍然得以保存，故考虑删除节点是黑色的情况。</p>
<ul>
<li>修复情况1：兄弟节点为红色(此时父节点和兄弟节点的子节点分为黑)。</li>
</ul>
<p><center> <img src="http://alexyoung.qiniudn.com/Red-black_tree_delete_case_2.png" alt=""> <center></center></center></p>
<p>因为兄弟节点必有黑孩子，可以改变兄弟节点S和父节点P的颜色，在对P做一次左旋，从而转换为情形2-4，图中转换为情况2</p>
<ul>
<li>修复情况2：兄弟是黑色且兄弟节点的两个子节点全为黑色。</li>
</ul>
<p><center> <img src="http://alexyoung.qiniudn.com/Red-black_tree_delete_case_4.png" alt=""> <center></center></center></p>
<p>因为S节点和S的两个子节点都是黑色，故需要从S支数去除一层黑色，来平衡黑高度，故将S的颜色改为RED，并将N直到P上，继续迭代。</p>
<ul>
<li>修复情况3：兄弟节点是黑色，兄弟的左子是红色，右子是黑色。</li>
</ul>
<p><center> <img src="http://alexyoung.qiniudn.com/Red-black_tree_delete_case_5.png" alt=""> <center></center></center></p>
<p>交换兄弟节点S与其左孩子的颜色，然后对S进行右旋，现在N的新兄弟S是一个有红色右孩子的黑节点，进入情况4</p>
<ul>
<li>修复情况4：当前节点颜色是黑-黑色，它的兄弟节点是黑色，但是兄弟节点的右子是红色，兄弟节点左子的颜色任意。</li>
</ul>
<p><center> <img src="http://alexyoung.qiniudn.com/Red-black_tree_delete_case_6.png" alt=""> <center></center></center></p>
<p>修改某些节点颜色，并对P做一次左旋，将N置为根，循环结束。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeFixUp</span>(Node&lt;T&gt; node){</div><div class="line">	</div><div class="line">		<span class="keyword">while</span> (node != <span class="keyword">this</span>.root && node.color == BLACK) {</div><div class="line">			<span class="comment">// 若节点是父节点的左孩子</span></div><div class="line">			<span class="keyword">if</span> (node == parentOf(node).left) {</div><div class="line">				Node&lt;T&gt; uncle = parentOf(node).right;		</div><div class="line">				<span class="keyword">if</span> (isRed(uncle)) {		<span class="comment">//情况一：叔叔节点为红色</span></div><div class="line">					parentOf(node).color = RED;</div><div class="line">					uncle.color = BLACK;</div><div class="line">					leftRotate(parentOf(node));</div><div class="line">					uncle = parentOf(node).right;</div><div class="line">				}</div><div class="line">				<span class="comment">//情况二：叔叔节点为黑色，且有两个黑孩子</span></div><div class="line">				<span class="keyword">if</span> (isBlack(uncle.left) && isBlack(uncle.right)) {</div><div class="line">					uncle.color = RED;</div><div class="line">					node = parentOf(node);</div><div class="line">				}<span class="keyword">else</span> {										</div><div class="line">					<span class="keyword">if</span> (isBlack(uncle.right)) {		<span class="comment">//情况三：叔叔节点的左孩子为红色，右孩子为黑色</span></div><div class="line">						uncle.left.color = BLACK;</div><div class="line">						uncle.color = RED;</div><div class="line">						rightRotate(uncle);</div><div class="line">						uncle = parentOf(node).right;</div><div class="line">					}</div><div class="line">					uncle.color = parentOf(node).color;		<span class="comment">//情况四：叔叔节点的右孩子为红色</span></div><div class="line">					parentOf(node).color = BLACK;</div><div class="line">					uncle.right.color = BLACK;</div><div class="line">					leftRotate(parentOf(node));</div><div class="line">					node = root;</div><div class="line">				}</div><div class="line">			}<span class="keyword">else</span> {</div><div class="line">				Node&lt;T&gt; uncle = parentOf(node).left;</div><div class="line">				<span class="keyword">if</span> (isRed(uncle)) {</div><div class="line">					parentOf(node).color = RED;</div><div class="line">					uncle.color = BLACK;</div><div class="line">					rightRotate(parentOf(node));</div><div class="line">					uncle = parentOf(node).left;</div><div class="line">				}</div><div class="line">				<span class="keyword">if</span> (isBlack(uncle.left) && isBlack(uncle.right)) {</div><div class="line">					uncle.color = RED;</div><div class="line">					node = parentOf(node);</div><div class="line">				}<span class="keyword">else</span> {</div><div class="line">					<span class="keyword">if</span> (isBlack(uncle.left)) {</div><div class="line">						uncle.right.color = BLACK;</div><div class="line">						uncle.color = RED;</div><div class="line">						leftRotate(uncle);</div><div class="line">						uncle = parentOf(node).left;</div><div class="line">					}</div><div class="line">					uncle.color = parentOf(node).color;</div><div class="line">					parentOf(node).color = BLACK;</div><div class="line">					uncle.left.color = BLACK;</div><div class="line">					rightRotate(parentOf(node));</div><div class="line">					node = root;</div><div class="line">				}</div><div class="line">			}</div><div class="line">		}</div><div class="line">		node.color = BLACK;</div><div class="line">	}</div></pre></td></tr></table></figure>

<p><br></p>
<hr>
<p><br></p>
<h3 id="动态顺序统计">动态顺序统计</h3>
<p>在之前的<a href="http://alexyyek.github.io/2014/12/08/select/" target="_blank" rel="external"><strong>顺序统计学</strong></a>问题中，我们尝试在<code>O(n)</code>的时间内找到无序集合中第i小的数。这里将介绍如何修改红黑树的结构，使得任意的顺序统计量都可以在<code>O(lgn)</code>时间内确定。</p>
<p>一颗<strong>顺序统计量数</strong>通过在红黑树的每个节点中存入附加信息而成，即除了节点的key值，还包含了域<code>size</code>，如下图size的规则为：</p>
<p><center> $size[x]=size[left[x]]+size[right[x]]+1$ <center></center></center></p>
<p><center> <img src="http://alexyoung.qiniudn.com/01212325-22d4dc3f9b39450e9e5254db69372047.png" alt=""><center></center></center></p>
<p><strong>如何扩张数据结构：</strong></p>
<ul>
<li>选择基础的数据结构</li>
<li>确定要在基础数据结构中添加哪些信息（根据需要）</li>
<li>验证可用基础数据结构上的基础修改操作来维护新添加的信息</li>
<li>设计新的操作</li>
</ul>
<p><br></p>
<h4 id="检索给定排序的元素">检索给定排序的元素</h4>
<p>为了找出顺序统计数中第i小的关键字，递归版伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">OS-SELECT(root[T],i)</div><div class="line">r = size[left[x]] + <span class="number">1</span></div><div class="line"><span class="keyword">if</span> r = i</div><div class="line">    then <span class="keyword">return</span> x</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> i &lt; r</div><div class="line">    then <span class="keyword">return</span> OS-SELECT(left[x],i)</div><div class="line"><span class="keyword">else</span> </div><div class="line">    <span class="keyword">return</span> OS-SELECT(right[x], i-r)</div></pre></td></tr></table></figure>

<p><br></p>
<h4 id="确定一个元素的秩">确定一个元素的秩</h4>
<p>过程OS-RANK返回在对树进行中序遍历得到的线性序中x的位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">OS-RANK(T,x)</div><div class="line">r = size[left[x]] + <span class="number">1</span></div><div class="line">y = x</div><div class="line"><span class="keyword">while</span> y != root[T]</div><div class="line">    do <span class="keyword">if</span> y = right[p[y]]</div><div class="line">        r = r + size[left[p[y]]] + <span class="number">1</span></div><div class="line">        y = p[y]</div><div class="line"><span class="keyword">return</span> r</div></pre></td></tr></table></figure>

<p><br></p>
<h4 id="对子树规模的维护">对子树规模的维护</h4>
<p>红黑树的插入和删除可能会改变树的结构，为了维护红黑树的结构，需要更新域size的值，左旋在原有代码下增加两行：</p>
<p><center> $size[y] = size[x]$ <center></center></center></p>
<p><center> $size[x] = size[left[x]] + size[right[x]] + 1$ <center></center></center></p>
<p><center> <img src="http://alexyoung.qiniudn.com/101600338568211.png" alt=""> <center></center></center></p>
<p>点击<a href="http://www.cnblogs.com/alan-forever/p/3657086.html" target="_blank" rel="external"><strong>具体讲解</strong></a></p>
<figure class="highlight C"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * x结点上进行左旋转，y结点（x结点的右儿子）的左儿子成为x结点的新右儿子</div><div class="line"> * x结点成为y结点的左儿子的新父结点</div><div class="line"> * x结点的父结点成为y结点的新父结点，y结点成为x结点的新父结点</div><div class="line"> * x结点成为y结点的新左儿子</div><div class="line"> */</div><div class="line"><span class="keyword">void</span> Left_Rotate(RB_Tree *T, RB_TreeNode *x){</div><div class="line">    RB_TreeNode *y = x-&gt;right;       <span class="comment">//x点右儿子          </span></div><div class="line">    x-&gt;right = y-&gt;left;              <span class="comment">//y结点的左儿子会成为x结点的右儿子</span></div><div class="line">    <span class="keyword">if</span>(y-&gt;left != NIL)</div><div class="line">        y-&gt;left-&gt;parent = x;         <span class="comment">//如果y有左儿子,y的左儿子的父结点为x</span></div><div class="line">    y-&gt;parent = x-&gt;parent;</div><div class="line">    <span class="keyword">if</span>(x-&gt;parent == NIL)</div><div class="line">        T-&gt;root = y;                <span class="comment">//如果x的父结点为哨兵，说明x为根结点，则y成为根结点</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x == x-&gt;parent-&gt;left)</div><div class="line">        x-&gt;parent-&gt;left = y;        </div><div class="line">    <span class="keyword">else</span></div><div class="line">        x-&gt;parent-&gt;right = y;       <span class="comment">//判断x为其父结点的左、右儿子，y成为x父结点对应的儿子</span></div><div class="line">    y-&gt;left = x;                    <span class="comment">//y的左儿子为x</span></div><div class="line">    x-&gt;parent = y;                  <span class="comment">//x的父结点为y</span></div><div class="line"></div><div class="line">    <span class="comment">/*调整size域*/</span></div><div class="line">    y-&gt;size = x-&gt;size;</div><div class="line">    x-&gt;size = x-&gt;left-&gt;size + x-&gt;right-&gt;size + <span class="number">1</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p><br></p>
<hr>
<h3 id="完整代码">完整代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div><div class="line">369</div><div class="line">370</div><div class="line">371</div><div class="line">372</div><div class="line">373</div><div class="line">374</div><div class="line">375</div><div class="line">376</div><div class="line">377</div><div class="line">378</div><div class="line">379</div><div class="line">380</div><div class="line">381</div><div class="line">382</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> Algorithm;</div><div class="line"></div><div class="line"><span class="javadoc">/**</span></div><div class="line"> * red-black tree</div><div class="line"> *<span class="javadoctag"> @author</span> AlexYoung</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RBTree</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>{</div><div class="line">	<span class="keyword">private</span> Node&lt;T&gt; root;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED = <span class="keyword">true</span>;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK = <span class="keyword">false</span>;</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt;</span>{</div><div class="line">		T key;</div><div class="line">		Node&lt;T&gt; left;</div><div class="line">		Node&lt;T&gt; right;</div><div class="line">		Node&lt;T&gt; parent;</div><div class="line">		<span class="keyword">boolean</span> color;</div><div class="line">		</div><div class="line">		</div><div class="line">		<span class="keyword">public</span> <span class="title">Node</span>(T key, Node&lt;T&gt; left, Node&lt;T&gt; right, Node&lt;T&gt; parent, Boolean color){</div><div class="line">			<span class="keyword">this</span>.key = key;</div><div class="line">			<span class="keyword">this</span>.left = left;</div><div class="line">			<span class="keyword">this</span>.right = right;</div><div class="line">			<span class="keyword">this</span>.parent = parent;</div><div class="line">			<span class="keyword">this</span>.color = color;</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">public</span> T <span class="title">getKey</span>(){</div><div class="line">			<span class="keyword">return</span> key;</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">public</span> String <span class="title">toString</span>(){</div><div class="line">			<span class="keyword">return</span> <span class="string">""</span> + key + <span class="string">" "</span> + color;</div><div class="line">		}</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="title">RBTree</span>(){</div><div class="line">		root = <span class="keyword">null</span>;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> Node&lt;T&gt; <span class="title">parentOf</span>(Node&lt;T&gt; node){</div><div class="line">		<span class="keyword">return</span> (node != <span class="keyword">null</span>) ? node.parent : <span class="keyword">null</span>;</div><div class="line">	}</div><div class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">colorOf</span>(Node&lt;T&gt; node){</div><div class="line">		<span class="keyword">return</span> (node != <span class="keyword">null</span>) ? node.color : BLACK;</div><div class="line">	}</div><div class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRed</span>(Node&lt;T&gt; node){</div><div class="line">		<span class="keyword">return</span> (node != <span class="keyword">null</span>) && (node.color == RED) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</div><div class="line">	}</div><div class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isBlack</span>(Node&lt;T&gt; node){</div><div class="line">		<span class="keyword">return</span> !isRed(node);</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> Node&lt;T&gt; <span class="title">miNode</span>(Node&lt;T&gt; node){</div><div class="line">		<span class="keyword">while</span> (node.left != <span class="keyword">null</span>) {</div><div class="line">			node = node.left;</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> node;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span>(Node&lt;T&gt; tree){</div><div class="line">		<span class="keyword">if</span>(tree != <span class="keyword">null</span>) {</div><div class="line">			inOrder(tree.left);</div><div class="line">			System.out.print(tree.key + <span class="string">"\t"</span>);</div><div class="line">			inOrder(tree.right);</div><div class="line">		}</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span>(){</div><div class="line">		inOrder(root);</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> Node&lt;T&gt; <span class="title">maxNode</span>(Node&lt;T&gt; node){</div><div class="line">		<span class="keyword">while</span> (node.right != <span class="keyword">null</span>) {</div><div class="line">			node = node.right;</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> node;</div><div class="line">	}</div><div class="line">	<span class="comment">// 前趋</span></div><div class="line">	<span class="keyword">private</span> Node&lt;T&gt; <span class="title">succussor</span>(Node&lt;T&gt; node){</div><div class="line">		<span class="keyword">if</span> (node.right != <span class="keyword">null</span>) {</div><div class="line">			<span class="keyword">return</span> miNode(node.right);</div><div class="line">		}</div><div class="line">		Node&lt;T&gt; parent = node.parent;</div><div class="line">		<span class="keyword">while</span> (parent != <span class="keyword">null</span> && node == parent.right) {</div><div class="line">			node = parent;</div><div class="line">			parent = parent.parent;</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> parent;</div><div class="line">	}</div><div class="line">	<span class="comment">// 后继</span></div><div class="line">	<span class="keyword">private</span> Node&lt;T&gt; <span class="title">preDecessor</span>(Node&lt;T&gt; node){</div><div class="line">		<span class="keyword">if</span> (node.left != <span class="keyword">null</span>) {</div><div class="line">			<span class="keyword">return</span> maxNode(node.left);</div><div class="line">		}</div><div class="line">		Node&lt;T&gt; parent = node.parent;</div><div class="line">		<span class="keyword">while</span> (parent != <span class="keyword">null</span> && node == parent.left) {</div><div class="line">			node = parent;</div><div class="line">			parent = parent.parent;</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> parent;</div><div class="line">	}</div><div class="line">	<span class="comment">//	左旋</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title">leftRotate</span>(Node&lt;T&gt; x){</div><div class="line">		<span class="comment">//consider the left child of y</span></div><div class="line">		Node&lt;T&gt; y = x.right;</div><div class="line">		x.right = y.left;</div><div class="line">		<span class="keyword">if</span> (y.left != <span class="keyword">null</span>) {</div><div class="line">			y.left.parent = x;</div><div class="line">		}</div><div class="line">		<span class="comment">//consider the node y</span></div><div class="line">		y.parent = x.parent;</div><div class="line">		<span class="keyword">if</span> (x.parent == <span class="keyword">null</span>) {</div><div class="line">			root = y;</div><div class="line">		}<span class="keyword">else</span>{</div><div class="line">			<span class="keyword">if</span>(x == x.parent.left)</div><div class="line">			x.parent.left = y;</div><div class="line">			<span class="keyword">else</span> </div><div class="line">			x.parent.right = y;</div><div class="line">		}</div><div class="line">		<span class="comment">//consider the Node x</span></div><div class="line">		y.left = x;</div><div class="line">		x.parent = y;</div><div class="line">	}</div><div class="line">	<span class="comment">//	右旋</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rightRotate</span>(Node&lt;T&gt; x){</div><div class="line">		Node&lt;T&gt; y= x.left;</div><div class="line">		x.left = y.right;</div><div class="line">		<span class="keyword">if</span> (y.right != <span class="keyword">null</span>) {</div><div class="line">			y.right.parent = x;</div><div class="line">		}</div><div class="line">		</div><div class="line">		y.parent = x.parent;</div><div class="line">		<span class="keyword">if</span> (x.parent == <span class="keyword">null</span>) {</div><div class="line">			root = y;</div><div class="line">		}<span class="keyword">else</span>{</div><div class="line">			<span class="keyword">if</span> (x == x.parent.left)</div><div class="line">			x.parent.left = y;</div><div class="line">			<span class="keyword">else</span> </div><div class="line">			x.parent.right = y;</div><div class="line">		}</div><div class="line">		</div><div class="line">		y.right = x;</div><div class="line">		x.parent =y;</div><div class="line">	}</div><div class="line">	<span class="comment">//递归查找</span></div><div class="line">	<span class="keyword">public</span> Node&lt;T&gt; <span class="title">search</span>(Node&lt;T&gt; tree, T key){</div><div class="line">		<span class="keyword">if</span> (tree == <span class="keyword">null</span> || key == tree.key) {</div><div class="line">			<span class="keyword">return</span> tree;</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (key.compareTo(tree.key) &lt;= <span class="number">0</span>) {</div><div class="line">			<span class="keyword">return</span> search(tree.left, key);</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			<span class="keyword">return</span> search(tree.right, key);</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="comment">//非递归查找</span></div><div class="line">	<span class="keyword">public</span> Node&lt;T&gt; <span class="title">searchNode</span>(Node&lt;T&gt; tree, T key){</div><div class="line">		<span class="keyword">while</span> (tree != <span class="keyword">null</span> && tree.key != key) {</div><div class="line">			<span class="keyword">if</span> (key.compareTo(tree.key) &lt;= <span class="number">0</span>) {</div><div class="line">				tree = tree.left;</div><div class="line">			}<span class="keyword">else</span> {</div><div class="line">				tree = tree.right;</div><div class="line">			}</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> tree;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="javadoc">/**</span></div><div class="line">	 * 将结点插入到红黑树中</div><div class="line">	 *<span class="javadoctag"> @param</span> node : 插入的结点</div><div class="line">	 */</div><div class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span>(Node&lt;T&gt; node){</div><div class="line">		Node&lt;T&gt; y = <span class="keyword">null</span>;</div><div class="line">		Node&lt;T&gt; x = <span class="keyword">this</span>.root;</div><div class="line">		<span class="keyword">while</span> (x != <span class="keyword">null</span>) {</div><div class="line">			y = x;</div><div class="line">			<span class="keyword">if</span> (node.key.compareTo(x.key) &lt;= <span class="number">0</span>) {</div><div class="line">				x = x.left;</div><div class="line">			} <span class="keyword">else</span> {</div><div class="line">				x = x.right;</div><div class="line">			}</div><div class="line">		}</div><div class="line"></div><div class="line">		node.parent = y;</div><div class="line">		<span class="keyword">if</span> (y == <span class="keyword">null</span>) {</div><div class="line">			root = node;</div><div class="line">			node.color = BLACK;</div><div class="line">		} <span class="keyword">else</span> {</div><div class="line">			<span class="keyword">if</span> (node.key.compareTo(y.key) &lt;= <span class="number">0</span>) {</div><div class="line">				y.left = node;</div><div class="line">				node.color = RED;</div><div class="line">			} <span class="keyword">else</span> {</div><div class="line">				y.right = node;</div><div class="line">				node.color = RED;</div><div class="line">			}</div><div class="line">		}</div><div class="line">		</div><div class="line">		</div><div class="line">		insertFixUp(node);</div><div class="line">	}</div><div class="line">	<span class="javadoc">/**</span></div><div class="line">	 * </div><div class="line">	 *<span class="javadoctag"> @param</span> key : 插入节点的键值</div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span>(T key){</div><div class="line">		Node&lt;T&gt; node = <span class="keyword">new</span> Node&lt;T&gt;(key, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, BLACK);</div><div class="line">		<span class="keyword">if</span> (node != <span class="keyword">null</span>) {</div><div class="line">			insert(node);</div><div class="line">		}</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertFixUp</span>(Node&lt;T&gt; node){</div><div class="line">		<span class="comment">//	若父节点存在，并且父节点的颜色是红色</span></div><div class="line">		<span class="keyword">while</span>(node.parent != <span class="keyword">null</span> && isRed(node.parent)) {</div><div class="line">			<span class="comment">// 若父节点”是“祖父节点的左孩子</span></div><div class="line">			<span class="keyword">if</span> (parentOf(node) == parentOf(parentOf(node)).left) {</div><div class="line">				Node&lt;T&gt; uncle = parentOf(parentOf(node)).right;		<span class="comment">//叔叔节点，即父节点的兄弟节点</span></div><div class="line">				<span class="keyword">if</span> (isRed(uncle)) {									<span class="comment">//情况一：如果叔叔节点是红色，因为父节点是红色，显然祖父节点是黑色</span></div><div class="line">					parentOf(node).color = BLACK;</div><div class="line">					uncle.color = BLACK;</div><div class="line">					parentOf(parentOf(node)).color = RED;</div><div class="line">					node = parentOf(parentOf(node));</div><div class="line">				}</div><div class="line">				<span class="keyword">else</span> {	</div><div class="line">					<span class="keyword">if</span> (parentOf(node).right == node) {				<span class="comment">//情况二：叔叔节点是黑色，而Z是右孩子</span></div><div class="line">						 node = parentOf(node);</div><div class="line">						 leftRotate(node);</div><div class="line">					}</div><div class="line">					</div><div class="line">					parentOf(node).color = BLACK;					<span class="comment">//情况三：叔叔节点黑色，Z是左孩子</span></div><div class="line">					parentOf(parentOf(node)).color = RED;</div><div class="line">					rightRotate(parentOf(parentOf(node)));</div><div class="line">				}</div><div class="line">			}</div><div class="line">			<span class="comment">// 若父节点”是“祖父节点的右孩子</span></div><div class="line">			<span class="keyword">else</span> {</div><div class="line">				Node&lt;T&gt; uncle = parentOf(parentOf(node)).left;</div><div class="line">				<span class="keyword">if</span> (isRed(uncle)) {</div><div class="line">					parentOf(node).color = BLACK;</div><div class="line">					uncle.color = BLACK;</div><div class="line">					parentOf(parentOf(node)).color = RED;</div><div class="line">					node = parentOf(parentOf(node));</div><div class="line">				}</div><div class="line">				<span class="keyword">else</span> {</div><div class="line">					<span class="keyword">if</span> (parentOf(node).left == node) {</div><div class="line">						 node = parentOf(node);</div><div class="line">						 rightRotate(node);</div><div class="line">					}</div><div class="line">					parentOf(node).color = BLACK;</div><div class="line">					parentOf(parentOf(node)).color = RED;</div><div class="line">					leftRotate(parentOf(parentOf(node)));</div><div class="line">				}</div><div class="line">			}</div><div class="line">		}</div><div class="line">		<span class="comment">/* 1.防止插入节点为根节点        </span></div><div class="line">		 * 2.防止树深度较低时grandparent为root节点,从而在情况一uncle为red时，把root节点置为red 	 */</div><div class="line">		<span class="keyword">if</span> (node == root) {</div><div class="line">			node.color = BLACK;</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="javadoc">/**</span></div><div class="line">	 * 删除节点</div><div class="line">	 *<span class="javadoctag"> @param</span> node : 待删除节点</div><div class="line">	 *<span class="javadoctag"> @return</span></div><div class="line">	 */</div><div class="line">	<span class="keyword">private</span> Node&lt;T&gt; <span class="title">remove</span>(Node&lt;T&gt; node){</div><div class="line">		Node&lt;T&gt; replace = <span class="keyword">null</span>;</div><div class="line">		<span class="keyword">if</span> (node.left == <span class="keyword">null</span> || node.right == <span class="keyword">null</span>) {</div><div class="line">			replace = node;</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			replace = succussor(node);</div><div class="line">		}</div><div class="line">		Node&lt;T&gt; child = replace.left != <span class="keyword">null</span> ? replace.left : replace.right; </div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (child == <span class="keyword">null</span>) {</div><div class="line">			child = <span class="keyword">new</span> Node&lt;T&gt;(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, replace.parent, BLACK);</div><div class="line">		}</div><div class="line">		child.parent = replace.parent;</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (replace.parent == <span class="keyword">null</span>) {</div><div class="line">			root = child;</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			<span class="keyword">if</span>(replace == replace.parent.left)</div><div class="line">				replace.parent.left = child;</div><div class="line">			<span class="keyword">else</span></div><div class="line">				replace.parent.right = child;</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (replace != node) {</div><div class="line">			node.key = replace.key;</div><div class="line">		}</div><div class="line">		<span class="keyword">if</span> (isBlack(replace)) {</div><div class="line">			removeFixUp(child);</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> replace;</div><div class="line">	}</div><div class="line">	<span class="javadoc">/**</span></div><div class="line">	 * 删除某一数值</div><div class="line">	 *<span class="javadoctag"> @param</span> key : 待删除值</div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span>(T key){</div><div class="line">		Node&lt;T&gt; node = <span class="keyword">null</span>;</div><div class="line">		<span class="keyword">if</span> ((node = searchNode(root, key)) != <span class="keyword">null</span>) {</div><div class="line">			remove(node);</div><div class="line">		}</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeFixUp</span>(Node&lt;T&gt; node){</div><div class="line">	</div><div class="line">		<span class="keyword">while</span> (node != <span class="keyword">this</span>.root && node.color == BLACK) {</div><div class="line">			<span class="comment">// 若节点是父节点的左孩子</span></div><div class="line">			<span class="keyword">if</span> (node == parentOf(node).left) {</div><div class="line">				Node&lt;T&gt; uncle = parentOf(node).right;		</div><div class="line">				<span class="keyword">if</span> (isRed(uncle)) {							<span class="comment">//情况一：叔叔节点为红色</span></div><div class="line">					parentOf(node).color = RED;</div><div class="line">					uncle.color = BLACK;</div><div class="line">					leftRotate(parentOf(node));</div><div class="line">					uncle = parentOf(node).right;</div><div class="line">				}</div><div class="line">				<span class="comment">//情况二：叔叔节点为黑色，且有两个黑孩子</span></div><div class="line">				<span class="keyword">if</span> (isBlack(uncle.left) && isBlack(uncle.right)) {</div><div class="line">					uncle.color = RED;</div><div class="line">					node = parentOf(node);</div><div class="line">				}<span class="keyword">else</span> {										</div><div class="line">					<span class="keyword">if</span> (isBlack(uncle.right)) {				<span class="comment">//情况三：叔叔节点的左孩子为红色，右孩子为黑色</span></div><div class="line">						uncle.left.color = BLACK;</div><div class="line">						uncle.color = RED;</div><div class="line">						rightRotate(uncle);</div><div class="line">						uncle = parentOf(node).right;</div><div class="line">					}</div><div class="line">					uncle.color = parentOf(node).color;		<span class="comment">//情况四：叔叔节点的右孩子为红色</span></div><div class="line">					parentOf(node).color = BLACK;</div><div class="line">					uncle.right.color = BLACK;</div><div class="line">					leftRotate(parentOf(node));</div><div class="line">					node = root;</div><div class="line">				}</div><div class="line">			}<span class="keyword">else</span> {</div><div class="line">				Node&lt;T&gt; uncle = parentOf(node).left;</div><div class="line">				<span class="keyword">if</span> (isRed(uncle)) {</div><div class="line">					parentOf(node).color = RED;</div><div class="line">					uncle.color = BLACK;</div><div class="line">					rightRotate(parentOf(node));</div><div class="line">					uncle = parentOf(node).left;</div><div class="line">				}</div><div class="line">				<span class="keyword">if</span> (isBlack(uncle.left) && isBlack(uncle.right)) {</div><div class="line">					uncle.color = RED;</div><div class="line">					node = parentOf(node);</div><div class="line">				}<span class="keyword">else</span> {</div><div class="line">					<span class="keyword">if</span> (isBlack(uncle.left)) {</div><div class="line">						uncle.right.color = BLACK;</div><div class="line">						uncle.color = RED;</div><div class="line">						leftRotate(uncle);</div><div class="line">						uncle = parentOf(node).left;</div><div class="line">					}</div><div class="line">					uncle.color = parentOf(node).color;</div><div class="line">					parentOf(node).color = BLACK;</div><div class="line">					uncle.left.color = BLACK;</div><div class="line">					rightRotate(parentOf(node));</div><div class="line">					node = root;</div><div class="line">				}</div><div class="line">			}</div><div class="line">		}</div><div class="line">		node.color = BLACK;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){</div><div class="line">		<span class="keyword">int</span>[] arr = {<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">60</span>, <span class="number">90</span>, <span class="number">70</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">80</span>};</div><div class="line">		RBTree&lt;Integer&gt; tree = <span class="keyword">new</span> RBTree&lt;Integer&gt;();</div><div class="line">		</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i : arr){</div><div class="line">			tree.insert(i);</div><div class="line">		}</div><div class="line">		tree.inOrder();</div><div class="line">		tree.remove(<span class="number">20</span>);</div><div class="line">		System.out.println();</div><div class="line">		tree.inOrder();</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[一颗高度为H的二叉树可以实现任何一种基本的动态集合操作，时间都为O(h)，当数的高度较低时，这种操作较快，但是当树的高度较高时，红黑树由于其平衡树的特点，保证了基本动态操作时间为O(lgn)。]]>
    
    </summary>
    
      <category term="Tree" scheme="http://alexyyek.github.io/tags/Tree/"/>
    
      <category term="coding" scheme="http://alexyyek.github.io/tags/coding/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[二叉查找树]]></title>
    <link href="http://alexyyek.github.io/2014/12/17/BinaryTree/"/>
    <id>http://alexyyek.github.io/2014/12/17/BinaryTree/</id>
    <published>2014-12-17T09:39:28.000Z</published>
    <updated>2014-12-17T13:21:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="二叉查找树">二叉查找树</h2>
<p>一颗二叉查找树是按二叉树的结构来组织的，树中每个结点都是一个对象，节点中除了<code>key</code>域外，还包含域<code>left</code>，<code>right</code>以及<code>parent</code>，分别指向当前节点的左子节点、右子节点和父节点。</p>
<p><center> <img src="http://7rf27k.com1.z0.glb.clouddn.com/QQ图片20141217175217.png" alt=""> <center></center></center></p>
<p>在二叉查找树中：</p>
<ol>
<li>若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>任意节点的左、右子树也分别为二叉查找树。</li>
<li>没有键值相等的节点（待定）</li>
</ol>
<h3 id="遍历操作">遍历操作</h3>
<p>根据二叉查找树的性质，可以由递归算法按排列顺序输出树中的所有关键字。</p>
<p><strong>中序遍历</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span>(Node root){</div><div class="line">		<span class="keyword">if</span> (root != <span class="keyword">null</span>) {</div><div class="line">			inOrder(root.left);</div><div class="line">			System.out.print(root.value +<span class="string">"\t"</span>);</div><div class="line">			inOrder(root.right);</div><div class="line">		}</div><div class="line">	}</div></pre></td></tr></table></figure>

<p>前序遍历和后续遍历形式基本一致，前序先输出root节点，后续最后输出root节点。</p>
<h3 id="查找操作">查找操作</h3>
<p>从二叉查找树根节点开始查找，并沿着树下降，对每个碰到的非空节点比较节点值与查找值大小，按情况向左右子树下降，直到找到并返回节点对象。非递归版本普遍较快。</p>
<p><strong>递归版本</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Node <span class="title">search</span>(Node tree, <span class="keyword">int</span> value){</div><div class="line">		<span class="keyword">if</span> (tree == <span class="keyword">null</span> || value == tree.value) {</div><div class="line">			<span class="keyword">return</span> tree;</div><div class="line">		}</div><div class="line">		<span class="keyword">if</span> (value &lt;= tree.value) {</div><div class="line">			<span class="keyword">return</span> search(tree.left, value);</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			<span class="keyword">return</span> search(tree.right, value);</div><div class="line">		}</div><div class="line">	}</div></pre></td></tr></table></figure>

<p><strong>非递归版本</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Node <span class="title">searchNode</span>(Node tree, <span class="keyword">int</span> value){</div><div class="line">		<span class="keyword">while</span> (tree != <span class="keyword">null</span> && tree.value != value) {</div><div class="line">			<span class="keyword">if</span> (value &lt;= tree.value) {</div><div class="line">				tree = tree.left;</div><div class="line">			}<span class="keyword">else</span> {</div><div class="line">				tree = tree.right;</div><div class="line">			}</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> tree;</div><div class="line">	}</div></pre></td></tr></table></figure>

<h3 id="插入操作">插入操作</h3>
<p>插入操作与查找操作类似，将待插值与当前节点值比较，小于当前节点值则去左子树继续比较，大于当前节点值去右子树比较，直到下降直空节点，则将待插值赋给空节点并返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Node <span class="title">insertNode</span>(Node tree, <span class="keyword">int</span> x){</div><div class="line">		<span class="keyword">if</span> (tree == <span class="keyword">null</span>) {</div><div class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Node(x);</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (x &lt;= tree.value) {</div><div class="line">			tree.left = insertNode(tree.left, x);</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			tree.right = insertNode(tree.right, x);</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> tree;</div><div class="line">	}</div></pre></td></tr></table></figure>

<h3 id="删除操作">删除操作</h3>
<p>删除操作根据所删节点的子女数量可能会改变树的结构，主要分为三种情况：</p>
<ol>
<li>无children节点，直接删除<br><img src="http://7rf27k.com1.z0.glb.clouddn.com/20130506115644277.png" alt=""></li>
<li>有一个children节点，将子节点覆盖删除节点<br><img src="http://7rf27k.com1.z0.glb.clouddn.com/20130506115712159.png" alt=""></li>
<li>两个children节点都不为空，寻址其后继节点（右子树中的最小值），用后继节点值替换删除节点值，然后在其右子树中删除后继节点<br><img src="http://7rf27k.com1.z0.glb.clouddn.com/QQ图片20141217174837.jpg" alt=""></li>
</ol>
<h3 id="二叉查找树性能">二叉查找树性能</h3>
<p>对高度为<strong><code>h</code></strong>的二叉查找树，动态集合操作INSERT和DELETE的运行时间为<strong><code>O(h)</code></strong></p>
<h2 id="完整代码">完整代码</h2>
<h3 id="简单版">简单版</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>{</div><div class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>{</div><div class="line">		Node left;</div><div class="line">		Node right;</div><div class="line">		<span class="keyword">int</span> value;</div><div class="line">		</div><div class="line">		<span class="keyword">public</span> <span class="title">Node</span>(<span class="keyword">int</span> value){</div><div class="line">			<span class="keyword">this</span>.value = value;</div><div class="line">			left = <span class="keyword">null</span>;</div><div class="line">			right = <span class="keyword">null</span>;</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="keyword">private</span> Node root;</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="title">BinarySearchTree</span>(){</div><div class="line">		root = <span class="keyword">null</span>;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="title">BinarySearchTree</span>(<span class="keyword">int</span>[] arr){</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i : arr){</div><div class="line">			insert(i);</div><div class="line">		}</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span>(<span class="keyword">int</span> value){</div><div class="line">		root = insert(root, value);</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> Node <span class="title">insert</span>(Node root, <span class="keyword">int</span> value){</div><div class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) {</div><div class="line">			root = <span class="keyword">new</span> Node(value);</div><div class="line">		}<span class="keyword">else</span> <span class="keyword">if</span> (value &lt;= root.value) {</div><div class="line">			<span class="keyword">if</span> (root.left == <span class="keyword">null</span>) {</div><div class="line">				root.left = <span class="keyword">new</span> Node(value);</div><div class="line">			}<span class="keyword">else</span> {</div><div class="line">				insert(root.left, value);</div><div class="line">			}</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			<span class="keyword">if</span> (root.right == <span class="keyword">null</span>) {</div><div class="line">				root.right = <span class="keyword">new</span> Node(value);</div><div class="line">			}<span class="keyword">else</span> {</div><div class="line">				insert(root.right, value);</div><div class="line">			}</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> root;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="comment">//中序遍历</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span>(Node tree){</div><div class="line">		<span class="keyword">if</span> (tree != <span class="keyword">null</span>) {</div><div class="line">			inOrder(tree.left);</div><div class="line">			System.out.print(tree.value + <span class="string">"\t"</span>);</div><div class="line">			inOrder(tree.right);</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="comment">//前序遍历</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span>(Node tree){</div><div class="line">		<span class="keyword">if</span> (tree != <span class="keyword">null</span>) {</div><div class="line">			System.out.print(tree.value +<span class="string">"\t"</span>);</div><div class="line">			preOrder(tree.left);</div><div class="line">			preOrder(tree.right);</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="comment">//后续遍历</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span>(Node tree){</div><div class="line">		<span class="keyword">if</span> (tree != <span class="keyword">null</span>) {</div><div class="line">			postOrder(tree.left);</div><div class="line">			postOrder(tree.right);</div><div class="line">			System.out.print(tree.value +<span class="string">"\t"</span>);</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="comment">//递归</span></div><div class="line">	<span class="keyword">public</span> Node <span class="title">search</span>(Node tree, <span class="keyword">int</span> value){</div><div class="line">		<span class="keyword">if</span> (tree == <span class="keyword">null</span> || value == tree.value) {</div><div class="line">			<span class="keyword">return</span> tree;</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (value &lt;= tree.value) {</div><div class="line">			<span class="keyword">return</span> search(tree.left, value);</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			<span class="keyword">return</span> search(tree.right, value);</div><div class="line">		}</div><div class="line">		</div><div class="line">	}</div><div class="line">	<span class="comment">//非递归</span></div><div class="line">	<span class="keyword">public</span> Node <span class="title">searchNoIter</span>(Node root, <span class="keyword">int</span> value){</div><div class="line">		<span class="keyword">while</span> (root != <span class="keyword">null</span> && value != root.value) {</div><div class="line">			<span class="keyword">if</span> (value &lt;= root.value) {</div><div class="line">				root = root.left;</div><div class="line">			}<span class="keyword">else</span> {</div><div class="line">				root = root.right;</div><div class="line">			}</div><div class="line">		}</div><div class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) {</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Null Poninter"</span> + value);</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			<span class="keyword">return</span> root;</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="comment">//	最小值节点</span></div><div class="line">	<span class="keyword">public</span> Node <span class="title">minNode</span>(Node root){</div><div class="line">		<span class="keyword">while</span> (root.left != <span class="keyword">null</span>) {</div><div class="line">			root = root.left;</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> root;</div><div class="line">	}</div><div class="line">	<span class="comment">//	最大值节点</span></div><div class="line">	<span class="keyword">public</span> Node <span class="title">maxNode</span>(Node root){</div><div class="line">		<span class="keyword">while</span> (root.right != <span class="keyword">null</span>) {</div><div class="line">			root = root.right;</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> root;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> Node <span class="title">insertNode</span>(Node root, Node x){</div><div class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) {</div><div class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Node(x.value);</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (x.value &lt;= root.value) {</div><div class="line">			root.left = insertNode(root.left, x);</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			root.right = insertNode(root.right, x);</div><div class="line">		}</div><div class="line">	</div><div class="line">		<span class="keyword">return</span> root;</div><div class="line">	}</div><div class="line">	</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> Node <span class="title">remove</span>(Node root, <span class="keyword">int</span> value){</div><div class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) {</div><div class="line">			<span class="keyword">return</span> root;</div><div class="line">		}</div><div class="line">		<span class="keyword">if</span> (value &lt; root.value) {</div><div class="line">			root.left = remove(root.left, value);</div><div class="line">		}<span class="keyword">else</span> <span class="keyword">if</span> (value &gt; root.value) {</div><div class="line">			root.right = remove(root.right, value);</div><div class="line">		}<span class="keyword">else</span> <span class="keyword">if</span> (root.left != <span class="keyword">null</span> && root.right != <span class="keyword">null</span>) {</div><div class="line">			root.value = minNode(root.right).value;</div><div class="line">			root.right = remove(root.right, root.value);</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			root = (root.left != <span class="keyword">null</span>)? root.left:root.right;</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> root;</div><div class="line">	}</div></pre></td></tr></table></figure>

<p><br></p>
<hr>
<h3 id="泛型带parent节点版本">泛型带parent节点版本</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> Algorithm;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BiSearchTree</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>{</div><div class="line">	<span class="keyword">private</span> Node&lt;T&gt; root;</div><div class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt;</span>{</div><div class="line">		T key;</div><div class="line">		Node&lt;T&gt; left;</div><div class="line">		Node&lt;T&gt; right;</div><div class="line">		Node&lt;T&gt; parent;</div><div class="line">		</div><div class="line">		<span class="keyword">public</span> <span class="title">Node</span>(T key, Node&lt;T&gt; parent, Node&lt;T&gt; left, Node&lt;T&gt;right){</div><div class="line">			<span class="keyword">this</span>.key = key;</div><div class="line">			<span class="keyword">this</span>.parent = parent;</div><div class="line">			<span class="keyword">this</span>.left = left;</div><div class="line">			<span class="keyword">this</span>.right = right;</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">public</span> T <span class="title">getKey</span>(){</div><div class="line">			<span class="keyword">return</span> key;</div><div class="line">		}</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="title">BiSearchTree</span>(){</div><div class="line">		root = <span class="keyword">null</span>;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span>(Node&lt;T&gt; root){</div><div class="line">		<span class="keyword">if</span> (root != <span class="keyword">null</span>) {</div><div class="line">			inOrder(root.left);</div><div class="line">			System.out.print(root.key + <span class="string">"\t"</span>);</div><div class="line">			inOrder(root.right);</div><div class="line">		}</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> Node&lt;T&gt; <span class="title">search</span>(Node&lt;T&gt; tree, T key){</div><div class="line">		<span class="keyword">if</span> (tree == <span class="keyword">null</span> || key == tree.key) {</div><div class="line">			<span class="keyword">return</span> tree;</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">int</span> cmp = key.compareTo(tree.key);</div><div class="line">		<span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) {</div><div class="line">			<span class="keyword">return</span> search(tree.left, key);</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			<span class="keyword">return</span> search(tree.right, key);</div><div class="line">		}</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> Node&lt;T&gt; <span class="title">searchNode</span>(Node&lt;T&gt; tree, T key){</div><div class="line">		<span class="keyword">while</span> (tree != <span class="keyword">null</span> && key != tree.key) {</div><div class="line">			<span class="keyword">int</span> cmp = key.compareTo(tree.key);</div><div class="line">			<span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) {</div><div class="line">				tree = tree.left;</div><div class="line">			}<span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) {</div><div class="line">				tree = tree.right;</div><div class="line">			}</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> tree;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> Node&lt;T&gt; <span class="title">minNode</span>(Node&lt;T&gt; tree){</div><div class="line">		<span class="keyword">while</span> (tree.left != <span class="keyword">null</span>) {</div><div class="line">			tree = tree.left;</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> tree;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> Node&lt;T&gt; <span class="title">maxNode</span>(Node&lt;T&gt; tree){</div><div class="line">		<span class="keyword">while</span> (tree.right != <span class="keyword">null</span>) {</div><div class="line">			tree = tree.right;</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> tree;</div><div class="line">	}</div><div class="line">	<span class="javadoc">/**</span></div><div class="line">	 * 如果x没有右孩子。则x有以下两种可能：</div><div class="line">	 * (01) x是"一个左孩子"，则"x的后继结点"为 "它的父结点"。</div><div class="line">	 * (02) x是"一个右孩子"，则查找"是其父节点的左儿子的节点"为止，找到的这个"最低的父结点"就是"x的后继结点"。</div><div class="line">	 *<span class="javadoctag"> @param</span> x</div><div class="line">	 *<span class="javadoctag"> @return</span></div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> Node&lt;T&gt; <span class="title">successor</span>(Node&lt;T&gt; x){</div><div class="line">		<span class="comment">// 如果x存在右孩子，则"x的后继结点"为 "以其右孩子为根的子树的最小结点"。</span></div><div class="line">		<span class="keyword">if</span> (x.right != <span class="keyword">null</span>) {</div><div class="line">			<span class="keyword">return</span> minNode(x.right);</div><div class="line">		}</div><div class="line">		Node&lt;T&gt; before = x.parent;</div><div class="line">		<span class="keyword">while</span> (before != <span class="keyword">null</span> && x == before.right) {</div><div class="line">			x = before;</div><div class="line">			before = before.parent;</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> before;</div><div class="line">	}</div><div class="line">	<span class="comment">// 如果x没有左孩子。则x有以下两种可能：</span></div><div class="line">	<span class="comment">// (01) x是"一个右孩子"，则"x的前驱结点"为 "它的父结点"。</span></div><div class="line">	<span class="comment">// (01) x是"一个左孩子"，则查找"是其父节点的右儿子节点"，找到的这个"最低的父结点"就是"x的前驱结点"。</span></div><div class="line">	<span class="keyword">public</span> Node&lt;T&gt; <span class="title">preDecessor</span>(Node&lt;T&gt; x){</div><div class="line">		<span class="keyword">if</span> (x.left != <span class="keyword">null</span>) {</div><div class="line">			<span class="keyword">return</span> maxNode(x.left);</div><div class="line">		}</div><div class="line">		Node&lt;T&gt; before = x.parent;</div><div class="line">		<span class="keyword">while</span> (before != <span class="keyword">null</span> && x == before.left) {</div><div class="line">			x = before;</div><div class="line">			before = before.right;</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> before;</div><div class="line">	}</div><div class="line">	<span class="javadoc">/**</span></div><div class="line">	 * 先找到插入位置的父节点，如果父节点为null，则插到父节点，否则插入左或右节点</div><div class="line">	 *<span class="javadoctag"> @param</span> tree</div><div class="line">	 *<span class="javadoctag"> @param</span> node 待插入节点</div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertNode</span>(Node&lt;T&gt; tree, Node&lt;T&gt; node){</div><div class="line">		Node&lt;T&gt; before = <span class="keyword">null</span>;</div><div class="line">		Node&lt;T&gt; index = tree;</div><div class="line">		<span class="keyword">while</span> (index != <span class="keyword">null</span>) {</div><div class="line">			before = index;</div><div class="line">			<span class="keyword">if</span> (node.key.compareTo(index.key) &lt; <span class="number">0</span>) {</div><div class="line">				index = index.left;</div><div class="line">			}<span class="keyword">else</span> {</div><div class="line">				index = index.right;</div><div class="line">			}</div><div class="line">		}</div><div class="line">		node.parent = before;</div><div class="line">		<span class="keyword">if</span> (before == <span class="keyword">null</span>) {</div><div class="line">			tree = node;</div><div class="line">		}<span class="keyword">else</span> <span class="keyword">if</span> (node.key.compareTo(before.key) &lt; <span class="number">0</span>) {</div><div class="line">			before.left = node;</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			before.right = node;</div><div class="line">		}</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> Node&lt;T&gt; <span class="title">remove</span>(Node&lt;T&gt; tree, T key){</div><div class="line">		Node&lt;T&gt; node = search(tree, key);</div><div class="line">		<span class="keyword">if</span> (node == <span class="keyword">null</span>) {</div><div class="line">			<span class="keyword">return</span> node;</div><div class="line">		}</div><div class="line">		Node&lt;T&gt; index = <span class="keyword">null</span>;</div><div class="line">		Node&lt;T&gt; child = <span class="keyword">null</span>;</div><div class="line">		<span class="keyword">if</span> (node.left == <span class="keyword">null</span> || node.left == <span class="keyword">null</span>) {</div><div class="line">			index = node;</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			index = successor(node);</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (index.left != <span class="keyword">null</span>) {</div><div class="line">			child = index.left;</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			child = index.right;</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (child != <span class="keyword">null</span>) {</div><div class="line">			child.parent = index.parent;</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (index.parent == <span class="keyword">null</span>) {</div><div class="line">			tree = child;</div><div class="line">		}<span class="keyword">else</span> <span class="keyword">if</span> (index == index.parent.left) {</div><div class="line">			index.parent.left = child;</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			index.parent.right = child;</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (index != node) {</div><div class="line">			node.key = index.key;</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> index;</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[二叉查找树是一种数据结构，支持多种动态集合操作。在二叉查找树上执行的基本操作时间与树高成正比。]]>
    
    </summary>
    
      <category term="Tree" scheme="http://alexyyek.github.io/tags/Tree/"/>
    
      <category term="coding" scheme="http://alexyyek.github.io/tags/coding/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[哈希碰撞]]></title>
    <link href="http://alexyyek.github.io/2014/12/14/hashCollapse/"/>
    <id>http://alexyyek.github.io/2014/12/14/hashCollapse/</id>
    <published>2014-12-14T11:46:07.000Z</published>
    <updated>2014-12-16T13:59:47.000Z</updated>
    <content type="html"><![CDATA[<h2 id="链地址法">链地址法</h2>
<p>Java.util.Hashtable类实现了JAVA中的哈希表，内部采用Entry[]数组，每个Entry均可作为链表的头，用来解决哈希碰撞。</p>
<h3 id="Hashtable特点"><strong>Hashtable特点</strong></h3>
<ul>
<li>线程安全，能用于多线程环境中。</li>
<li>Key、Value均不能为null。</li>
<li>Hashtable同样实现了Serializable接口，它支持序列化，实现了Cloneable接口，能被克隆。</li>
<li>包含了一个Entry[]数组，而Entry又是一个链表，用来处理冲突。</li>
<li>每个Key对应了Entry数组中固定的位置（记为index），称为槽位（Slot）。槽位计算公式为：<pre><code>       (key.hash<span class="variable">Code</span>() &amp; <span class="number">0</span>x7<span class="variable">FFFFFFF</span>) <span class="comment">% Entry[].length() </span>
</code></pre></li>
<li>当Entry[]的实际元素数量（Count）超过了分配容量（Capacity）的75%时，新建一个Entry[]是原先的2倍，重新Hash（rehash）。</li>
<li>rehash的核心思路是，将旧Entry[]数组的元素重新计算槽位，散列到新Entry[]中。<br><br></li>
</ul>
<hr>
<h3 id="Hashtable源码分析"><strong>Hashtable源码分析</strong></h3>
<p><strong>Entry类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class Entry&lt;K,V&gt; <span class="comment">// Entry&lt;K,V&gt;是槽中的元素，可做链表，解决散列冲突。</span></div><div class="line">{</div><div class="line">     <span class="keyword">int</span> hash; <span class="comment">// 即key.hashCode()</span></div><div class="line">     K key;</div><div class="line">     V value;</div><div class="line">     Entry&lt;K,V&gt; next; <span class="comment">// 用来实现链表结构。同一链表中的key的hash是相同的。</span></div><div class="line">     <span class="keyword">protected</span> <span class="title">Entry</span>(<span class="keyword">int</span> hash, K key, V value, Entry&lt;K,V&gt; next) {</div><div class="line">          <span class="keyword">this</span>.hash=hash;<span class="keyword">this</span>.key=key;<span class="keyword">this</span>.value=value;<span class="keyword">this</span>.next=next;</div><div class="line">     }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><br><br><strong>构造函数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="title">Hashtable</span>(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor) {</div><div class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</div><div class="line">                initialCapacity);</div><div class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Load: "</span>+loadFactor);</div><div class="line"> </div><div class="line">    <span class="keyword">if</span> (initialCapacity==<span class="number">0</span>)</div><div class="line">        initialCapacity = <span class="number">1</span>;</div><div class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</div><div class="line">    table = <span class="keyword">new</span> Entry&lt;?,?&gt;[initialCapacity];</div><div class="line">    threshold = (<span class="keyword">int</span>)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</div><div class="line">}</div><div class="line"> </div><div class="line"><span class="javadoc">/**</span></div><div class="line"> * Constructs a new, empty hashtable with the specified initial capacity</div><div class="line"> * and default load factor (0.75).</div><div class="line"> *<span class="javadoctag"> @param</span>     initialCapacity   the initial capacity of the hashtable.</div><div class="line"> *<span class="javadoctag"> @exception</span> IllegalArgumentException if the initial capacity is less</div><div class="line"> *              than zero.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="title">Hashtable</span>(<span class="keyword">int</span> initialCapacity) {</div><div class="line">    <span class="keyword">this</span>(initialCapacity, <span class="number">0.75</span>f);</div><div class="line">}</div><div class="line"> </div><div class="line"><span class="javadoc">/**</span></div><div class="line"> * Constructs a new, empty hashtable with a default initial capacity (11)</div><div class="line"> * and load factor (0.75).</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="title">Hashtable</span>() {</div><div class="line">    <span class="keyword">this</span>(<span class="number">11</span>, <span class="number">0.75</span>f);</div><div class="line">}</div></pre></td></tr></table></figure>

<ul>
<li>threshold：Hashtable的阈值，用于判断是否需要调整Hashtable的容量。threshold的值=”容量*加载因子”</li>
<li>loadFactor：加载因子，通常设为<strong><code>0.75</code></strong><br><br></li>
</ul>
<p><strong>hashcode</strong><br>考虑一种情况，当向集合中插入对象时，如何判别在集合中是否已经存在该对象了？（注意：集合中不允许重复的元素存在）。</p>
<p>也许大多数人都会想到调用equals方法来逐个进行比较，这个方法确实可行。但是如果集合中已经存在一万条数据或者更多的数据，如果采用equals方法去逐一比较，效率必然是一个问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">containsKey</span>(Object key) {</div><div class="line">    Entry&lt;?,?&gt; tab[] = table;</div><div class="line">    <span class="keyword">int</span> hash = key.hashCode();</div><div class="line">    <span class="keyword">int</span> index = (hash & <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">    <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) {</div><div class="line">        <span class="keyword">if</span> ((e.hash == hash) && e.key.equals(key)) {</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>当集合要添加新的对象时，先调用这个对象的hashCode方法，得到对应的hashcode值(实际上在HashMap的具体实现中会用一个table保存已经存进去的对象的hashcode值)；</p>
<ul>
<li>if（table中没有该hashcode值），then → 直接存进去</li>
<li>if（存在该hashcode值），then → 调用equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址<br>所以这里存在一个冲突解决的问题，这样一来实际调用equals方法的次数就大大降低了，说通俗一点：<strong>Java中的hashCode方法就是根据一定的规则将与对象相关的信息（比如对象的存储地址，对象的字段等）映射成一个数值，这个数值称作为散列值。</strong><br><br></li>
</ul>
<p><strong>addEntry</strong><br>addEntry方法实现向Hashtable中添加k-v值对</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addEntry</span>(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> index) {</div><div class="line">    modCount++;</div><div class="line"> </div><div class="line">    Entry&lt;?,?&gt; tab[] = table;</div><div class="line">    <span class="keyword">if</span> (count &gt;= threshold) {</div><div class="line">        <span class="comment">// Rehash the table if the threshold is exceeded</span></div><div class="line">        rehash();</div><div class="line"> </div><div class="line">        tab = table;</div><div class="line">        hash = key.hashCode();</div><div class="line">        index = (hash & <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">    }</div><div class="line"> </div><div class="line">    <span class="comment">// Creates the new entry.</span></div><div class="line">    <span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index]; <span class="comment">// 旧有Entry</span></div><div class="line">    tab[index] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e); <span class="comment">/* 旧有Entry成为了新增Entry的next */</span></div><div class="line">    count++;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>当count大于阀值时，要重新进行hash，重新确定Hashtable的大小<br><br></p>
<p><strong>rehash</strong><br>rehash方法即再次hash，当Entry[]的实际存储数量占分配容量的约75%时，扩容并且重新计算各个对象的槽位</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rehash</span>() {</div><div class="line">          <span class="keyword">int</span> oldCapacity = table.length;</div><div class="line">          Entry[] oldMap = table;</div><div class="line">          <span class="keyword">int</span> newCapacity = (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// 2倍+1</span></div><div class="line">          Entry[] newMap = <span class="keyword">new</span> Entry[newCapacity];</div><div class="line">          threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</div><div class="line">          table = newMap;</div><div class="line"> </div><div class="line">          <span class="keyword">for</span>( <span class="keyword">int</span> i=oldCapacity; i-- &gt;<span class="number">0</span>;){ <span class="comment">//  i的取值范围为 [oldCapacity-1,0]</span></div><div class="line">               <span class="keyword">for</span> (Entry&lt;K,V&gt; old = oldMap[i]; old!=<span class="keyword">null</span>;){ <span class="comment">// 遍历旧Entry[]</span></div><div class="line">                    Entry&lt;K,V&gt; e = old;</div><div class="line">                    <span class="comment">//重新计算各个元素在新Entry[]中的槽位index。</span></div><div class="line">                    <span class="keyword">int</span> index = (e.hash & <span class="number">0x7FFFFFFF</span>) % newCapacity;     </div><div class="line">                    e.next = newMap[index]; <span class="comment">// 已经存在槽位中的Entry成为了新增Entry的next </span></div><div class="line">                    newMap[index]=e;     <span class="comment">// 放到槽位中</span></div><div class="line">                    old = old.next;</div><div class="line">               }</div><div class="line">          }</div><div class="line"> </div><div class="line">     }</div></pre></td></tr></table></figure>

<p><br></p>
<hr>
<h3 id="Hashtable源码总结">Hashtable源码总结</h3>
<p><strong>1</strong>. <strong>关于hashCode()和equals()方法</strong><br>下面这段话摘自Effective Java一书：</p>
<blockquote>
<ul>
<li>在程序执行期间，只要equals方法的比较操作用到的信息没有被修改，那么对这同一个对象调用多次，hashCode方法必须始终如一地返回同一个整数。</li>
<li>如果两个对象根据equals方法比较是相等的，那么调用两个对象的hashCode方法必须返回相同的整数结果。</li>
<li>如果两个对象根据equals方法比较是不等的，则hashCode方法不一定得返回不同的整数。</li>
</ul>
</blockquote>
<p>对于第二条和第三条很好理解，但是第一条，很多时候就会忽略。在《Java编程思想》一书中的P495页也有同第一条类似的一段话：</p>
<blockquote>
<p>设计hashCode()时最重要的因素就是：无论何时，对同一个对象调用hashCode()都应该产生同样的值。如果在讲一个对象用put()添加进HashMap时产生一个hashCdoe值，而用get()取出时却产生了另一个hashCode值，那么就无法获取该对象了。</p>
</blockquote>
<p><strong>所以如果你的hashCode方法依赖于对象中易变的数据，用户就要当心了，因为此数据发生变化时，hashCode()方法就会生成一个不同的散列码。</strong></p>
<p><br><br><strong>2</strong>. <strong>Hashtable中key和value都不允许为null</strong><br>而HashMap中key和value都允许为null（key只能有一个为null，而value则可以有多个为null）。但是如果在Hashtable中有类似put(null,null)的操作，编译同样可以通过，因为key和value都是Object类型，但运行时会抛出NullPointerException异常，这是JDK的规范规定的。<br><br><br><strong>3</strong>. <strong>Hashtable计算hash值</strong><br>直接用key的hashCode()，而HashMap重新计算了key的hash值，Hashtable在求hash值对应的位置索引时，用取模运算，而HashMap在求位置索引时，则用与运算，且这里一般先用hash&amp;0x7FFFFFFF后，再对length取模，&amp;0x7FFFFFFF的目的是为了将负的hash值转化为正值，因为hash值有可能为负数，而&amp;0x7FFFFFFF后，<strong>只有符号外改变，而后面的位都不变</strong> 。</p>
<p><br></p>
<hr>
<h3 id="链地址法性能分析">链地址法性能分析</h3>
<p>给定一个能存放n个元素，具有m个槽位的散列表T，定义T的装载因子$a=n/m$，即一个链中的平均元素数。假定可以在<code>O(1)</code>的时间内计算出散列值h(k)，即计算散列函数和寻址槽h(k)为<code>O(1)</code>时间。现查找元素k：</p>
<ul>
<li><p>一次不成功情况<br>在简单一致散列的假设下。一次不成功查找的<code>期望</code>时间为<code>0(1+a)</code><br>一次不成功即查找遍整个散列表<code>T[h(k)]</code>，平均每个链表查找元素为$a=n/m$，加上计算哈希h(k)的时间，总时间为<code>O(1+a)</code></p>
</li>
<li><p>一次成功情况<br>在简单一致散列的假设下。一次成功查找的期望时间为<code>0(1+a)</code><br><center> <img src="http://7rf27k.com1.z0.glb.clouddn.com/QQ图片20141215121340.png" alt=""> <center></center></center></p>
</li>
</ul>
<p>由于链表中新元素是在表头插入的，所以一次成功的查找中，所检查的元素数比x所在链表中出现在x前面的元素数多1<br>在hash值为index的槽位，一次成功的查找中，所检查元素的期望为：</p>
<p>$E\ [1/n·\sum_{i=1}^n(1+\sum_{j=i+1}^n X_{ij})]$</p>
<p>$=1/n·\sum_{i=1}^n(1+\sum_{j=i+1}^n E[X_{ij}])=1/n·\sum_{i=1}^n(1+\sum_{j=i+1}^n1/m)$</p>
<p>$=1+1/{mn}(\sum_{i=1}^nn-\sum_{i=1}^ni)=1+1/{mn}(n^2-n(n+1)/2)$</p>
<p>$=1+(n-1_/2m)=1+a/2-a/2n$</p>
<p>于是，一次成功的查找所需全部时间为<code>O(2+a/2-a/2n)</code>=<code>O(1+a)</code>.</p>
<p><strong>Conclusion</strong>：如果散列表中槽位数至少与表中的元素数成正比，则有n=O(m)，从而 $a=n/m=O(m)/m=O(1)$<br>所以平均查找操作需要常数量的时间，且已经知道插入操作最坏情况需要<code>O(1)</code>，删除操作最坏需要<code>O(1)</code>，因而全部字典操作可以在<code>O(1)</code>时间完成。</p>
<h2 id="开放寻址法">开放寻址法</h2>
<p>前面讲的方法主要基于用链表的方法解决哈希冲突，但元素数n大于槽位数m时，必然会导致至少一个槽位被多个元素hash到，因此链地址法的查询性能平均为<code>O(1+a)</code>，不能达到理想的<code>O(1)</code>。<br>开放寻址法中，所有的元素都存放在散列表里，即每个表项是动态集合中的一个元素，或者为NIL。当要插入一个元素时，可以连续的检查散列表的各项,直到找个一个空槽来存放待插入元素，整个数组必须支持<code>动态扩容</code>：当数组空闲节点低于一个阀值时，将扩展数组容量为原来的一倍。这个阀值通常是<code>0.72</code>。当然检查的顺序不一定是0,1,…,m-1，主要分为下面三种探查方法：</p>
<h3 id="线性探查">线性探查</h3>
<p>将散列表T[0,1,…,m-1]看成是一个循环向量，若初始探查的地址为d(即h(key)=d)，则最长的探查序列为：</p>
<p><center> $d，d+l，d+2，…，m-1，0，1，…，d-1$ <center></center></center></p>
<p>散列函数为</p>
<p><center> $h(k,i)=(h^*(k)+i) \ mod \ m \ , \ i=0,1,…,m-1$ <center></center></center></p>
<p>探查过程终止于三种情况：</p>
<ol>
<li>若当前探查的单元为空，则表示查找失败（若是插入则将key写入其中）；</li>
<li>若当前探查的单元中含有key，则查找成功，但对于插入意味着失败；</li>
<li>若探查到T[d-1]时仍未发现空单元也未找到key，则无论是查找还是插入均意味着失败(此时表满)。</li>
</ol>
<p><center> <img src="http://7rf27k.com1.z0.glb.clouddn.com/直接寻址.jpg" alt=""> <center> </center></center></p>
<p>用线性探测法处理冲突，思路清晰，算法简单，但存在下列缺点：</p>
<ul>
<li>处理溢出需另编程序。一般可另外设立一个溢出表，专门存放哈希表中放不下的记录。此溢出表最简单的结构是顺序表，查找方法可用顺序查找。</li>
<li>按上述算法建立起来的哈希表，删除工作非常困难。假如要从哈希表中删除一个记录，按理应将这个记录所在位置置为空，但我们不能这样做，而只能标上已被删除的标记<code>DELETE</code>，否则，将会影响以后的查找。</li>
<li>线性探测法很容易产生堆聚现象。所谓堆聚现象，就是存入哈希表的记录在表中连成一片。按照线性探测法处理冲突，如果生成哈希地址的连续序列愈长（即不同关键字值的哈希地址相邻在一起愈长），则当新的记录加入该表时，与这个序列发生冲突的可能性愈大。因此，哈希地址的较长连续序列比较短连续序列生长得快，这就意味着，一旦出现堆聚 ( 伴随着冲突 ) ，就将引起进一步的堆聚。</li>
</ul>
<p><strong>线性补偿探测法</strong><br>线性补偿探测法的基本思想是：将线性探测的步长从 1 改为 Q ，即将上述算法中的 </p>
<p>$h(k,i)=(h^”(k)+1) \ mod \ m$ 改为 $h(k,i)=(h^”(k)+Q) \ mod \ m$ </p>
<p>而且要求 Q 与 m 是<code>互质</code>的，以便能探测到哈希表中的所有单元。<br><br></p>
<hr>
<h3 id="二次探查">二次探查</h3>
<p>二次探查采用如下形式的散列函数：</p>
<p><center> $h(k,i)=(h^*(k)+c_1i+c_2i^2) \ mod \ m \ , \ i=0,1,…,m-1, \ c_2\not=0$ <center></center></center></p>
<p>其中$h^*(k)$是一个辅助散列函数，$c_1$和 $c_2$为辅助常数。初始的探查位置为$T[h^*(k)]$，后续的探查位置要加上一个偏移量，该偏移量以二次的方式依赖于探查序号i。这种探查方法的效果要比线性探查好很多，但是，为了能够充分利用散列表，$c_1$，$c_2$和 $m$的值要受到限制。此外，如果两个关键字的初始探查位置相同，那么它们的探查序列也是相同的。这一性质可导致一种轻度的群集，称为二次群集。<br><br></p>
<hr>
<h3 id="双重散列">双重散列</h3>
<p>双重散列是用于开放寻址最好的方法之一，它采用如下形式的散列函数：</p>
<p><center> $h(k,i)=(h_1(k)+ih_2(k)) \ mod \ m$ <center></center></center></p>
<p>为了能查找整个散列表，值$h_2(k)$要与表的大小m<code>互质</code>，确保这一条件成立的方法有两种</p>
<ol>
<li>取m为2的幂，并设计一个总产生奇数的$h_2$</li>
<li>取m为质数，并设计一个总是产生较m小的正整数的$h_2$</li>
</ol>
<p>例如下图所示，散列表大小为 $m=13$，$h_1(k)=k \ mod \ 13$, $h_2(k)=1+(k \ mod \ 11)$，因为$14\equiv1\ (mod\ 13)$，$14\equiv3\ (mod\ 11)$，故在探查了槽1和槽5并发现被占用后，关键字14被插入到空槽9中。</p>
<p><center> <img src="http://7rf27k.com1.z0.glb.clouddn.com/QQ图片20141215204708.png" alt=""> <center></center></center></p>
<p>双重散列法中用了$O(m^2)$种探查序列，而线性探查或二次探查中用了$O(m)$种，所以是一种改进。<br><br></p>
<hr>
<h3 id="开放寻址散列性能分析">开放寻址散列性能分析</h3>
<p>在开放寻址法中，每个槽位至多只有一个元素，因而 $n\leq m$，这意味着 $n \leq 1$<br>下面分析在<code>一致散列</code>假设下，用开放寻址法进行散列时预期的探查数</p>
<ul>
<li>给定一个装载因子为$a=n/m&lt;1$的开放寻址散列表，在<code>一次不成功</code>的查找中，期望的探查数至多为：$\frac{1}{(1-a)}$</li>
<li>给定一个装载因子为$a&lt;1$的开放寻址散列表，<code>一次成功</code>查找中的期望探查数至多为：$\frac{1}{a}·ln\frac{1}{1-a}$</li>
</ul>
<h2 id="Java代码实现">Java代码实现</h2>
<h3 id="Hashtable链地址法">Hashtable链地址法</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> Practice;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Objects;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>{</div><div class="line">	<span class="keyword">private</span> Entry&lt;K, V&gt;[] table;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> threhold;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">float</span> loadFactor;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>{</div><div class="line">		<span class="keyword">int</span> hash;</div><div class="line">		K key;</div><div class="line">		V value;</div><div class="line">		Entry next;</div><div class="line"></div><div class="line">		<span class="keyword">public</span> <span class="title">Entry</span>() {</div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">public</span> <span class="title">Entry</span>(<span class="keyword">int</span> hash, K key, V value, Entry next) {</div><div class="line">			<span class="keyword">this</span>.hash = hash;</div><div class="line">			<span class="keyword">this</span>.key = key;</div><div class="line">			<span class="keyword">this</span>.value = value;</div><div class="line">			<span class="keyword">this</span>.next = next;</div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">public</span> K <span class="title">getKey</span>() {</div><div class="line">			<span class="keyword">return</span> key;</div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">public</span> V <span class="title">getValue</span>() {</div><div class="line">			<span class="keyword">return</span> value;</div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">public</span> V <span class="title">setValue</span>(V value) {</div><div class="line">			<span class="keyword">if</span> (value == <span class="keyword">null</span>) {</div><div class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">			}</div><div class="line">			V old = <span class="keyword">this</span>.value;</div><div class="line">			<span class="keyword">this</span>.value = value;</div><div class="line">			<span class="keyword">return</span> old;</div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span>(Object o) {</div><div class="line">			<span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Entry)) {</div><div class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">			}</div><div class="line">			Entry&lt;K, V&gt; e = (Entry&lt;K, V&gt;) o;</div><div class="line">			<span class="keyword">return</span> (key == <span class="keyword">null</span> ? e.getKey() == <span class="keyword">null</span> : key.equals(e.getKey()))</div><div class="line">					&& (value == <span class="keyword">null</span> ? e.getValue() == <span class="keyword">null</span> : value.equals(e</div><div class="line">							.getValue()));</div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashcode</span>() {</div><div class="line">			<span class="keyword">return</span> hash ^ Objects.hashCode(value);</div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">public</span> String <span class="title">toString</span>() {</div><div class="line">			<span class="keyword">return</span> key.toString() + <span class="string">"="</span> + value.toString();</div><div class="line">		}</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="title">Hashtable</span>(<span class="keyword">int</span> initCapacity, <span class="keyword">float</span> loadFactor) {</div><div class="line">		<span class="keyword">if</span> (initCapacity &lt; <span class="number">0</span>)</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity"</span></div><div class="line">					+ initCapacity);</div><div class="line">		<span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Load"</span> + loadFactor);</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (initCapacity == <span class="number">0</span>)</div><div class="line">			initCapacity = <span class="number">1</span>;</div><div class="line">		<span class="keyword">this</span>.loadFactor = loadFactor;</div><div class="line">		table = <span class="keyword">new</span> Entry[initCapacity];</div><div class="line">		threhold = (<span class="keyword">int</span>) Math</div><div class="line">				.min(initCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="title">Hashtable</span>(<span class="keyword">int</span> initCapacity) {</div><div class="line">		<span class="keyword">this</span>(initCapacity, <span class="number">0.75</span>f);</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="title">Hashtable</span>() {</div><div class="line">		<span class="keyword">this</span>(<span class="number">11</span>, <span class="number">0.75</span>f);</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">size</span>() {</div><div class="line">		<span class="keyword">return</span> count;</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span>(K key, V value) {</div><div class="line">		<span class="keyword">if</span> (value == <span class="keyword">null</span>) {</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">		}</div><div class="line"></div><div class="line">		Entry&lt;?, ?&gt; tab[] = table;</div><div class="line">		<span class="keyword">int</span> hash = key.hashCode();</div><div class="line">		<span class="keyword">int</span> index = (hash & <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">		<span class="keyword">for</span> (Entry&lt;K, V&gt; entry = (Entry&lt;K, V&gt;) tab[index]; entry != <span class="keyword">null</span>; entry = entry.next) {</div><div class="line">			<span class="keyword">if</span> ((entry.hash == hash) && entry.key.equals(key)) {</div><div class="line">				V old = entry.value;</div><div class="line">				entry.value = value;</div><div class="line">				<span class="keyword">return</span> old;</div><div class="line">			}</div><div class="line">		}</div><div class="line">		<span class="keyword">if</span> (count &gt; threhold) {</div><div class="line">			rehash();</div><div class="line">			tab = table;</div><div class="line">			hash = key.hashCode();</div><div class="line">			index = (hash & <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">		Entry&lt;K, V&gt; entry = (Entry&lt;K, V&gt;) tab[index];</div><div class="line">		tab[index] = <span class="keyword">new</span> Entry&lt;K, V&gt;(hash, key, value, entry);</div><div class="line">		count ++;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span>(Object key){</div><div class="line">		Entry&lt;?, ?&gt; tab[] = table;</div><div class="line">		<span class="keyword">int</span> hash = key.hashCode();</div><div class="line">		<span class="keyword">int</span> index = (hash & <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">		<span class="keyword">for</span> (Entry&lt;K, V&gt; e = (Entry&lt;K, V&gt;) tab[index]; e != <span class="keyword">null</span> ; e = e.next) {</div><div class="line">			<span class="keyword">if</span> (e.hash == hash && e.key.equals(key)) {</div><div class="line">				<span class="keyword">return</span> e.value;</div><div class="line">			}</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rehash</span>(){</div><div class="line">		<span class="keyword">int</span> oldCapacity = table.length;</div><div class="line">		Entry&lt;?, ?&gt;[] oldEntry = table;</div><div class="line">		</div><div class="line">		<span class="keyword">int</span> newCapacity = (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</div><div class="line">		</div><div class="line">		Entry[]	newMap = <span class="keyword">new</span> Entry[newCapacity];</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = oldCapacity; i &gt; <span class="number">0</span>; i--) {</div><div class="line">			<span class="keyword">for</span> (Entry&lt;K, V&gt; e = (Entry&lt;K, V&gt;) oldEntry[i];  e != <span class="keyword">null</span>; e = e.next) {</div><div class="line">				<span class="keyword">int</span> index = (e.hash & <span class="number">0x7FFFFFFF</span>) % newCapacity;</div><div class="line">				e.next = newMap[index];</div><div class="line">				newMap[index] = e;</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String arg[]) {</div><div class="line">        Hashtable&lt;String, String&gt; hashtable = <span class="keyword">new</span> Hashtable&lt;String, String&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) {</div><div class="line">            hashtable.put(<span class="string">"lyx"</span> + i, <span class="string">"lyx"</span> + i);</div><div class="line">        }</div><div class="line"> </div><div class="line">        hashtable.put(<span class="string">"lyx0"</span>, <span class="string">"aaaaaaaaaaaaaaaaaaaaa"</span>);</div><div class="line">        hashtable.put(<span class="string">"lyx0"</span>, <span class="string">"aaaaaaaaaaaaaaaaaaaaa"</span>);</div><div class="line">        hashtable.put(<span class="string">"lyx0"</span>, <span class="string">"aaaaaaaaaaaaaaaaaaaaa"</span>);</div><div class="line">        hashtable.put(<span class="string">"lyx0"</span>, <span class="string">"aabbccdd"</span>);</div><div class="line"> </div><div class="line">        System.out.println(hashtable.get(<span class="string">"lyx0"</span>));</div><div class="line">        System.out.println(hashtable.get(<span class="string">"lyx1"</span>));</div><div class="line">        System.out.println(hashtable.get(<span class="string">"lyx2"</span>));</div><div class="line">        System.out.println(hashtable.get(<span class="string">"lyx3"</span>));</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>


<h3 id="线性探查-1">线性探查</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> Practice;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.nio.BufferOverflowException;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinearProbingHash</span>&lt;<span class="title">T</span>&gt; </span>{</div><div class="line">	<span class="keyword">private</span> T[] table;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> tableCapacity;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> size;</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="title">LinearProbingHash</span>(<span class="keyword">int</span> tableSize){</div><div class="line">		table = (T[]) <span class="keyword">new</span> Object[tableSize];</div><div class="line">		<span class="keyword">this</span>.tableCapacity = tableSize;</div><div class="line">		size = <span class="number">0</span>;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span>(T item){</div><div class="line">		<span class="keyword">int</span> index, originIndex;</div><div class="line">		index = (item.hashCode() & <span class="number">0x7FFFFFFF</span>) % tableCapacity;</div><div class="line">		originIndex = index;</div><div class="line">		do {</div><div class="line">			<span class="keyword">if</span> (table[index] == <span class="keyword">null</span> || table[index].equals(<span class="string">"DELETE"</span>)) {</div><div class="line">				table[index] = item;</div><div class="line">				size++;</div><div class="line">				<span class="keyword">return</span>;</div><div class="line">			}<span class="keyword">else</span> {</div><div class="line">				index = (index + <span class="number">1</span>) % tableCapacity;</div><div class="line">			}</div><div class="line">		} <span class="keyword">while</span> (index != originIndex);</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BufferOverflowException();</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span>(T item){</div><div class="line">		<span class="keyword">int</span> index, originIndex;</div><div class="line">		index = (item.hashCode() & <span class="number">0x7FFFFFFF</span>) % tableCapacity;</div><div class="line">		originIndex = index;</div><div class="line">		do {</div><div class="line">			<span class="keyword">if</span> (table[index].equals(item)) {</div><div class="line">				table[index] = (T) <span class="string">"DELETE"</span>;</div><div class="line">				size--;</div><div class="line">				<span class="keyword">return</span> index;</div><div class="line">			}<span class="keyword">else</span> {</div><div class="line">				index = (index & <span class="number">0x7FFFFFFF</span>) % tableCapacity;</div><div class="line">			}</div><div class="line">		} <span class="keyword">while</span> (index != originIndex);</div><div class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span>(T item){</div><div class="line">		<span class="keyword">return</span> (find(item) &lt; <span class="number">0</span>) ? <span class="keyword">false</span> : <span class="keyword">true</span>;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span>(){</div><div class="line">		<span class="keyword">return</span> size;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span>(T item){</div><div class="line">		<span class="keyword">int</span> index, originIndex;</div><div class="line">		index = (item.hashCode() & <span class="number">0x7FFFFFFF</span>) % tableCapacity;</div><div class="line">		originIndex = index;</div><div class="line">		do {</div><div class="line">			<span class="keyword">if</span> (table[index].equals(item)) {</div><div class="line">				<span class="keyword">return</span> index;</div><div class="line">			}<span class="keyword">else</span> {</div><div class="line">				index = (index + <span class="number">1</span>) % tableCapacity;</div><div class="line">			}</div><div class="line">		} <span class="keyword">while</span> (index != originIndex);</div><div class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> String <span class="title">toString</span>() {  </div><div class="line">        <span class="keyword">int</span> max = tableCapacity - <span class="number">1</span>;  </div><div class="line">        StringBuffer buf = <span class="keyword">new</span> StringBuffer();  </div><div class="line">        buf.append(<span class="string">"["</span>);  </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tableCapacity; i++) {  </div><div class="line">            <span class="keyword">if</span>(table[i] != <span class="keyword">null</span>) {  </div><div class="line">                buf.append(table[i]);  </div><div class="line">                <span class="keyword">if</span>(i &lt; max)  </div><div class="line">                    buf.append(<span class="string">", "</span>);  </div><div class="line">            }  </div><div class="line">        }  </div><div class="line">        buf.append(<span class="string">"]"</span>);  </div><div class="line">        <span class="keyword">return</span> buf.toString();  </div><div class="line">    }  </div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {  </div><div class="line">        LinearProbingHash&lt;Integer&gt; lp = <span class="keyword">new</span> LinearProbingHash&lt;Integer&gt;(<span class="number">10</span>);  </div><div class="line">        lp.add(<span class="keyword">new</span> Integer(<span class="number">54</span>));  </div><div class="line">        lp.add(<span class="keyword">new</span> Integer(<span class="number">77</span>));  </div><div class="line">        lp.add(<span class="keyword">new</span> Integer(<span class="number">94</span>));  </div><div class="line">        lp.add(<span class="keyword">new</span> Integer(<span class="number">89</span>));  </div><div class="line">        lp.add(<span class="keyword">new</span> Integer(<span class="number">14</span>));  </div><div class="line">        lp.add(<span class="keyword">new</span> Integer(<span class="number">45</span>));  </div><div class="line">        lp.add(<span class="keyword">new</span> Integer(<span class="number">35</span>));  </div><div class="line">        lp.add(<span class="keyword">new</span> Integer(<span class="number">76</span>));  </div><div class="line">          </div><div class="line">        System.out.println(lp); <span class="comment">// [35, 76, 54, 94, 14, 77, 45, 89]  </span></div><div class="line">        System.out.println(lp.contains(<span class="keyword">new</span> Integer(<span class="number">45</span>))); <span class="comment">// true  </span></div><div class="line">        System.out.println(lp.size()); <span class="comment">// 8  </span></div><div class="line">        </div><div class="line">        lp.delete(<span class="keyword">new</span> Integer(<span class="number">77</span>));</div><div class="line">        System.out.println(lp); <span class="comment">// [35, 76, 54, 94, 14, DELETE, 45, 89]</span></div><div class="line">        System.out.println(lp.size()); <span class="comment">// 7</span></div><div class="line">        lp.add(<span class="keyword">new</span> Integer(<span class="number">100</span>));</div><div class="line">        System.out.println(lp); <span class="comment">// [35, 76, 100, 54, 94, 14, DELETE, 45, 89]</span></div><div class="line">        System.out.println(lp.size()); <span class="comment">// 8</span></div><div class="line">    }  </div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[当多个关键字映射到同一槽位时，便发生哈希碰撞。主要解决方案有两种，一种是基于链表的链地址法，另一种则是开放寻址法。]]>
    
    </summary>
    
      <category term="hash" scheme="http://alexyyek.github.io/tags/hash/"/>
    
      <category term="coding" scheme="http://alexyyek.github.io/tags/coding/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
</feed>
